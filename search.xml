<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>阅读笔记-Towards Discriminative Representation:Multi-view Trajectory Contrastive Learning for Online Multi-object Tracking (MTtrack)</title>
    <link href="/jasonyang.github.io/2022/05/27/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-MTtrack/"/>
    <url>/jasonyang.github.io/2022/05/27/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-MTtrack/</url>
    
    <content type="html"><![CDATA[<h1 id="towards-discriminative-representation-multi-view-trajectory-contrastive-learning-for-online-multi-object-tracking">TowardsDiscriminative Representation: Multi-view Trajectory ContrastiveLearning for Online Multi-object Tracking</h1><p>原文链接：https://arxiv.org/pdf/2203.14208.pdf</p><h2 id="阅读疑惑">阅读疑惑</h2><ol type="1"><li>“在推理阶段，开发了一种相似性引导的特征融合策略，以进一步提高轨迹表示的质量。”<ol type="1"><li>计算当前捕获的特征与之前轨迹buffer中的特征的余弦相似度，然后基于此相似度进行加权特征融合。</li></ol></li><li>在回归采样点坐标的时候，中心点特征的维度是<span class="math inline">\(256\times1\)</span>，无论如进行线性变化，最后得到维度都是<span class="math inline">\(N_k \times 1\)</span>，如何确定<span class="math inline">\(x,y\)</span>方向的偏移？<ol type="1"><li>应该是用中心点特征（256）去变换得到<span class="math inline">\(N_k\)</span>个坐标偏移点坐标，即<span class="math inline">\(1 \times 256-&gt;1 \times (N_k \times2)\)</span></li></ol></li></ol><h2 id="行文结构">行文结构</h2><h3 id="提出问题">提出问题</h3><p>最近的工作主要利用单个或相邻帧中的特征来构建度量损失并授权网络来提取目标的表示。尽管这种策略是有效的，但它未能充分利用整个轨迹中包含的信息。许多具有不同身份的对象由于被遮挡或模糊而与相同的轨迹相关联，从而导致学习的表示无法区分。因此，需要提取更有意义和有区别的表示来提高关联的准确性。</p><h3 id="介绍">介绍</h3><ol type="1"><li>将目标外观向量视为查询，并设计对比损失以使它们更靠近相应的轨迹中心，同时远离其他轨迹中心</li><li>LVS （可学习视图采样）用多个自适应选择的关键点而不是锚点或其 2D中心来表示每个目标。</li></ol><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220520090626497.png" alt="image-20220520090626497" style="zoom:60%;"></p><p>使用LVS方法能够让算法自动地去提取目标未遮挡部分的外观信息。</p><p><em>目标的锚点或 2D 中心被其他对象遮挡，而 LVS仍然可以自适应地关注可见区域。</em></p><ol start="3" type="1"><li>在推理阶段，我们注意到某些帧的目标特征不清楚，不适合表示轨迹。相应地，我们设计了一种相似度引导的特征融合（SGFF）策略，该策略基于历史特征相似度自适应地聚合特征，以减轻这些不良特征对轨迹表示的影响</li></ol><h3 id="可学习视图采样">可学习视图采样</h3><p><strong>基于中心点特征向量表示的缺点：</strong></p><ol type="1"><li>目标中心点可能被其他物体遮挡，此时生成的外观向量无法反应目标的特征</li><li>仅用一个向量表示每个目标无法为对比学习算法提供足够的样本。</li></ol><p>提取方法：首先提取目标中心点的特征向量<span class="math inline">\(v_{c}\)</span>表示目标的外观特征，然后使用一个线性变换层去回归<span class="math inline">\(N_k=9\)</span>个采样点相对于中心点的偏置offset，最后限制所有的采样点均在以<span class="math inline">\(c\)</span>为中心点的目标bbox框内。</p><p>对于采样点坐标提取其对应的特征向量<span class="math inline">\(v_i^{k}\)</span>,经过4层FC之后得到增强后的特征表示<span class="math inline">\(\widetilde{v}_i^k\)</span>。</p><blockquote><p>注：在推理阶段，$N_k$个外观向量被合并为一个单独的向量来表示它们对应的目标。</p></blockquote><h3 id="轨迹中心向量记忆库">轨迹中心(向量)记忆库</h3><p>bank存储的是从开始到目前帧所有轨迹的中心特征向量,如果有<span class="math inline">\(N\)</span>个轨迹,则bank的向量维度为<span class="math inline">\(N\times256\)</span>,(假设一个id-embedding的特征向量是256维)</p><ol type="1"><li><p>开发了一种基于动量的更新策略，在每次迭代中动态更新轨迹中心，而不需要历史梯度信息。</p></li><li><p>收集从具有相同轨迹 ID的实例中提取的所有外观向量，以更新它们对应的轨迹中心</p></li><li><p>利用所有外观特征向量中与中心特征向量余弦相似度最小的(最难学习)来更新中心特征.<span class="math display">\[c_{l} \leftarrow \alpha c_{l}+(1-\alpha) p_{m}^{l}\]</span> <span class="math inline">\(c_l\)</span>表示中心向量,<span class="math inline">\(\alpha=0.2\)</span>表示更新阈值,$ p_{m}^{l}<span class="math inline">\(表示轨迹\)</span>l$中最难学习的一条外观特征.</p></li><li><p>在训练阶段，使用难样本更新轨迹中心有助于提高网络训练的效率。我们的实验结果已经证实了这个问题。</p></li></ol><p>使用InfoNCE loss来监督,使得帧内第<span class="math inline">\(k\)</span>个外观特征<span class="math inline">\(\widetilde{v}_l^k\)</span>,与中心特征<span class="math inline">\(c_l\)</span>更加接近,而与其他轨迹的中心特征<span class="math inline">\(c_{other}\)</span>距离更远. <span class="math display">\[L_{N C E}^{k}=-\log \frac{\exp \left(\tilde{v}_{l}^{k} \cdotc_{l}\right) / \tau}{\sum_{i=0}^{N_{t}} \exp \left(\tilde{v}_{l}^{k}\cdot c_{i}\right) / \tau}\]</span></p><p><span class="math display">\[L_{t c l}=\frac{1}{N_{a}} \sum_{k=1}^{N_{a}} L_{N C E}^{k}\]</span></p><blockquote><p><span class="math inline">\(\tau=0.05\)</span>是一个[0-1]的超参数;<span class="math inline">\(N_t\)</span>表示中心数;<span class="math inline">\(N_a\)</span>表示有LVS确定的外观特征采样点数.</p></blockquote><h3 id="外观特征相似度指导的轨迹融合">外观特征相似度指导的轨迹融合</h3><p>保留轨迹前<span class="math inline">\(Q\)</span>帧的外观特征,然后分别计算当前外观特征与之前外观特征的余弦相似度,得到一个加权值,最后将当前帧的特征融合进去.<span class="math display">\[\beta^{t}=\max \left\{0, \frac{1}{Q} \sum_{i=1}^{Q}\Psi_{d}\left(z_{l}^{t}, z_{l}^{t-i}\right)\right\}\]</span></p><blockquote><p><span class="math inline">\(\Psi_{d}\)</span>表示余弦相似度的计算.,<span class="math inline">\(Q=30\)</span></p></blockquote><p>这种以相似度来更新的有BUG，就是如果之前外观特征学得不好，后面学好了但是却一直无法更新,最后的结果就是越学越差。</p><h2 id="总结">总结</h2><p>  LVS从多个目标位置提取外观特征的做法值得借鉴,但是这样提取的特征不足以鲁棒性的表示目标,文章还使用了额外的4个FC来提取更具判别性的特征,这无疑增加了计算成本,同时提出的相似度指导的特征融合能够使用自适应权重,但是其权重却是通过与之前特征的相似度高低的得来的,这样会造成如果之前特征就学习不好的话,后面学好的特征仍无法更新目标外观模型的情况,个人感觉还不如使用可见度或者采样节点的可见度(或者目标的遮挡度)对外观模型进行加权融合.</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220520110352302.png" alt="image-20220520110352302" style="zoom:50%;"></p>]]></content>
    
    
    <categories>
      
      <category>多目标跟踪</category>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Multiple People Tracking by Lifted Multicut and Person Re-identiﬁcation</title>
    <link href="/jasonyang.github.io/2022/05/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-LMP/"/>
    <url>/jasonyang.github.io/2022/05/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-LMP/</url>
    
    <content type="html"><![CDATA[<h1 id="multiple-people-tracking-by-lifted-multicut-and-person-re-identiﬁcation">MultiplePeople Tracking by Lifted Multicut and Person Re-identiﬁcation</h1><p>原文链接：https://openaccess.thecvf.com/content_cvpr_2017/papers/Tang_Multiple_People_Tracking_CVPR_2017_paper.pdf</p><h2 id="主要工作">主要工作</h2><ol type="1"><li><p>将MCLMP融入到多目标跟踪领域</p><p>  MCLMP（Minimum Cost Lifted MulticutProblem）——最小花费改进多边切割问题，之前这类方法主要用在经典的图像分割领域，以像素点或者像素块作为图节点，为节点之间的每条边分配去切断惩罚（边权重，有正有负），在一定的约束条件下对节点间多余的边进行切割（切断图像块与图像块之间的联系，剩余聚合的图像块便可以看作一个具有相同语义的区域）以最小化惩罚，然后得到聚类结果。这类方法最重要的是通过一些合理的节点连接权重的度量函数，衡量节点之间的关系，然后便是利用一些启发式的算法对图进行切割优化。</p><p>  应用到多目标跟踪领域，作者将图的每个节点等效成视频帧中的每个检测到的目标，同一帧中的目标之间可以彼此相连（这里相连的原因是作者对检测得到的bbox没有进行NMS会有一些重复的框），然后对前后相差<span class="math inline">\(\delta_t\)</span>帧的目标也进行连接（通过中心点距离或者bbox或者外观相似的阈值条件确定），此时的连接都是regularedges，另外还有一点就是通过additionaledges去连接部分外观度量特别相似，然后帧间隔大于<span class="math inline">\(\delta_t\)</span>的目标。边的连接权重或者切断惩罚通过下面的向量计算式得到:<span class="math display">\[\begin{array}{c}c_e=\log \frac{1-p_e}{pe}=-&lt;\theta_{\gamma}, f^{(e)}&gt; \\f^{(e)} \leftarrow \left( f_{st}, f_{dm}, f_{reID}, f_{st}^2,f_{st} \dot\ f_{dm} \dots, \xi_{min}^2\right), \ f^{(e)} \in \cal{R}^{14}\end{array}\]</span> 其中：</p><ul><li><span class="math inline">\(\theta_{\gamma}\)</span>为可学习的映射参数（文中在训练跟踪视频的时候使用了一个LogisticRegression来预测这个参数）</li><li><span class="math inline">\(f_{st}\)</span>代表检测框中心点和高相似度：<span class="math inline">\(f_{st}=\frac{\sqrt{\left(x_{v}-x_{w}\right)^{2}+\left(y_{v}-y_{w}\right)^{2}}}{\bar{h}}\)</span></li><li><span class="math inline">\(f_{dm}\)</span>代表两个目标的关键点集合匹配度（感觉有点儿像交并比），但又不完全是（图1是第一篇用这种DeepMatching的论文：Multipersontracking by multicuts and deep matching）</li><li><span class="math inline">\(f_{reID}\)</span>代表融合目标关键点特征的目标相似度（byStackNetPose），具体怎么融合看主要工作2</li><li><span class="math inline">\(\xi_{min}\)</span>表示两个目标检测置信度中，较小的那个置信度。</li></ul><center><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220516211227565.png" alt="image-20220516211227565" style="zoom:50%;"><br></p><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">图1 Deep Matching 示意图</div></center></li></ol><p>​</p><ol start="2" type="1"><li><p>提出融合人体外观和人体姿态的深度评估网络</p><p>  作者提出了融合深度外观和人体关键点的评估网络名为：StackNetPose。具体做法为，先通过单独的人体关键点检测网络，得到各个关键点（每个行人图像14个points）的响应图（宽高与原图一致），然后融合成7张单通道的heatmap，两张行人图像得到14个heatmap（如下图中绿色部分），之后将这些heatmap与两张行人图像的RGB通道堆叠得到一个拥有20个通道输入的特征图，最后通过一个分类网络评估行人图像之间的相似度。</p></li></ol><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517091655746.png" alt="image-20220517091655746" style="zoom:50%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;         display: inline-block;         color: #999;         padding: 2px;">图2 深度提取网络示意图</div></center><h2 id="mclmp问题建模及约束解释">MCLMP问题建模及约束解释</h2><p>最小花费改进多边切割问题的定义或者用法如第一节所述，下面以一个简单得了例子来表述如何构建一个MCLMP模型。这是一个简单的双向图模型，每条边旁边的数字代表切掉这条表对应的花费或者收益，实线连接的边表示连接（joint），虚线连接的边表示剪掉（cut）。</p><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517092532052.png" alt="image-20220517092532052" style="zoom:30%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;         display: inline-block;         color: #999;         padding: 2px;">图3 连接关系图</div></center><h3 id="问题建模">问题建模</h3><p>MCLMP的规划模型如下：</p><ol type="1"><li><p>目标函数 <span class="math display">\[\min _{x \in\{0,1\} E^{\prime}} \sum_{e \in E^{\prime}} c_{e} x_{e}\]</span></p><blockquote><p>其中<span class="math inline">\(E'\)</span>表示图中所有的边（包括剪掉和连接的，包括regularedges 和 additional edges，additional edges是自己设置的），<span class="math inline">\(c_e\)</span>表示<span class="math inline">\(e\)</span>这条边剪掉所带来的花费，比如上图中<span class="math inline">\(V_1，V_6\)</span>两个节点的弧形连接边，如果将这个边cut，那么将会花费5。<span class="math inline">\(x_e\)</span>表示边的连接状态，<span class="math inline">\(x_e=1\)</span>表示这条边被cut，<span class="math inline">\(x_e=0\)</span>表示这条边是joint。因此对于一个都是joint关系的图，总体的花费都为0，需要cut掉一些产生收益的负权边（如上图的-1，-0.5的这些边）来进一步减少花费。</p></blockquote></li><li><p>约束条件</p><p>约束1： <span class="math display">\[\forall Y \in \operatorname{cycles}(G), \ \  \forall e \in Y: x_{e} \leq\sum_{e^{\prime} \in Y \backslash\{e\}} x_{e^{\prime}}\]</span></p><blockquote><p>直观表述：对任意一个循环连接（cut的虚线边也算作连接，也存在循环连接），循环圈中的每条边的连接状态值，小于等于剩余边连接状态值的之和。通俗解释，一个循环连接，要么就全都是joint的，此时所有的<span class="math inline">\(x_e=0\)</span>，有<span class="math inline">\(0\le0\)</span>，约束成立；要么就要有两条及以上的边是cut的，此时对被cut的边有<span class="math inline">\(1 \le 1+k\)</span>，<span class="math inline">\(k\)</span>为循环连接中cut边数量-2， <span class="math inline">\(k \ge 0\)</span>。</p></blockquote><p>约束2： <span class="math display">\[\forall v w \in E^{\prime} \backslash E , \ \ \forall P \in v w \text{-paths(G) }: x_{v w} \leq \sum_{e \in P} x_{e}\]</span></p><blockquote><p>直观表述：对任意一条additional edges,其任意一条可行的regularedges组成的path（状态为0才能称之为path），path中所有连接边的状态值之和应该大于additionaledges直接连接的状态值。通俗解释：任意一条additionaledges（比如图3中的V1——V6边）状态为joint的前提是存在一个同样为joint的连接通路，这个通路可以是：V1——V2——V3——V6，也可以是：V1——V2——V5——V6，也可以两个都存在。</p></blockquote><p>约束3： <span class="math display">\[\forall v w \in E^{\prime} \backslash E , \ \ \forall C \in vw-\operatorname{cuts}(G): 1-x_{v w} \leq \sum_{e \inC}\left(1-x_{e}\right)\]</span></p><blockquote><p>通俗表述：对任意一条additionaledges（比如图3中的V1——V6边）状态为cut的前提是所有V1——V6的连接通路均不存在一些状态为cut的边，这些通路包括：V1——V2——V3——V6，也可以是：V1——V2——V5——V6，V1——V4——V5——V6，都要有cut边。</p></blockquote></li></ol><p>图例解释：</p><ol type="1"><li>不满足约束（1）</li></ol><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517102134624.png" alt="image-20220517102134624" style="zoom:45%;"></p><p>假设优化剪边后的图连接关系如上，此时对于V1——V2——V5——V4——V1循环，边<span class="math inline">\(x_{12}=1\)</span>，而其余的边<span class="math inline">\(x_{e^{'}}=0\)</span>，因此对于约束（1）<span class="math inline">\(x_{12}=1 \nleq0\)</span>不满足，不是问题的可行解。</p><ol start="2" type="1"><li>不满足约束（2）</li></ol><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517102844176.png" alt="image-20220517102844176" style="zoom:45%;"></p><p>假设优化剪边后的图连接关系如上，此时因为存在V1——V4——V5——V6的path,所以additional edges <span class="math inline">\(x_{16}\)</span>应该为joint状态。</p><ol start="3" type="1"><li><p>不满足约束（3）</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517103152519.png" alt="image-20220517103152519" style="zoom:45%;"></p></li></ol><p>假设优化剪边后的图连接关系如上，此时因为任何一条从V1——V6的通路都带有cut状态的边，因此additionaledges <span class="math inline">\(x_{16}\)</span>应该为cut状态。</p><p>最后放上正确优化后的图结构：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517103817848.png" alt="image-20220517103817848" style="zoom:40%;"></p><p>此时的多边切割划分为为（-1 + -1 + -1 + -1 =-4），相比原来的花费0，确实更小了。</p><p><strong>相关文献：</strong></p><p>Multi-Person Tracking by Multicut and Deep Matching</p><ul><li><a href="https://arxiv.org/pdf/1608.05404.pdf">Paper</a>;</li></ul><p>Multiple People Tracking by Lifted Multicut and PersonRe-identiﬁcation</p><ul><li><a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Tang_Multiple_People_Tracking_CVPR_2017_paper.pdf">Paper</a></li></ul><p>An Efficient Fusion Move Algorithm for the Minimum Cost LiftedMulticut Problem</p><ul><li><a href="https://hci.iwr.uni-heidelberg.de/sites/default/files/publications/files/1939997197/beier_16_efficient.pdf">Paper</a></li><li><a href="http://www.eccv2016.org/files/posters/O-2A-01.pdf">Poster</a></li><li><a href="http://videolectures.net/site/normal_dl/tag=1078753/eccv2016_beier_efficient_fusion_01.pdf">Lectures&amp;Slides</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>多目标跟踪</category>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>Minimum Cost Lifted Multicut Problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gaussian Processes for Regression</title>
    <link href="/jasonyang.github.io/2022/05/18/%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B%E5%9B%9E%E5%BD%92%EF%BC%88Gaussian%20Processes%20for%20Regression%EF%BC%89/"/>
    <url>/jasonyang.github.io/2022/05/18/%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B%E5%9B%9E%E5%BD%92%EF%BC%88Gaussian%20Processes%20for%20Regression%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高斯过程回归gaussian-processes-for-regression">高斯过程回归（GaussianProcesses for Regression）</h1><hr><h2 id="实际问题">实际问题</h2><p>如下图所示，我们已知<span class="math inline">\(x\)</span>在<span class="math inline">\(\left[\begin{array}{llllll} -1.50 &amp; -1.00&amp; -0.75 &amp; -0.40 &amp; -0.25 &amp; 0.00\end{array}\right]\)</span>处的观测值以及他们在这些点处的观测标准差<span class="math inline">\(\sigma_n=0.3\)</span>，如何根据这些已知信息去求得<span class="math inline">\(x_*=0.2\)</span>时，<span class="math inline">\(y_*=?\)</span>。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513113623452.png" alt="image-20220513113623452" style="zoom:35%;"></p><h2 id="问题建模">问题建模</h2><h3 id="确定衡量观测点影响重要程度的协方差函数">确定衡量观测点影响重要程度的协方差函数</h3><p>​ 一般选用径向基函数（RBF）来衡量两个观测点之间的协方差（影响程度）：<span class="math display">\[k\left(x, x^{\prime}\right)=\sigma_{f}^{2} \exp\left[\frac{-\left(x-x^{\prime}\right)^{2}}{2 l^{2}}\right]\]</span></p><blockquote><p><span class="math inline">\(k(x,x')\)</span>表示<span class="math inline">\(x\)</span>与<span class="math inline">\(x'\)</span>之间的协方差，<span class="math inline">\(\sigma_f\)</span>控制影响强度，<span class="math inline">\(l\)</span>控制影响周期。</p></blockquote><h3 id="不同时刻或者位置的观测值">不同时刻或者位置的观测值</h3><p>一个系统或者运动物体在时刻<span class="math inline">\(t\)</span>或者位置<span class="math inline">\(x\)</span>的观测值<span class="math inline">\(y\)</span>有如下计算公式： <span class="math display">\[y=f(x)+\mathcal{N}(0, \sigma_{n}^{2})\]</span></p><blockquote><p><span class="math inline">\(f(.)\)</span>表示依赖或者映射函数，<span class="math inline">\(\mathcal{N}(0,\sigma_{n}^{2})\)</span>表示测量值噪声服从均值为0，方差为<span class="math inline">\(\sigma_{n}^2\)</span>的高斯分布。</p></blockquote><h3 id="融合观测噪声的协方差函数">融合观测噪声的协方差函数</h3><p><span class="math display">\[k\left(x, x^{\prime}\right)=\sigma_{f}^{2} \exp\left[\frac{-\left(x-x^{\prime}\right)^{2}}{2l^{2}}\right]+\sigma_{n}^{2} \delta\left(x, x^{\prime}\right)\]</span></p><blockquote><p><span class="math inline">\(\delta(.)\)</span>表示Kronecker三角函数，当<span class="math inline">\(x=x'\)</span>时，<span class="math inline">\(\delta(x, x')=1\)</span>,其余时候等于0.</p></blockquote><h3 id="根据任意两个观测点计算得到协方差矩阵">根据任意两个观测点计算得到协方差矩阵</h3><p>根据2.3中的协方差函数以及已知观测点的位置<span class="math inline">\(x\)</span>和未知待预测点的位置<span class="math inline">\(x_*\)</span>计算得到以下协方差阵： <span class="math display">\[K=\left[\begin{array}{cccc}k\left(x_{1}, x_{1}\right) &amp; k\left(x_{1}, x_{2}\right) &amp; \cdots&amp; k\left(x_{1}, x_{n}\right) \\k\left(x_{2}, x_{1}\right) &amp; k\left(x_{2}, x_{2}\right) &amp; \cdots&amp; k\left(x_{2}, x_{n}\right) \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\k\left(x_{n}, x_{1}\right) &amp; k\left(x_{n}, x_{2}\right) &amp; \cdots&amp; k\left(x_{n}, x_{n}\right)\end{array}\right]\]</span></p><p><span class="math display">\[K_{*}=\left[\begin{array}{llll}k\left(x_{*}, x_{1}\right) &amp; k\left(x_{*}, x_{2}\right) &amp; \cdots&amp; k\left(x_{*}, x_{n}\right)\end{array}\right] \quad K_{* *}=k\left(x_{*}, x_{*}\right)\]</span></p><blockquote><p><span class="math inline">\(x_1, ...,x_n\)</span>表示已知观测点，<span class="math inline">\(x_*\)</span>表示待预测的点。可以确定的是依据2.3中的公式，矩阵<span class="math inline">\(K\)</span>的对角线元素为<span class="math inline">\(\sigma_f^2 + \sigma_n^2\)</span>。</p></blockquote><h3 id="基于高斯过程和最大后延概率求解待预测值">基于高斯过程和最大后延概率求解待预测值</h3><p>基于之前的关键假设：观测系统是一个高斯过程。所以目前的观测值和待预测值服从一个多元高斯分布：<span class="math display">\[\left[\begin{array}{c}\mathbf{y} \\y_{*}\end{array}\right] \sim\mathcal{N}\left(\mathbf{0},\left[\begin{array}{ll}K &amp; K_{*}^{\mathrm{T}} \\K_{*} &amp; K_{* *}\end{array}\right]\right)\]</span> 现在需要做的是，求得一个待预测的观测值<span class="math inline">\(y_*\)</span>，使得<span class="math inline">\(p(y_*|\mathbf{y})\)</span>的概率最大，换句话说使得<span class="math inline">\(p(y_*|\mathbf{y})\)</span>概率最大的<span class="math inline">\(y_*\)</span>即为所求的最佳高斯过程回归值。</p><p><span class="math inline">\(y_*|\mathbf{y}\)</span>的条件概率服从：<span class="math display">\[y_{*} \mid \mathbf{y} \sim \mathcal{N}\left(K_{*} K^{-1} \mathbf{y},K_{* *}-K_{*} K^{-1} K_{*}^{\mathrm{T}}\right)\]</span> 综上，<span class="math inline">\(y_*\)</span>的最佳估计和估计的方差为： <span class="math display">\[\bar{y}_{*}=K_{*} K^{-1} \mathbf{y}\]</span></p><p><span class="math display">\[\operatorname{var}\left(y_{*}\right)=K_{* *}-K_{*} K^{-1}K_{*}^{\mathrm{T}}\]</span></p><h2 id="例题">例题</h2><p>依据上述第一节的例题，有6个观测点值<span class="math inline">\(x=\left[\begin{array}{llllll}-1.50 &amp; -1.00 &amp; -0.75 &amp; -0.40&amp; -0.25 &amp; 0.00\end{array}\right]\)</span>，同时可以假定<span class="math inline">\(\sigma_n=0.3\)</span>，设定<span class="math inline">\(\sigma_f=1.27,l=1\)</span>，则依据公式（3）（4）（5）得： <span class="math display">\[K=\left[\begin{array}{llllll}1.70 &amp; 1.42 &amp; 1.21 &amp; 0.87 &amp; 0.72 &amp; 0.51 \\1.42 &amp; 1.70 &amp; 1.56 &amp; 1.34 &amp; 1.21 &amp; 0.97 \\1.21 &amp; 1.56 &amp; 1.70 &amp; 1.51 &amp; 1.42 &amp; 1.21 \\0.87 &amp; 1.34 &amp; 1.51 &amp; 1.70 &amp; 1.59 &amp; 1.48 \\0.72 &amp; 1.21 &amp; 1.42 &amp; 1.59 &amp; 1.70 &amp; 1.56 \\0.51 &amp; 0.97 &amp; 1.21 &amp; 1.48 &amp; 1.56 &amp; 1.70\end{array}\right]\\K_{*}=\left[\begin{array}{llllll}0.38 &amp; 0.79 &amp; 1.03 &amp; 1.35 &amp; 1.46 &amp; 1.58\end{array}\right] ,\ \  \    K_{**}=1.70\]</span> 之后依据公式（8）（9）得到： <span class="math display">\[\bar{y}_{*}=0.95 ，\ \  \operatorname{var}\left(y_{*}\right)=0.21\]</span><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513150426202.png" alt="image-20220513150426202" style="zoom:35%;"></p><blockquote><p>图中黑色实线表示GPR预测值，黑色原点表示实际观测值，蓝色点表示在<span class="math inline">\(x=0.2\)</span>处的观测值，红色区域表示95%的置信度区间（<span class="math inline">\(\bar{y}_{*} \pm 1.96\sqrt{\operatorname{var}\left(y_{*}\right)}\)</span>）。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>轨迹位置预测</category>
      
      <category>预测算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gaussian Processes for Regression</tag>
      
      <tag>回归预测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-YOLO_Pose:Enhancing YOLO for Multi Person Pose Estimation Using Object Keypoint Similarity Loss</title>
    <link href="/jasonyang.github.io/2022/05/17/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-YOLOPose/"/>
    <url>/jasonyang.github.io/2022/05/17/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-YOLOPose/</url>
    
    <content type="html"><![CDATA[<h1 id="yolo-pose-enhancing-yolo-for-multi-person-pose-estimation-using-object-keypoint-similarity-loss">YOLO-Pose:Enhancing YOLO for Multi Person Pose Estimation Using Object KeypointSimilarity Loss</h1><p>原文链接：https://arxiv.org/pdf/2204.06806.pdf</p><h2 id="行文结构">行文结构</h2><h3 id="摘要">摘要</h3><p><strong>目前算法的问题：</strong></p><ol type="1"><li>不是端到端训练，同时无法直接依据姿态检测的指标OKS进行训练，而是使用L1Loss进行替代。</li></ol><p>所提算法允许进行端到端地训练模型并优化 OKS指标本身。所提出的模型学习在单次前向传递中联合检测多人的边界框及其相应的2D 姿势。</p><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525201239786.png" alt="image-20220525201239786" style="zoom:23%;"><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525201313195.png" alt="image-20220525201313195" style="zoom:25%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">算法可视化对比 ：YOLO-pose(左)， HigherHRNetW32（右）</div></center><blockquote><p>上图中HRNet需要先运行一次目标检测网络然后才能对框定的bbox进行姿态估计。</p></blockquote><h3 id="介绍">介绍</h3><p><strong>2D人体姿态估计：</strong>多人 2D姿势估计是理解图像中的人类的任务。给定输入图像，目标是检测每个人并定位他们的身体关节。由于图像中的人数可变、比例变化、身体部位的遮挡、人体的非刚性以及各种其他原因，推断图像中多人的姿势可能具有挑战性。</p><p>提出的姿态估计技术可以很容易地集成到任何运行目标检测的计算机视觉系统中，计算量几乎为零。</p><h3 id="yolo-pose整体结构">YOLO-Pose整体结构</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525204036320.png" alt="image-20220525204036320" style="zoom:50%;"></p><p>就是相当于YOLOv5在之前的bbox分支基础上重新增加了一个Head去回归目标的姿态。整体的预测向量如下：<span class="math display">\[\begin{array}{l}P_{v}=\left\{C_{x}, C_{y}, W, H, \text { box }_{\text {conf }}, \text {class }_{\text {conf }}, K_{x}^{1}, K_{y}^{1}, K_{\text {conf }}^{1},\ldots\right., K_{x}^{n}, K_{y}^{n}, K_{\text {conf }\}}^{n}\end{array}\]</span></p><blockquote><p>其中<span class="math inline">\(n=17\)</span>代表需要预测17个人体关键点，每个关键点由位置<span class="math inline">\(x,y\)</span>和关键点置信度<span class="math inline">\(K_{conf}\)</span>衡量。在推理时保留置信度高于0.5的关键点。</p></blockquote><h4 id="oks损失计算">OKS损失计算</h4><p><span class="math display">\[\begin{aligned}\mathcal{L}_{k p t s}(s, i, j, k) &amp;=1-\sum_{n=1}^{N_{k p t s}} O K S\\&amp;=1-\frac{\sum_{n=1}^{N_{k p t s}} \exp \left(\frac{d_{n}^{2}}{2s^{2} k_{n}^{2}}\right) \delta\left(v_{n}&gt;0\right)}{\sum_{n=1}^{N_{kp t s}} \delta\left(v_{n}&gt;0\right)}\end{aligned}\]</span></p><blockquote><p><span class="math inline">\(d_n\)</span>表示第<span class="math inline">\(n\)</span>个关键点GT与Pred之间的欧氏距离；</p><p><span class="math inline">\(s\)</span>表示目标的尺度（也即anchorbbox的尺度），其他描述又说是目标关键点轮廓的面积；</p><p><span class="math inline">\(k_n\)</span>表示第<span class="math inline">\(n\)</span>个关键点的权重；</p><p><span class="math inline">\(\delta(v_n)\)</span>表示关键点可见度符号函数，当真实可见度<span class="math inline">\(v_n &gt; 0\)</span>时，<span class="math inline">\(\delta(v_n)\)</span>等于1。</p></blockquote><h3 id="sota结果对比">SOTA结果对比</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220526093441077.png" alt="image-20220526093441077" style="zoom:67%;"></p><h3 id="l1-loss和oks-loss的对比分析">L1 Loss和OKS Loss的对比分析</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220526093646961.png" alt="image-20220526093646961" style="zoom: 33%;"></p><h3 id="macs与flops的比较">MACs与FLOPs的比较</h3><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/v2-ec81621db83d2e9216d320410d5a8771_b.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>姿态估计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>YOLO</tag>
      
      <tag>Pose Estimation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Improving Multiple Object Tracking with Single Object Tracking（SOTMOT）</title>
    <link href="/jasonyang.github.io/2022/05/14/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SOTMOT/"/>
    <url>/jasonyang.github.io/2022/05/14/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SOTMOT/</url>
    
    <content type="html"><![CDATA[<h1 id="improving-multiple-object-tracking-with-single-object-tracking">ImprovingMultiple Object Tracking with Single Object Tracking</h1><p>论文链接：https://openaccess.thecvf.com/content/CVPR2021/papers/Zheng_Improving_Multiple_Object_Tracking_With_Single_Object_Tracking_CVPR_2021_paper.pdf</p><h2 id="摘要">摘要</h2><h3 id="原文">原文</h3><p>​ Despite considerable similarities between multiple object tracking(MOT) and single object tracking (SOT) tasks, modern MOT methods havenot beneﬁted from the development of SOT ones to achieve satisfactoryperformance. The major reason for this situation is that it isinappropriate and inefﬁcient to apply multiple SOT models directly tothe MOT task, although advanced SOT methods are of the strongdiscriminative power and can run at fast speeds.</p><p>​ In this paper, we propose a novel and end-to-end trainable MOTarchitecture that extends CenterNet by adding an SOT branch for trackingobjects in parallel with the existing branch for object detection,allowing the MOT task to beneﬁt from the strong discriminative power ofSOT methods in an effective and efﬁcient way. Unlike most existing SOTmethods which learn to distinguish the target object from its localbackgrounds, the added SOT branch trains a separate SOT model per targetonline to distinguish the target from its surrounding targets, assigningSOT models the novel discrimination. Moreover, similar to the detectionbranch, the SOT branch treats objects as points, making its onlinelearning efﬁcient even if multiple targets are processed simultaneously.Without tricks, the proposed tracker achieves MOTAs of 0.710 and 0.686,IDF1s of 0.719 and 0.714, on MOT17 and MOT20 benchmarks, respectively,while running at 16 FPS on MOT17.</p><h3 id="翻译">翻译</h3><p>  尽管多目标跟踪（MOT）和单目标跟踪（SOT）任务之间有相当大的相似性，但现代MOT方法并没有从SOT任务的发展中获益，从而获得令人满意的性能。出现这种情况的主要原因是，尽管先进的SOT方法具有很强的识别能力，并且可以以很快的速度运行，但直接将多个SOT模型应用于MOT任务是不合适的，也是不充分的。</p><p>  在本文中，我们提出了一种新颖的端到端可培训MOT体系结构，通过添加用于跟踪对象的SOT分支与用于对象检测的现有分支并行，扩展了CenterNet，使MOT任务能够以有效的方式受益于SOT方法的强鉴别能力。与大多数现有的SOT方法不同，SOT方法学习将目标对象与其局部背景区分开来，添加的SOT分支在线为每个目标训练一个单独的SOT模型，以将目标与其周围目标区分开来，从而为SOT模型分配新的区分。此外，与检测分支类似，SOT分支将对象视为点，即使同时处理多个目标，其在线学习也非常有效。在没有技巧的情况下，建议的跟踪器在MOT17和MOT20基准上分别实现了0.710和0.686的MOTA，0.719和0.714的IDF1，同时在MOT17上以16FPS的速度运行。</p><h2 id="总体思路和结构">总体思路和结构</h2><h3 id="总体思路">总体思路</h3><p>  在CenterNet的基础上增加了一个SOTbranch，轨迹（先用卡尔曼滤波预测轨迹在当前帧的虚拟位置）和当前帧的检测利用SOT分支的岭回归权重进行相似度计算，然后利用匈牙利算法进行匹配，同时对于这一轮未匹配上的轨迹<span class="math inline">\(\mathcal{T}_{unmatched}\)</span>，再次利用IoU度量矩阵和匈牙利算法进行二次匹配，仍未匹配的轨迹丢入轨迹暂存池<span class="math inline">\(\mathcal{T}_{pool}\)</span>，仍未匹配的高分检测初始化为新的轨迹。</p><h3 id="网络结构">网络结构</h3><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513210421725.png" alt="image-20220513210421725" style="zoom:33%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">SOTMOT总体结构图</div></center><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513210835865.png" alt="image-20220513210835865" style="zoom:33%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">单独的SOT Branch示意图</div></center><blockquote><p>注：两帧图像同时输入一个共享权重的网络（其实就是一个网络，进行两次前向传播后再计算损失）仅在Offlinetraining阶段使用，在推理阶段仅需要输入当前帧图像。<span class="math inline">\(EFAC\)</span>就是提取特征图目标中点所有通道的特征；<span class="math inline">\(F\)</span>表示经过3个卷积层再一次提取特征之后的特征图<span class="math inline">\(F \in R^{C_{sot} \times \frac{H}{4} \times\frac{W}{4}}\)</span>。</p></blockquote><h2 id="sot-branch离线训练和在线推理">SOT Branch离线训练和在线推理</h2><h3 id="预备工作">预备工作</h3><ol type="1"><li>根据检测目标彼此之间中心点的位置得到邻接矩阵<span class="math inline">\(A \in R^{N \times N}\)</span>（假设当前检测到<span class="math inline">\(N\)</span>个目标）</li></ol><p><span class="math display">\[\mathbf{A}_{i, j}=\left\{\begin{array}{cc}1 &amp; \text { if } \min\left(\left|x_{i}^{c}-x_{j}^{c}\right|,\left|y_{i}^{c}-y_{j}^{c}\right|\right)\leqslant r \\0 &amp; \text { otherwise }\end{array}\right.\]</span></p><blockquote><p>其中，<span class="math inline">\(x_i^c和y_i^c\)</span>表示第<span class="math inline">\(i\)</span>个目标中心点的坐标，<span class="math inline">\(r\)</span>为距离阈值，文章中取值为75。</p></blockquote><ol start="2" type="1"><li><p>依据邻接矩阵<span class="math inline">\(A\)</span>和第2节中的特征图<span class="math inline">\(F \in R^{C_{sot} \times \frac{H}{4} \times\frac{W}{4}}\)</span>建立每个目标<span class="math inline">\(i\)</span>的邻居特征集合<span class="math inline">\(X_i， i \in [1, ..,N]\)</span>和对应的邻居标签向量<span class="math inline">\(\mathbf{y_i}\)</span> <span class="math display">\[X_i = \text{concat}[\mathbf{x}_j], \ \ \mathbf{x}_{j} =\left\{\mathbf{x}_{j} \mid \forall j: \mathbf{A}_{i, j}=1\right\} \ \X_i \in R^{n_i \times C_{sot}}\\\mathbf{y_i} =[1, 0,0, ..., 0]^{\top}， \mathbf{y_i} \in  R^{n_i \times1}\]</span></p><blockquote><p>其中<span class="math inline">\(\mathbf{x}_j\)</span>表示第<span class="math inline">\(j\)</span>个目标中心点在<span class="math inline">\(F\)</span>中所对应的嵌入特征，<span class="math inline">\(\mathbf{x}_j \in R^{1 \timesC_{sot}}\)</span>;<span class="math inline">\(n_i\)</span>表示第<span class="math inline">\(i\)</span>个目标周围的邻居目标数量，这个邻居包括自己，因此在对应的标签向量<span class="math inline">\(\mathbf{y_i}\)</span>中有且仅有一个位置的值为1.</p></blockquote></li><li><p>建立并求解岭回归（系统辨识）模型</p><p>这里的岭回归感觉就是一个系统辨识，输入是不同目标的特征向量，输出是判定为特定目标的概率。具体建立和求解公式如下：</p><ol type="1"><li><p>建立带正则化的最小化预测误差模型 <span class="math display">\[\min _{\mathbf{w}_{i}}\left\|\mathbf{X}_{i}\mathbf{w}_{i}-\mathbf{y}_{i}\right\|_{2}^{2}+\lambda\left\|\mathbf{w}_{i}\right\|_{2}^{2}\]</span></p><blockquote><p><span class="math inline">\(\mathbf{w}_i\)</span>表示待求解的系统参数，<span class="math inline">\(\lambda\)</span>为正则化参数，文中取值为0.1.</p></blockquote></li><li><p>利用岭回归求解公式解出最优系统参数<span class="math inline">\(\mathbf{w}_i^*\)</span> <span class="math display">\[\mathbf{w}_{i}^{*}=\left(\mathbf{X}_{i}^{\top} \mathbf{X}_{i}+\lambda\mathbf{I}\right)^{-1} \mathbf{X}_{i}^{\top} \mathbf{y}_{i}, \\mathbf{w}_{i}^{*} \in R^{C_{sot} \times 1}\]</span></p></li></ol></li></ol><p>​ 以上便完成了对目标<span class="math inline">\(i\)</span>一致性的度量函数的求解，即有了<span class="math inline">\(\mathbf{w}_i^*\)</span>之后，可以通过<span class="math inline">\(\mathbf{w}_i^*\mathbf{x}_j\)</span>值的大小，判定目标<span class="math inline">\(i,j\)</span>是否为同一目标。</p><h3 id="离线训练sot-branch">离线训练SOT Branch</h3><p>经过上面的推导可以知道，在同一帧中构建目标的邻居节点集合，之后可以给定邻居的标签通过岭回归求解得到映射矩阵<span class="math inline">\(\mathbf{w}_i^*\)</span>，但如何将同一帧计算的结果扩展到不同帧，同时利用网络反向传播，根据预测与真实值的误差增强SOT分支目标中心点特征的提取能力，这就需要利用成对的（前后帧）图像输入，对网络进行离线训练。具体训练流程如下：</p><ol type="1"><li><p>针对<span class="math inline">\(t1\)</span>帧的图像（假设<span class="math inline">\(t1 &lt;t2\)</span>），图像经过带SOT分支的CenterNet网络，得到<span class="math inline">\(N\)</span>个高置信度检测目标（以目标中心点<span class="math inline">\((x_i^c,y_i^c)\)</span>及中心点对应的目标嵌入特征表示<span class="math inline">\(\mathbf{x}_i\)</span>）。</p></li><li><p>依据第3.1节的岭回归模型构建流程，得到<span class="math inline">\(N\)</span>个目标各自的一致性映射矩阵<span class="math inline">\(\left \{ \mathbf{w}_i^* \right\}_{i=1}^{N}\)</span>。</p></li><li><p>针对<span class="math inline">\(t2\)</span>帧的图像，图像同样经过带SOT分支的CenterNet网络，得到<span class="math inline">\(M\)</span>个高置信度检测目标（以目标中心点<span class="math inline">\((x_j^c,y_j^c)\)</span>及中心点对应的目标嵌入特征表示<span class="math inline">\(\mathbf{x}_j\)</span>）。</p></li><li><p>依据公式（1）（2），生成<span class="math inline">\(t2\)</span>帧中每个目标<span class="math inline">\(j\)</span>的邻居中心特征向量集合<span class="math inline">\(X_j^{t2}\)</span>。</p></li><li><p>假设在<span class="math inline">\(t1\)</span>帧中出现的目标有<span class="math inline">\(K\)</span>个同时出现在<span class="math inline">\(t2\)</span>帧中，此时针对这<span class="math inline">\(K\)</span>个相同的目标，在<span class="math inline">\(t1\)</span>帧生成的映射矩阵按理来说同样对<span class="math inline">\(t2\)</span>帧中相同的目标的邻居集作出准确的判断。所以有如下预测公式：<span class="math display">\[\hat{\mathbf{v}}_k=X_k^{t2}\mathbf{w}_k^*, \ k \in K\]</span></p></li><li><p>根据预测和标签值计算SOT预测损失（只针对两帧中同时出现的<span class="math inline">\(K\)</span>个目标）。 <span class="math display">\[\mathcal{L}_{\mathrm{sot}}=\sum_{k=1}^{K}\mathcal{L}_{\mathrm{reg}}\left(\mathbf{v}_{k},\hat{\mathbf{v}}_{k}\right)\\\mathcal{L}_{\mathrm{reg}}(\mathbf{v},\hat{\mathbf{v}})=\left\|\frac{\exp (\mathbf{v})\odot(\mathbf{v}-\hat{\mathbf{v}})}{1+\exp (a\cdot(c-|\mathbf{v}-\hat{\mathbf{v}}|))}\right\|_{2}^{2}\]</span></p><blockquote><p>其中<span class="math inline">\(\odot\)</span>表示同或运算，<span class="math inline">\(a,c\)</span>文章取值为10和0.2.</p></blockquote></li><li><p>根据SOT损失，以及其他检测分支的损失端到端训练SOTMOT网络。</p></li></ol><blockquote><p>这里为什么没有类似于推理的跨帧配对计算损失，是因为跨帧预测标签的指定非常麻烦，不能直接通过距离阈值构建，前一帧每个目标的预测标签都需要两帧之间的身份id来构建，但是理论上可行的。同时还有一个可能的原因是，推理是前后紧密相连的两帧，同时前帧的位置还利用卡尔曼滤波进行了跨帧传播，前后帧目标差距不大，而离线训练的两帧时间间隔比较大，目标的空间位置比较远，无法进行有效衡量。</p></blockquote><h3 id="在线推理">在线推理</h3><p>网络训练完成之后，在线推理阶段只需要输入当前帧的视频图像，然后依据之前的轨迹<span class="math inline">\(i\)</span>为中心，确定半径阈值为<span class="math inline">\(r\)</span>的邻居检测目标集合<span class="math inline">\(Z_i^{det}\)</span>，然后利用轨迹<span class="math inline">\(i\)</span>的映射矩阵$_i^*$，判断当前帧的邻居检测目标与之前轨迹的相似性，以完成跨帧的轨迹传播。</p><h4 id="预测轨迹和检测的相似性">预测轨迹和检测的相似性</h4><ol type="1"><li><p>计算轨迹<span class="math inline">\(k\)</span>的映射矩阵$_k^*$</p><p>这里的计算方法与之前单独每一帧的计算方法有些许不同，因为每个轨迹会保存其从轨迹开始到当前帧的所有结果（<span class="math inline">\(\mathcal{X}_{k}=\left\{\left(\mathbf{X}_{k}^{p},\mathbf{y}_{k}^{p}\right)\right\}_{p=s}^{t-1}\)</span>），所以求解映射矩阵时是最小化轨迹所有观测检测的预测误差得到。假设轨迹<span class="math inline">\(k\)</span>在第<span class="math inline">\(s\)</span>帧初始化，在第<span class="math inline">\(t-1\)</span>帧仍能被观察到，则此时轨迹的映射矩阵应该通过最小化下面这个公式得到：<span class="math display">\[\min _{\mathbf{w}_{k}} \sum_{p=s}^{t-1}\beta^{p}\left\|\mathbf{X}_{k}^{p}\mathbf{w}_{k}-\mathbf{y}_{k}^{p}\right\|_{2}^{2}+\lambda\left\|\mathbf{w}_{k}\right\|_{2}^{2}\]</span></p><blockquote><p><span class="math inline">\(\beta^p\)</span>是轨迹平滑系数，$<sup>{s}=(1-)</sup>{t-s},_{p=s}^{t-1} ^{p}=1， &nbsp;^{p-1} / ^{p}=1-<span class="math inline">\(，其中\)</span>$，该式表示对最新的轨迹观测的预测损失我们应该更加看重。</p></blockquote><p>轨迹<span class="math inline">\(k\)</span>的映射矩阵$_k^* $: <span class="math display">\[\mathbf{w}_{k}^{*}=\left[\sum_{p=s}^{t}\beta^{p}\left(\mathbf{X}_{k}^{p}\right)^{\top}\mathbf{X}_{k}^{p}+\lambda \mathbf{I}\right]^{-1}\left[\sum_{p=s}^{t}\beta^{p}\left(\mathbf{X}_{k}^{p}\right)^{\top}\mathbf{y}_{k}^{p}\right]\]</span></p></li><li><p>利用卡尔曼滤波更新轨迹<span class="math inline">\(k\)</span>在当前帧的位置（<span class="math inline">\(\hat{x}_k^c, \hat{y}_k^c\)</span>）</p></li><li><p>根据轨迹在当前的预测位置（<span class="math inline">\(\hat{x}_k^c,\hat{y}_k^c\)</span>）确定轨迹哪些检测目标是轨迹的邻居（周围目标）</p></li><li><p>提取轨迹周围目标的中心点嵌入特征<span class="math inline">\(\mathbf{x}_j^{det}\)</span>，并根据轨迹的映射矩阵进行相似度预测。</p></li></ol><h4 id="匹配流程">匹配流程</h4><ol type="1"><li>利用预测的轨迹和目标的相似性进行第一轮匹配</li><li>根据轨迹的虚拟位置和检测框的IoU进行第二轮匹配</li><li>将仍未匹配上的轨迹加入缓存池；将仍未匹配上的检测初始化为新轨迹</li></ol><p>通过以上步骤便完成了多个目标的跨帧跟踪。</p><h2 id="总结">总结</h2><p>SOTMOT与FairMOT都有一个专门提取提升的嵌入特征的embeddingHead，但他们的的不同点在于：</p><ol type="1"><li>SOTMOT学习的是如何将目标与周围其他目标区分，FairMOT需要学习将目标与整幅图像中的所有其他目标区分，SOTMOT的学习更具针对性，也更容易收敛。</li><li>SOTMOT每次的映射度量是有一个最优参数估计（岭回归）在里面的，而FairMOT只是单纯运用余弦相似度进行映射。</li></ol><p>最后附上性能对比图：</p><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220514111832808.png" alt="image-20220514111832808" style="zoom:50%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">private detection</div></center>]]></content>
    
    
    <categories>
      
      <category>多目标跟踪</category>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>SOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Detection Recovery in Online Multi-Object Tracking with Sparse Graph Tracker（SGT）</title>
    <link href="/jasonyang.github.io/2022/05/13/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SGT/"/>
    <url>/jasonyang.github.io/2022/05/13/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SGT/</url>
    
    <content type="html"><![CDATA[<h1 id="detection-recovery-in-online-multi-object-tracking-with-sparse-graph-tracker">DetectionRecovery in Online Multi-Object Tracking with Sparse Graph Tracker</h1><p>论文链接：https://arxiv.org/pdf/2205.00968v1.pdf</p><h2 id="总体结构">总体结构</h2><h3 id="网络总体流程图">网络总体流程图</h3><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220511100109328.png" alt="image-20220511100109328"><figcaption aria-hidden="true">image-20220511100109328</figcaption></figure><h3 id="推理流程">推理流程</h3><ol type="1"><li><p>连续两帧的图片输入到检测网络，提取得到<span class="math inline">\(bboxs^{t1}, embeddings^{t1}\)</span>以及<span class="math inline">\(bboxs^{t2}, embeddings^{t2}\)</span>；</p></li><li><p>根据检测框的前景置信度分数排序，从<span class="math inline">\(t1,t2\)</span>帧中各选取<span class="math inline">\(K\)</span>个候选框（in MOT17，<span class="math inline">\(K=100\)</span>, in MOT 20 , <span class="math inline">\(K=300\)</span>）;</p></li><li><p>添加之前missed tracklets的轨迹信息到<span class="math inline">\(t1\)</span>帧，总共的节点数为：<span class="math inline">\(2K +N_{missed}\)</span>，然后结合节点所处的帧阶段，对这些节点进行连接初始化，具体规则如下：</p><ol type="1"><li>前后帧节点（检测到的候选目标）中心点距离较近——两节点连接</li><li>前后帧节点的外观特征余弦距离较小——连接</li><li>前后帧节点的边框IoU较高——连接</li></ol><p>至此得到一个带链接关系的二向图。</p></li><li><p>初始化节点（node）特征、边（edge）特征。其中节点特征可选用外观特征代替，边特征有两个，分别是<span class="math inline">\(t1 \rightarrow t2\)</span>的边特征和<span class="math inline">\(t2 \rightarrowt1\)</span>的边特征，它们的定义如下: <span class="math display">\[e_{i, j}^{0}=f_{e n c}\left(\left[x_{i}-x_{j}, y_{i}-y_{j}, \log\left(\frac{w_{i}}{w_{j}}\right), \log \left(\frac{h_{i}}{h_{j}}\right),\operatorname{IoU}_{i, j}, \operatorname{Sim}_{i, j}\right]\right)\]</span></p><blockquote><p>其中<span class="math inline">\(f_{enc}\)</span>表示两层FC block，<span class="math inline">\(Sim_{i,j}\)</span>表示两个节点的外观相似度。因为<span class="math inline">\(x_i - x_j\)</span>不等于<span class="math inline">\(x_j -x_i\)</span>所以即使两条边使用相同的（共享权重的）<span class="math inline">\(f_{enc}\)</span>，但是<span class="math inline">\(e_{i,j}^0\)</span>和<span class="math inline">\(e_{j,i}^0\)</span>也不相同。</p></blockquote></li><li><p>节点和边特征更新，更新共有3次即<span class="math inline">\(N_{iter}=3\)</span>，每次更新的公式如下：</p><ol type="1"><li><p>边更新 <span class="math display">\[e_{i, j}^{l}=f_{e}\left(\left[v_{i}^{l-1}, v_{j}^{l-1}, e_{i, j}^{0},e_{i, j}^{l-1}\right]\right)\]</span> 为防止过拟合，每次边更新都有最初的边特征<span class="math inline">\(e_{i,j}^0\)</span>加入；<span class="math inline">\(f_e\)</span>同样表示两层FC block.</p></li><li><p>节点更新 <span class="math display">\[v_{j}^{l}=f_{v_{\text {out }}}\left(\frac{1}{\left|E_{:, j}^{l}\right|}\sum_{i} f_{v_{e n c}}\left(\left[v_{i}^{l-1}, e_{i,j}^{l}\right]\right)\right)\]</span> <span class="math inline">\(|E_{:,j}^{l}|\)</span>表示与节点<span class="math inline">\(j\)</span>所连接的另一帧的节点数量。（帧内节点不连接，帧间节点通过第3点中的3个条件来连接）</p></li></ol></li><li><p>轨迹链接预测和目标可见性预测</p><ol type="1"><li><p>轨迹链接预测</p><p>通过融合两个更新后的边特征（<span class="math inline">\(e_{i,j}^3\)</span>和<span class="math inline">\(e_{j,i}^3\)</span>），文章中说是取平均，然后特征通过一个分类器，得到节点<span class="math inline">\(i,j\)</span>之间的连接度<span class="math inline">\(SE\)</span>，然后依据连接度分数利用匈牙利算法对二分图的连接关系进行指定，保证<span class="math inline">\(t1\)</span>帧的每个节点至多只有一条传播到<span class="math inline">\(t2\)</span>帧的边，然后对于高于阈值<span class="math inline">\(\mathcal{T}_E\)</span>的边，则认为前后帧<span class="math inline">\(i,j\)</span>节点（目标）具有同一ID，以此完成轨迹的向前传播。</p></li><li><p>目标可见性预测</p><p>针对<span class="math inline">\(t2\)</span>帧的节点（目标），利用节点特征通过一个分类器，得到节点的可恢复度<span class="math inline">\(SN\)</span>,当可恢复度低于阈值<span class="math inline">\(\mathcal{T}_N\)</span>时，认为该目标不可恢复，如果该节点已被<span class="math inline">\(t1\)</span>帧的节点连接，则此时将他们的连接删除，该节点对应的目标在<span class="math inline">\(t2\)</span>帧也不会出现。</p></li></ol></li><li><p>旧轨迹终止和新轨迹初始化</p><ol type="1"><li><p>旧轨迹终止</p><p>当一个轨迹(这个轨迹在之前至少被连续跟踪了<span class="math inline">\(min_{age}=10\)</span>帧)暂时未通过连接预测进行帧间传播时，轨迹被加入<span class="math inline">\(\mathcal{T}_{missed}\)</span>,并持续跟踪<span class="math inline">\(max_{age}=30\)</span>帧，以保证长时期long-term的数据关联。但如果超过30帧轨迹仍未能从每次的<span class="math inline">\(t2\)</span>帧中找到匹配的检测框，则将这段轨迹移出轨迹暂存池<span class="math inline">\(\mathcal{T}_{pool} = \mathcal{T}_{active} +\mathcal{T}_{missed}\)</span></p></li><li><p>新轨迹初始化</p><p>对于第一帧和第二帧的前向传播情况，如果前后两帧有节点保持了连接则为他们分配唯一的ID，然后对于第二帧和第三帧的前向传播，因为第二帧的一些节点已经分配了ID，若这些节点能够与第三帧的节点相连接，则与其连接的第三帧的节点共享其ID，如果第二帧中未分配ID的节点与第三帧的节点相连接，则重新为它们分配一个额外的唯一的ID。</p><blockquote><p>注：具体是不是两帧连接就初始化轨迹，文章里面貌似也没说，上面的流程只代表一种可行的新轨迹初始化方案。</p></blockquote></li></ol></li><li><p>（轨迹外观模型更新的小trick）</p><p>文章中使用轨迹当前的检测置信度分数对轨迹的外观特征进行自适应加权更新，更新公式如下：<span class="math display">\[e m b_{t 2}^{t r k}=e m b_{t 1}^{t r k} \times \frac{S_{t 1}}{S_{t1}+S_{t 2}}+e m b_{t 2}^{d e t} \times \frac{S_{t 2}}{S_{t 1}+S_{t 2}}\]</span></p><blockquote><p>上述公式表明，对于已分配ID的轨迹的节点特征，是融合了上一次前后两帧关联后<span class="math inline">\(t2\)</span>帧对应节点的外观特征的结果。</p></blockquote></li></ol><h3 id="损失设计">损失设计</h3><h4 id="检测损失">检测损失</h4><p>依据CenterNet的损失设计，不过作者将CenterNet中预测<span class="math inline">\(w,h\)</span>的回归Head，改为预测从中心点到<span class="math inline">\(left,right,top,bottem\)</span>四条边的距离的回归head。</p><h4 id="关联损失">关联损失</h4><p><span class="math display">\[\mathcal{L}_{A}=w_{e d g e} \mathcal{L}_{e d g e}+w_{n o d e}\mathcal{L}_{n o d e}\]</span></p><ol type="1"><li><p>边连接预测损失 <span class="math display">\[\mathcal{L}_{\text {edge }}=\frac{1}{N_{E}+} \sum_{e_{i, j} \inE}\left\{\begin{array}{ll}\operatorname{FL}\left(E S_{i, j}, e y_{i, j}\right), &amp; \text { if }n y_{i}=1 \text { or } n y_{j}=1 \\0 &amp; \text { otherwise }\end{array}\right.\]</span> <span class="math inline">\(N_E+\)</span>表示GT边的数量，GT边表示至少有一个节点是GT节点的边；<span class="math inline">\(FL(.)\)</span>表示Focal Loss; <span class="math inline">\(ny_j=1\)</span>表示节点<span class="math inline">\(j\)</span>对应的目标是真实目标。</p></li><li><p>节点可恢复度预测损失 <span class="math display">\[\mathcal{L}_{n o d e}=\frac{1}{N_{N_{t 2}^{+}}} \sum_{n_{j} \in N_{t 2}}\operatorname{FL}\left(N S_{j}, n y_{j}\right)\]</span> <span class="math inline">\(N_{N_{t2}^+}\)</span>表示<span class="math inline">\(t2\)</span>帧中是真实目标的节点（nodes matching GTin T2 frame ）的数量。</p></li></ol><h4 id="gt框的指定">GT框的指定</h4><p>类似于DETR，利用匈牙利算法基于预测框与GT框的IoU分数来为预测框分配GT。</p><h2 id="总结">总结</h2><p>总的来说这篇文章就是通过前后两帧的检测结果，通过构建一个二向连接图，并衡量前后帧检测结果之间的连接关系来完成轨迹的前后帧传播，好处就是可以将轨迹关联的训练损失可以直接设计为分类预测损失，还有一个点就是使用了前<span class="math inline">\(K\)</span>个固定的检测框，以求恢复一些轨迹。之前的算法中恢复轨迹的做法有两种：</p><ol type="1"><li>OMC：使用之前轨迹的特征嵌入在当前帧特征embedding上做互相关，得到轨迹响应极点，并结合当前帧目标框检测结果，恢复轨迹；</li><li>ByteTrack：直接对低分检测框和未匹配上的轨迹利用IoU进行二次匹配，恢复轨迹。</li></ol><p>最后，看似整个网络没有使用额外的数据关联或者匹配，实则在每两帧之间生成鲁棒性的节点预测时同样使用了匈牙利算法进行最大化连接度匹配，且最后的效果也没有特别好。</p><p><strong>最后放上Paper with Code上面的MOT17，MOT20的排名：</strong></p><ul><li><p>MOT 17</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220511144541094.png"></p></li><li><p>MOT 20</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220511144634459.png" alt="image-20220511144634459"><figcaption aria-hidden="true">image-20220511144634459</figcaption></figure></li></ul><p>​</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>多目标跟踪</category>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>GNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-DanceTrack:Multi-Object Tracking in Uniform Appearance and Diverse Motion</title>
    <link href="/jasonyang.github.io/2022/05/12/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-DanceTrack/"/>
    <url>/jasonyang.github.io/2022/05/12/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-DanceTrack/</url>
    
    <content type="html"><![CDATA[<h1 id="dancetrack-multi-object-tracking-in-uniform-appearance-and-diverse-motion">DanceTrack:Multi-Object Tracking in Uniform Appearance and Diverse Motion</h1><p>原文链接：https://arxiv.org/pdf/2111.14690.pdf</p><h2 id="行文结构">行文结构</h2><p><strong>DanceTrack数据集的特点：</strong></p><ol type="1"><li><p>统一外观：人类具有高度相似且几乎没有区别的外观。</p></li><li><p>多样的运动：它们具有复杂的运动模式和相互作用。</p><blockquote><p>具有频繁的相对位置切换和遮挡。</p></blockquote></li></ol><h3 id="摘要">摘要</h3><p>现有跟踪数据集中的偏差，其中大多数对象往往具有可区分的外观，因此使用re-ID模型足以建立关联，但是当对象外观没有足够的辨别力时，多目标跟踪方法也应该起作用。期待后来的一些算法能够<strong>更少依赖于视觉辨别，更多地依赖于运动分析。</strong></p><h3 id="介绍">介绍</h3><p>现有多目标跟踪数据集的局限性，并观察到许多目标具有不同的外观，并且目标的运动模式非常规则甚至是线性的。最近开发的多目标跟踪算法高度依赖外观匹配来关联检测到的对象，同时几乎不考虑其他线索。</p><p>DanceTrack数据集：</p><ol type="1"><li>该数据集包含超过 100K 的图像帧（几乎是 MOT17 数据集的 10 倍）；</li><li>外观一致：视频中的人穿着非常相似甚至相同的衣服，使得他们的视觉特征很难被re-ID 模型区分；</li><li>多样化运动：人们通常有非常大范围的运动和复杂的身体姿态变化，对运动建模提出了更高的要求。第二个属性也带来了遮挡和交叉作为副作用，即人体彼此重叠的比例很大，并且它们的相对位置经常交换。</li></ol><p>一些对更好的实现DanceTrack上的关联结果有益的结论：</p><ol type="1"><li>目标的细粒度表示，例如分割和姿势，表现出比粗边界框更好的能力；<ol type="1"><li>是否可以融合姿势度量相似度，文末尝试了融合OKS相似度确实带来了很大的提升。</li></ol></li><li>尽管我们正在解决二维跟踪任务，但深度信息显示出对关联对象的积极影响；</li><li>时间动力学的运动建模很重要。</li></ol><h3 id="dancetrack数据集">DanceTrack数据集</h3><p>DanceTrack数据集与MOT17、MOT20的比较：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525145804749.png" alt="image-20220525145804749" style="zoom:50%;"></p><h4 id="数据集构建">数据集构建</h4><p>通过简单地增加感兴趣对象的密度来关注“人群”并不是我们所期望的，MOT20包含行人非常拥挤的视频。但由于行人的运动非常规律，相对位置和遮挡区域保持一致，这样的“人群”并没有为外观匹配设置障碍。</p><p>对于部分被遮挡的对象，标注了一个全身框。<strong>对于完全被遮挡的物体，我们不标注</strong>；当它在未来的帧中重新出现时，它的标识符id在可见时与前一帧保持相同。</p><p>厉害呀，啥工具。标注工具可以自动将注释框从前一帧传播到当前帧，而注释器只需要对当前帧中的框进行细化。</p><h4 id="数据集统计">数据集统计</h4><p>训练集40个，验证集25个，测试集35个。并且在数据集拆分过程中，我们在平均长度、平均边界框数、包含场景和运动多样性方面保持子集的分布接近。</p><p>一些具有挑战性的场景：</p><ol type="1"><li>低光照和远距离相机</li><li>Group Dance，最多40人</li><li>体操比赛视频：极其多样化的身体姿势、频繁的姿势变化和复杂的运动模式。</li></ol><p>目标之间的外观相似度、相邻帧的重叠IoU、目标中心的相对位置切换在不用数据集上的比较：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525151644078.png" alt="image-20220525151644078" style="zoom:67%;"></p><h4 id="数据集的性能评价指标">数据集的性能评价指标</h4><p>HOTA：综合指标</p><p>AssA、IDF1：衡量关联性能</p><p>DetA、MOTA：衡量检测性能</p><h4 id="当前工作的局限">当前工作的局限</h4><ol type="1"><li>考虑到上述动机和建议的数据集，我们没有提供一种高度优于以前的多目标跟踪算法的算法，但将其作为未来研究的一个悬而未决的问题。</li><li>我们在这项工作中强调的情况，人体姿势或分割掩码的注释对于更细粒度的研究应该很重要。但受限于时间和资源，我们在这个版本中只提供了边界框的标注。</li></ol><h3 id="对比实验分析">对比实验分析</h3><p>CenterTrack论文中提供了一种MOT17训练集拆分为训练集和验证集的方法。</p><h4 id="oracle-analysisgt关联分析">Oracle Analysis（GT关联分析）</h4><p>用具有不同关联算法的GT边界框来实现预期的算法上限性能。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525152911459.png" alt="image-20220525152911459" style="zoom:67%;"></p><blockquote><p>从结果来看，就 MOT17 上的所有指标而言，跟踪输出接近完美。而且，有趣的是，仅使用 IoU 匹配可以获得最佳性能，这证明 MOT17包含具有简单和规则运动模式的对象，并且在大多数情况下瓶颈不在于关联。在DanceTrack上同样最佳性能仅在于IoU匹配，即使结合线性运动模型或附加外观信息也无济于事。当使用外观相似性时，所有指标都比不使用任何外观提示要差。</p></blockquote><p>MOT17和DanceTrack数据集目标外观特征Tt-SNE聚类可视化</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525153305733.png" alt="image-20220525153305733" style="zoom:33%;"></p><p><strong>GT分析结论：现有数据集存在严重偏差，更多地关注检测质量，并且所涉及的简单轨迹模式限制了该领域的研究。相反，DanceTrack对开发具有提高关联能力的多对象跟踪器提出了更高的要求。</strong></p><h4 id="目前先进算法在dancetrack上的表现">目前先进算法在DanceTrack上的表现</h4><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525153730867.png" alt="image-20220525153730867" style="zoom:67%;"></p><blockquote><p>检测不是在 DanceTrack上具有良好跟踪性能的瓶颈，如何针对目标的统一外观和多样化运动建立稳健的关联才是。</p></blockquote><h4 id="不同关联算法在dancetrack数据集上的性能比较">不同关联算法在DanceTrack数据集上的性能比较</h4><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525154132253.png" alt="image-20220525154132253" style="zoom: 40%;"></p><blockquote><p>以上关联方法均是基于YOLOX的检测结果。</p></blockquote><h4 id="多任务融合学习分析">多任务融合学习分析</h4><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525154922769.png" alt="image-20220525154922769" style="zoom:67%;"></p><ol type="1"><li><p>融合COCO目标mask监督</p><p>训练数据是 DanceTrack 训练集和 COCO Mask的组合。 如果输入图像来自DanceTrack，我们将其 mask loss 设置为 0。在推理过程中，匹配度量是bounding box IoU 和 mask IoU的加权和。<em>但是从图中看联合训练之后只用bbox匹配就可以达到很好的效果了呀</em></p></li><li><p>融合COCO目标pose监督</p><p>训练数据是 DanceTrack 训练集和 COCO 人体姿势 [24] 的组合。如果输入图像来自 DanceTrack，我们将其位姿损失设置为0。在推理过程中，匹配度量是边界框 IoU 和对象关键点相似度 (OKS)的加权和。</p><blockquote><p>当人体的大部分区域已经被遮挡时，分割模型通常不能提供可靠的输出，而专注于某些人体关键点的姿态估计模型通常表现出更高的鲁棒性。</p></blockquote></li><li><p>融合深度信息</p><p>和KITII数据集中的车辆数据一起训练，有较大的域Gap，因此造成了性能下降；感觉深度信息和姿态信息都是能用的。</p></li><li><p>融合运动模型的作用</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525160839057.png" alt="image-20220525160839057" style="zoom:40%;"></p><blockquote><p>使用弱监督学习来估计其他模式（深度、遮罩掩膜、姿态估计）</p></blockquote></li></ol><h2 id="储备知识">储备知识</h2><ol type="1"><li>有度量关键点相似度的算法：Object Keypoint Similarity(OKS)（COCO数据集里面提供的）</li></ol>]]></content>
    
    
    <categories>
      
      <category>多目标跟踪</category>
      
      <category>数据集介绍</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日积月累：02.移除元素</title>
    <link href="/jasonyang.github.io/2022/04/07/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A02.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <url>/jasonyang.github.io/2022/04/07/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A02.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode日积月累02.移除元素">LeetCode日积月累：02.移除元素</h2><p>根据<strong>代码随想录</strong>的讲解顺序开始打卡学习，闲时更新。</p><blockquote><p>代码随想录：https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#_27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0</p><p>LeetCode练习题目：https://leetcode-cn.com/problems/remove-element/</p></blockquote><h3 id="题目描述">题目描述</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 原地移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并<strong>原地修改输入数组</strong>。</p><p>元素的<strong>顺序可以改变</strong>。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">val</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span>, <span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="hljs-number">2</span> ，而 <span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 或 <span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]，也会被视作正确答案。<br></code></pre></td></tr></tbody></table></figure><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,4,0</span>,<span class="hljs-number">3</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br><br></code></pre></td></tr></tbody></table></figure><h3 id="解决方案own">解决方案（own）</h3><p>借本想法是建立前、后两个指针，前指针从前往后判断元素是否是移除，在发现需要移除的值后，后指针从后往前遍历寻找不等于val的元素，然后交换这两个指针对应的元素值。整个程序在前指针大于后指针时停止。算法总共只需遍历一次数组元素，时间复杂度为O(n)。</p><blockquote><p>每次前后指针找到待移除元素时，数组总长度-1；该方法会改变删除后输出数组元素的相对位置。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeElement</span>(<span class="hljs-params">self, nums, val</span>):</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        """</span><br><br>        <span class="hljs-comment">## own solution</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        left_idx, right_idx = <span class="hljs-number">0</span>, l-<span class="hljs-number">1</span><br>        temp = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> left_idx &lt;= right_idx:<br>            <span class="hljs-keyword">if</span> nums[left_idx] == val:<br>                l -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> nums[right_idx] == val <span class="hljs-keyword">and</span> left_idx &lt; right_idx :<br>                    right_idx -= <span class="hljs-number">1</span><br>                    l -= <span class="hljs-number">1</span><br>                temp = nums[left_idx]<br>                nums[left_idx] = nums[right_idx]<br>                nums[right_idx] = temp<br>                right_idx -= <span class="hljs-number">1</span><br>            left_idx += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> l<br></code></pre></td></tr></tbody></table></figure><h3 id="解决方案others">解决方案（others）</h3><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"><figcaption aria-hidden="true">27.移除元素-双指针法</figcaption></figure><p>快慢指针均从前往后遍历，当快指针遇到待删除元素时，慢指针暂停移动，快指针继续遍历，直到遇到非删除元素，然后将快指针对应的值赋值到慢指针所在位置，赋值后慢指针和快指针继续移动，最终到快指针遍历结束，此时慢指针的位置则为移除val后的数组长度。</p><blockquote><p>因为是顺序遍历，最后输出的数组元素之间的相对位置与删除前一致。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-string">"""双指针法</span><br><span class="hljs-string">    时间复杂度：O(n)</span><br><span class="hljs-string">    空间复杂度：O(1)</span><br><span class="hljs-string">    """</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeElement</span>(<span class="hljs-params">cls, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        fast = slow = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> fast &lt; <span class="hljs-built_in">len</span>(nums):<br><br>            <span class="hljs-keyword">if</span> nums[fast] != val:<br>                nums[slow] = nums[fast]<br>                slow += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 当 fast 指针遇到要删除的元素时停止赋值</span><br>            <span class="hljs-comment"># slow 指针停止移动, fast 指针继续前进</span><br>            fast += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> slow<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inverted residuals block、Shufflenet block的Pytorch实现</title>
    <link href="/jasonyang.github.io/2022/04/03/Inverted%20residuals%20block%E3%80%81Shufflenet%20block%E7%9A%84Pytorch%E5%AE%9E%E7%8E%B0/"/>
    <url>/jasonyang.github.io/2022/04/03/Inverted%20residuals%20block%E3%80%81Shufflenet%20block%E7%9A%84Pytorch%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="inverted-residuals-blockshufflenet-block的pytorch实现">Invertedresiduals block、Shufflenet block的Pytorch实现</h2><hr><h3 id="目前卷积的三种实现方式">0. 目前卷积的三种实现方式：</h3><hr><blockquote><p>图源：https://blog.csdn.net/tintinetmilou/article/details/81607721</p></blockquote><p><strong>Basic Convolution</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403121056332.png" alt="image-20220403121056332"><figcaption aria-hidden="true">image-20220403121056332</figcaption></figure><p><strong>Depthwise Convolution</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403121110773.png" alt="image-20220403121110773"><figcaption aria-hidden="true">image-20220403121110773</figcaption></figure><p><strong>Pointwise Convolution</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403121125095.png" alt="image-20220403121125095"><figcaption aria-hidden="true">image-20220403121125095</figcaption></figure><h3 id="mobilenet-v2">1. MobileNet v2</h3><hr><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403112515368.png" alt="image-20220403112515368"><figcaption aria-hidden="true">image-20220403112515368</figcaption></figure><p>MobileNetv2采用先升维度再降维度的方法，先将通道维度上升到原来的<code>t</code>倍，然后进行<code>depthwise conv</code>，最后再通过<code>1x1 conv</code>将通道数为恢复到原来维度。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/201911131056046.png" alt="在这里插入图片描述"><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220402161527672.png" alt="image-20220402161527672" style="zoom:50%;"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mobilev2_block</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, out_channels, ratio=<span class="hljs-number">6</span>, stride=<span class="hljs-number">1</span></span>):</span><br><span class="hljs-built_in">super</span>(mobilev2_block, self).__init__()<br>self.in_channels = in_channels<br>self.out_channels = out_channels<br>self.stride = stride<br>self.ratio = ratio<br><br><span class="hljs-keyword">if</span> stride == <span class="hljs-number">1</span>:<br><span class="hljs-keyword">assert</span> out_channels == in_channels, <span class="hljs-string">"Under the stride=1 input and output channel number should be equal."</span><br>mid_channels = in_channels*ratio<br>self.branch = nn.Sequential(<br>nn.Conv2d(in_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(mid_channels),<br>nn.ReLU6(inplace=<span class="hljs-literal">True</span>),<br><br>nn.Conv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">3</span>, stride=stride, padding=<span class="hljs-number">1</span>, groups=mid_channels, bias=<span class="hljs-literal">False</span>),<br><br>nn.Conv2d(mid_channels, out_channels, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(out_channels),<br>nn.ReLU6(inplace=<span class="hljs-literal">True</span>),<br><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br><span class="hljs-keyword">if</span> self.stride == <span class="hljs-number">1</span>:<br>x = x + self.branch(x)<br><span class="hljs-keyword">elif</span> self.stride == <span class="hljs-number">2</span>:<br>x = self.branch(x)<br><span class="hljs-keyword">return</span> x<br><br>fake_data = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">32</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>)<br>net = mobilev2_block(in_channels=<span class="hljs-number">32</span>, out_channels=<span class="hljs-number">64</span>, stride=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(net(fake_data).size())<br></code></pre></td></tr></tbody></table></figure><h3 id="shufflenet-v2">2. ShuffleNet v2</h3><hr><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403111217519.png" alt="image-20220403111217519"><figcaption aria-hidden="true">image-20220403111217519</figcaption></figure><p>上图右边两个结构是shufflenetv2的基础残差块，<code>图（c）</code>的输入和输出的特征图完全一致：<code>NxCxHxW-&gt;NxCxHxW</code>；<code>图（d）</code>输入和输出的特征图宽高变为原来的<code>1/2</code>，同时通道数可以为之前的<code>1,2,3</code>倍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicConv2d</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, out_channels, **kwargs</span>):</span><br><span class="hljs-built_in">super</span>(BasicConv2d, self).__init__()<br>self.conv = nn.Conv2d(in_channels, out_channels, bias=<span class="hljs-literal">False</span>, **kwargs)<br>self.bn = nn.BatchNorm2d(out_channels, eps=<span class="hljs-number">0.001</span>)<br>self.relu = nn.ReLU(inplace=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 不确定是ReLU还是relu6</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>x = self.conv(x)<br>x = self.bn(x)<br><br><span class="hljs-keyword">return</span> self.relu(x)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Identity_layer</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-string">"""</span><br><span class="hljs-string">恒等映射</span><br><span class="hljs-string">"""</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-built_in">super</span>(Identity_layer, self).__init__()<br><span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br><span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shufflev2_block</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, out_channels, mode=<span class="hljs-number">1</span>, group=<span class="hljs-number">2</span></span>):</span><br><span class="hljs-built_in">super</span>(shufflev2_block, self).__init__()<br>self.group = group<br>self.in_channels = in_channels<br>self.mode = mode<br>self.out_channels = out_channels<br><br><span class="hljs-comment"># HxW-&gt;HxW</span><br><span class="hljs-keyword">if</span> self.mode == <span class="hljs-number">1</span>: <br><span class="hljs-keyword">assert</span> in_channels == out_channels, <span class="hljs-string">"Under the MODE 1 input and output channel number should be equal."</span><br>mid_channels = self.in_channels // group<br>self.branch1 = Identity_layer()<br>self.branch2 = nn.Sequential(<br><span class="hljs-comment"># pw</span><br>BasicConv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>),<br><span class="hljs-comment"># dw</span><br>nn.Conv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>, groups=mid_channels, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(mid_channels),<br><span class="hljs-comment"># pw linner</span><br>BasicConv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>)<br>)<br><span class="hljs-comment"># HxW-&gt;H/2xW/2</span><br><span class="hljs-keyword">elif</span> mode == <span class="hljs-number">2</span>:<br>mid_channels = self.out_channels // group<br>self.branch1 = nn.Sequential(<br><span class="hljs-comment"># dw</span><br>nn.Conv2d(self.in_channels, self.in_channels, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>, groups=self.in_channels, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(self.in_channels),<br><span class="hljs-comment"># pw linner</span><br>BasicConv2d(self.in_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>)<br><br>)<br>self.branch2 = nn.Sequential(<br><span class="hljs-comment"># pw</span><br>BasicConv2d(self.in_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>),<br><span class="hljs-comment"># dw</span><br>nn.Conv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>, groups=mid_channels, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(mid_channels),<br><span class="hljs-comment"># pw linner</span><br>BasicConv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br><span class="hljs-keyword">if</span> self.mode == <span class="hljs-number">1</span>:<br>channel_per_group = self.in_channels // self.group<br>x = torch.cat([self.branch1(x[:, :channel_per_group]), self.branch2(x[:, channel_per_group:])], dim=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">elif</span> self.mode == <span class="hljs-number">2</span>:<br>x = torch.cat([self.branch1(x), self.branch2(x)], dim=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> self._shuffle(x)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_shuffle</span>(<span class="hljs-params">self, x</span>):</span><br>channel = x.size(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 随机切换通道排序</span><br>shuffle_list = random.sample(<span class="hljs-built_in">range</span>(channel), channel)<br><span class="hljs-keyword">return</span> x[:, shuffle_list]<br><br><br>fake_data = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">512</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>)<br>net = shufflev2_block(in_channels=<span class="hljs-number">512</span>, out_channels=<span class="hljs-number">512</span>, mode=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(net(fake_data).size())<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>可以通过nn.conv2d()内部的<code>groups</code>参数轻松进行depthwiseconv操作。</p></blockquote><h3 id="参考">参考</h3><hr><p>【知乎】《轻量化神经网络综述》：https://zhuanlan.zhihu.com/p/45496826</p><p>【CSDN】Depthwise卷积与Pointwise卷积:https://blog.csdn.net/tintinetmilou/article/details/81607721</p><p>【GitHub】<a href="https://github.com/ericsun99/Shufflenet-v2-Pytorch">Shufflenet-v2-Pytorch</a></p><p>【Arxiv】<a href="https://arxiv.org/pdf/1807.11164.pdf">ShuffleNetV2: Practical Guidelines for Efficient CNN Architecture Design</a></p><p>【Arxiv】<a href="https://arxiv.org/pdf/1801.04381.pdf">MobileNetV2:Inverted Residuals and Linear Bottlenecks</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>轻量化卷积神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python argparse 使用</title>
    <link href="/jasonyang.github.io/2022/04/01/Python%20argparse%20%E4%BD%BF%E7%94%A8/"/>
    <url>/jasonyang.github.io/2022/04/01/Python%20argparse%20%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="python-argparse-使用">Python argparse 使用</h2><hr><blockquote><p>搬运自：<a href="https://geek-docs.com/python/python-tutorial/python-argparse.html">极客教程——Pythonargparse 教程</a></p></blockquote><h3 id="基本使用">1. 基本使用</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse <span class="hljs-comment"># 导入模块</span><br> <br>parser = argparse.ArgumentParser() <span class="hljs-comment"># 初始化一个参数解析器</span><br><br><span class="hljs-comment"># 向参数解析器添加 track-buffer 参数 -buffer 和 --track-buffer分别表示参数的短名和长名</span><br><span class="hljs-comment"># track-buffer 参数可传入的数据的类型是int型，参数的默认值是30（如果没传入的话）</span><br><span class="hljs-comment"># help='tracking buffer'——阐述这个参数的含义</span><br>parser.add_argument(<span class="hljs-string">'-buffer'</span>,<span class="hljs-string">'--track-buffer'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">30</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'tracking buffer'</span>)<br>parser.add_argument(<span class="hljs-string">'--input-video'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">'test_video.flv'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'path to the input video'</span>)<br><br><span class="hljs-comment"># output-format参数只有['video', 'text']两个值可以选择，不传入时默认为video</span><br>parser.add_argument(<span class="hljs-string">'--output-format'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">'video'</span>, choices=[<span class="hljs-string">'video'</span>, <span class="hljs-string">'text'</span>], <span class="hljs-built_in">help</span>=<span class="hljs-string">'Expected output format. Video or text.'</span>)<br>parser.add_argument(<span class="hljs-string">'--output-root'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">'results'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'expected output root path'</span>)<br><br>args = parser.parse_args() <span class="hljs-comment"># 获取解析器中的所有参数，</span><br><span class="hljs-built_in">print</span>(args)<br><br><span class="hljs-comment">## 运行示例1</span><br><span class="hljs-comment"># python argparse_use.py</span><br><span class="hljs-comment"># out:</span><br><span class="hljs-comment"># Namespace(input_video='test_video.flv', output_format='video', output_root='results', track_buffer=30)</span><br><br><span class="hljs-comment">## 运行示例2</span><br><span class="hljs-comment"># python argparse_use.py -buffer 50 --output-format text</span><br><span class="hljs-comment"># out:</span><br><span class="hljs-comment"># Namespace(input_video='test_video.flv', output_format='text', output_root='results', track_buffer=50)</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="add_argument中的其他功能函数方法">2.add_argument()中的其他功能函数（方法）</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># argparse_use.py</span><br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment"># required arg</span><br><br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment"># help flag provides flag help</span><br><span class="hljs-comment"># store_true actions stores argument as True</span><br><br>parser = argparse.ArgumentParser() <span class="hljs-comment"># 初始化一个参数解析器</span><br><br><span class="hljs-comment"># 向参数解析器添加 output 参数 -o 和 --output分别表示参数的短名和长名</span><br><span class="hljs-comment"># action='store_true'——表示这个参数在终端不调用时默认为false；如果终端调用了output参数则为true</span><br><span class="hljs-comment"># help="shows output"——表示output参数的介绍信息（作用）</span><br>parser.add_argument(<span class="hljs-string">'-o'</span>, <span class="hljs-string">'--output'</span>, action=<span class="hljs-string">'store_true'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"shows output"</span>)<br><br><span class="hljs-comment"># 向参数解析器添加 name 参数</span><br><span class="hljs-comment"># required=True——表示在运行.py文件时需要显式的为参数name传入对应的值，例如：python argparse_use.py --name jason</span><br>parser.add_argument(<span class="hljs-string">'--name'</span>, required=<span class="hljs-literal">True</span>) <br><br><span class="hljs-comment"># 向参数解析器添加 n 参数</span><br><span class="hljs-comment"># dest='now'——为n参数起了一个别名叫做now，以后可以通过args.now来获取到args.n的值</span><br>parser.add_argument(<span class="hljs-string">'-n'</span>, dest=<span class="hljs-string">'now'</span>, action=<span class="hljs-string">'store_true'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"shows now"</span>)<br><br><span class="hljs-comment"># type=int——n参数能接收传入的值为的数据类型是 int, 其余解释同上</span><br>parser.add_argument(<span class="hljs-string">'-n'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, required=<span class="hljs-literal">True</span>, <br>    <span class="hljs-built_in">help</span>=<span class="hljs-string">"define the number of random integers"</span>)<br><br><span class="hljs-comment"># default=2——e参数在终端运行时如果没有传入对应值的话，默认值为2</span><br>parser.add_argument(<span class="hljs-string">'-e'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">2</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"defines the exponent value"</span>)<br><br><span class="hljs-comment"># metavar='value'——简要介绍v参数表示value并会在帮助的输出中显示，注意这个和dest起别名的区别</span><br>parser.add_argument(<span class="hljs-string">'-v'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, required=<span class="hljs-literal">True</span>, metavar=<span class="hljs-string">'value'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"computes cube for the given value"</span>)<br><br><span class="hljs-comment"># action='append'——表示name参数或者n参数可以通过终端多次传入，然后先后执行不同的传入</span><br><span class="hljs-comment"># exp:python argparse_use.py --name jason -n yang --name he</span><br><span class="hljs-comment"># 先执行python argparse_use.py --name jason；然后再执行python argparse_use.py --name yang</span><br>parser.add_argument(<span class="hljs-string">'-n'</span>, <span class="hljs-string">'--name'</span>, dest=<span class="hljs-string">'names'</span>, action=<span class="hljs-string">'append'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"provides names to greet"</span>)<br><br><span class="hljs-comment"># nargs=2——表示chars参数可以在一次传入中接收2个值，然后得到一个列表</span><br><span class="hljs-comment"># exp:python argparse_use.py --chars a b c</span><br><span class="hljs-comment"># 此时args.chars=['a', 'b' 'c']</span><br>parser.add_argument(<span class="hljs-string">'--chars'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, nargs=<span class="hljs-number">2</span>, metavar=<span class="hljs-string">'c'</span>,<span class="hljs-built_in">help</span>=<span class="hljs-string">'starting and ending character'</span>)<br><br><span class="hljs-comment"># nargs='*'——表示num参数可以在一次传入中接收多个值，然后得到一个列表</span><br>parser.add_argument(<span class="hljs-string">'num'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, nargs=<span class="hljs-string">'*'</span>)<br><br><span class="hljs-comment"># choices=['std', 'iso', 'unix', 'tz']——表示now参数在传入相应值时只能选择['std', 'iso', 'unix', 'tz']之中的一个</span><br>parser.add_argument(<span class="hljs-string">'--now'</span>, dest=<span class="hljs-string">'format'</span>, choices=[<span class="hljs-string">'std'</span>, <span class="hljs-string">'iso'</span>, <span class="hljs-string">'unix'</span>, <span class="hljs-string">'tz'</span>],<br>                    <span class="hljs-built_in">help</span>=<span class="hljs-string">"shows datetime in given format"</span>)<br><br>args = parser.parse_args() <span class="hljs-comment"># 获取解析器中的所有参数，</span><br><br><span class="hljs-built_in">print</span>(args)<br></code></pre></td></tr></tbody></table></figure><blockquote><p>PS: 以上这些add_argument中的功能函数或者方法都可以叠加使用。</p><p>PS2:上面在创建参数时有些用了相同的参数名，这只是方便，实际使用中不能使用相同的参数名。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04. Pytorch中WeightedRandomSampler()的使用</title>
    <link href="/jasonyang.github.io/2022/03/31/04.%20Pytorch%E4%B8%ADWeightedRandomSampler()%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/jasonyang.github.io/2022/03/31/04.%20Pytorch%E4%B8%ADWeightedRandomSampler()%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="pytorch中weightedrandomsampler的使用">04.Pytorch中WeightedRandomSampler()的使用</h2><hr><p>针对一些样本类别不均衡数据集，可使用加权的随机采样器平衡各类样本被采样（抽取）训练的概率，缓和偏向预测。### 1. 加权随机采样器简介</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220329232206466.png" alt="image-20220329232206466"><figcaption aria-hidden="true">image-20220329232206466</figcaption></figure><p>参数介绍：</p><ul><li><code>weights:</code>每个样本的采样权重（注意是每个样本），是一个长度为<code>N</code>的<code>list</code>，<code>N</code>为数据集中的样本总个数。</li><li><code>num_samples:</code>需要采样的样本个数。</li><li><code>replacement:</code>是否可以重采样，如果可以重采样则<code>num_samples</code>可以大于<code>N</code>；否则<code>num_samples &lt;= N</code>，且当<code>num_samples=N</code>时采样权重失效。</li><li><code>generator:</code>用于生成采样器的生成器，一般不指定。</li></ul><h3 id="使用示例">2. 使用示例</h3><p>为了阐述<code>WeightedRandomSampler()</code>的工作原理，首先简单创建一个<code>dataset</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">创建简易数据集</span><br><span class="hljs-string">'''</span><br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">My_dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.data = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>) <span class="hljs-comment"># 生成虚拟图像数据</span><br>        self.labels = torch.randint(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">10</span>]) <span class="hljs-comment"># 生层虚拟数据的label</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-keyword">return</span> self.data[idx], self.labels[idx], idx<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.data.size(<span class="hljs-number">0</span>)<br>  <br></code></pre></td></tr></tbody></table></figure><p>上面创建了一个简易的数据集，里面只有10个（虚假）的图像数据，接下来将结合这个数据集类展示<code>WeightedRandomSampler()</code>来的用法。</p><h4 id="生成采样索引">2.1 生成采样索引</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">import</span> torch<br><br>weights = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>] <span class="hljs-comment"># 10个样本各自的采样权重</span><br>sampler = data.WeightedRandomSampler(weights, num_samples=<span class="hljs-number">20</span>, replacement=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(sampler))<br><span class="hljs-comment">### out</span><br><span class="hljs-comment"># 因为最后一个样本的采样权重比较大，所以采样得到样本索引大多数都是最后一个样本</span><br><span class="hljs-comment"># [9, 9, 1, 9, 9, 9, 4, 9, 4, 3, 4, 9, 0, 9, 2, 9, 9, 9, 7, 9] </span><br><br>weights = [<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] <span class="hljs-comment"># 10个样本各自的采样权重</span><br>sampler = data.WeightedRandomSampler(weights, num_samples=<span class="hljs-number">20</span>, replacement=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(sampler))<br><span class="hljs-comment">### out</span><br><span class="hljs-comment"># 同理，因为第一个样本的采样权重比较大，所以采样得到样本索引大多数都是第一个样本</span><br><span class="hljs-comment"># [0, 0, 4, 7, 4, 0, 1, 0, 0, 4, 0, 0, 3, 6, 3, 0, 0, 8, 0, 0]</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>当<code>replacement=False</code>时，各个样本的索引只能被采样一次，且当<code>num_samples=N</code>时，输出的采样样本就是原始数据集。</p></blockquote><h4 id="结合dataset演示">2.2 结合<code>dataset</code>演示</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">import</span> torch<br><br>weights = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>] <span class="hljs-comment"># 10个样本各自的采样权重</span><br>sampler = data.WeightedRandomSampler(weights, num_samples=<span class="hljs-number">20</span>, replacement=<span class="hljs-literal">True</span>)<br>my_dataset = My_dataset()<br>my_dataloader = data.DataLoader(my_dataset, batch_size=<span class="hljs-number">10</span>, sampler=sampler)<br><span class="hljs-keyword">for</span> (data, label, index) <span class="hljs-keyword">in</span> my_dataloader:<br>    <span class="hljs-built_in">print</span>(index)<br><br><span class="hljs-comment">### out</span><br><span class="hljs-comment"># tensor([1, 9, 8, 8, 9, 3, 1, 9, 4, 9])</span><br><span class="hljs-comment"># tensor([9, 9, 0, 3, 9, 9, 5, 9, 7, 9])</span><br></code></pre></td></tr></tbody></table></figure><p>加入<code>sampler</code>之后，<code>dataloader</code>在每次加载的数据样本就会依据采样的样本索引去获取对应索引样本的数据，以达到平衡不同类别的样本数量。</p>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>dataset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>别人所理解的卡尔曼滤波</title>
    <link href="/jasonyang.github.io/2022/03/30/%E5%88%AB%E4%BA%BA%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    <url>/jasonyang.github.io/2022/03/30/%E5%88%AB%E4%BA%BA%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="别人所理解的卡尔曼滤波">别人所理解的卡尔曼滤波</h2><p>摘录一些其他博主所讲解的卡尔曼滤波器文章</p><hr><h3 id="how-a-kalman-filter-works-in-pictures">1. How a Kalman filterworks, in pictures</h3><p>【Bzarg】《How a Kalman filter works, inpictures》：http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/</p><hr><p>卡尔曼滤波更新公式：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330152427883.png" alt="image-20220330152427883"><figcaption aria-hidden="true">image-20220330152427883</figcaption></figure><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330152526716.png" alt="image-20220330152526716"><figcaption aria-hidden="true">image-20220330152526716</figcaption></figure><p>博主绘制的卡尔曼滤波更新过程：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330152621011.png" alt="image-20220330152621011"><figcaption aria-hidden="true">image-20220330152621011</figcaption></figure><h3 id="bilibili-dr_can博主更新的卡尔曼滤波系列教程">2. bilibiliDR_CAN博主更新的卡尔曼滤波系列教程</h3><p>【DR_CAN】《KalmanFilter_全网最详细数学推导》：https://space.bilibili.com/230105574/channel/collectiondetail?sid=6939</p><hr><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330153127035.png" alt="image-20220330153127035"><figcaption aria-hidden="true">image-20220330153127035</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>Kalman filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日积月累：01.二分查找</title>
    <link href="/jasonyang.github.io/2022/03/26/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/jasonyang.github.io/2022/03/26/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="leetcode日积月累01.二分查找">LeetCode日积月累：01.二分查找</h3><p>根据<strong>代码随想录</strong>的讲解顺序开始打卡学习，闲时更新。</p><blockquote><p>代码随想录：https://www.programmercarl.com/0704.二分查找.html#_704-二分查找</p><p>LeetCode练习题目：https://leetcode-cn.com/problems/binary-search/</p></blockquote><h4 id="题目描述">题目描述</h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回-1。</p><p><strong>示例</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></tbody></table></figure><h4 id="解决方案">解决方案</h4><p>注意选取的指针列表是左闭右开区间（<code>[left, right)</code>）还是闭区间（<code>[left, right]</code>）。-<code>[left, right)</code>：则当<code>nums[middle] &gt; target</code>时，<code>right = middle</code>因为右端是开，middle是取不到的刚好也是开.-<code>[left, right]</code>：则当<code>nums[middle] &gt; target</code>时，<code>right = middle - 1</code>因为右端是闭区间，而<code>nums[middle]</code>已经大于<code>target</code>,<code>middle-1</code>才是可以取到.</p><ol type="1"><li>[left, right]版本</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            middle = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>[left, right)版本</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, nums, target</span>):</span><br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) <span class="hljs-comment"># 半开区间</span><br><br>        <span class="hljs-keyword">while</span> left &lt; right: <span class="hljs-comment"># left不能取到right</span><br>            middle = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle<br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03. Pytorch中model eval和torch no grad()的区别</title>
    <link href="/jasonyang.github.io/2022/03/17/03.%20pytorch%E4%B8%ADmodel%20eval%E5%92%8Ctorch%20no%20grad()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/jasonyang.github.io/2022/03/17/03.%20pytorch%E4%B8%ADmodel%20eval%E5%92%8Ctorch%20no%20grad()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="pytorch中model-eval和torch-no-grad的区别">03. pytorch中modeleval和torch no grad()的区别</h2><p>原博文连接如下：<a href="https://blog.csdn.net/songyu0120/article/details/103884586?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164748615916780269889584%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164748615916780269889584&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-103884586.142%5Ev2%5Epc_search_result_cache,143%5Ev4%5Econtrol&amp;utm_term=model.eval%28%29%E5%92%8Ctorch.no_grad%28%29&amp;spm=1018.2226.3001.4187">CSDN:pytorch中model eval和torch no grad()的区别</a></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220317110919631.png" alt="image-20220317110919631"><figcaption aria-hidden="true">image-20220317110919631</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>train and test model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何查找会议论文开会地和出版地</title>
    <link href="/jasonyang.github.io/2022/03/13/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87%E5%BC%80%E4%BC%9A%E5%9C%B0%E5%92%8C%E5%87%BA%E7%89%88%E5%9C%B0/"/>
    <url>/jasonyang.github.io/2022/03/13/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87%E5%BC%80%E4%BC%9A%E5%9C%B0%E5%92%8C%E5%87%BA%E7%89%88%E5%9C%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="如何查找会议论文开会地和出版地">如何查找会议论文开会地和出版地</h2><hr><p>国内一些期刊要求会议论文的参考文献必须得明确论文的出版地（or开会地）和出版商，而直接用googlescholar搜索论文得到的引用格式由通常没有出版地信息，上网搜索了一波，整理了一下其他博主的方案归纳如下。</p><p>会议论文的一般引用格式：</p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">［序号］作者．题名[<span class="hljs-symbol">A</span>]．论文集名[<span class="hljs-symbol">C</span>]．出版地：出版社,出版年：起-止页码.<br></code></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[19]</span> WANG Zhong-dao, ZHENG Liang, LIU Yi-xuan, et al. Towards real-<span class="hljs-selector-tag">time</span> multi-<span class="hljs-selector-tag">object</span> tracking<span class="hljs-selector-attr">[C]</span><span class="hljs-comment">// European Conference on Computer Vision. Cham: Springer, 2020: 107-122.</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>无论英文还是中文作者姓名一律<code>姓前名后</code>，有些期刊可能会要求完整的姓名拼音（如示例），根据具体期刊要求修改即可。</p></blockquote><h3 id="首先使用中文google-scholar镜像站搜索对应论文得到一个基本的国标引用格式">1.首先使用中文GoogleScholar镜像站搜索对应论文，得到一个基本的国标引用格式。</h3><hr><blockquote><p>注：如果直接用Google scholar搜索的话，在导出文献引用时会没有<code>GB/T 7714</code>格式。</p></blockquote><p><strong>Google Scholar镜像站:</strong> http://scholar.scqylaw.com/进入后随便点击一个访问链接，并搜索需要引用的论文，这里以<code>YOLO:You only look once</code>为例。复制<code>GB/T 7714</code>的引用文本。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326112911647.png" alt="image-20220326112911647"><figcaption aria-hidden="true">image-20220326112911647</figcaption></figure><p>这里得到引文通常是没有出版地和出版商的，需要进入我们的主线任务：<strong>如何查看会议论文的出版地和出版商。</strong></p><h3 id="查看会议论文的出版地和出版商">2.查看会议论文的出版地和出版商</h3><hr><blockquote><p>常用的几个出版商和出版地：</p></blockquote><table><thead><tr class="header"><th>出版商</th><th>出版地</th></tr></thead><tbody><tr class="odd"><td>IEEE</td><td>Piscataway, NJ</td></tr><tr class="even"><td>IEEE Computer Society</td><td>Los Alamitos, CA</td></tr><tr class="odd"><td>IEEE Communications Society</td><td>New York, NY</td></tr><tr class="even"><td>AAAI Press</td><td>Palo Alto, CA</td></tr><tr class="odd"><td>Springer</td><td>Berlin, German</td></tr></tbody></table><p>查询的网址主要有两个：</p><p><strong>Web of science 检索:</strong>https://www.webofscience.com/wos/woscc/basic-search</p><p><strong>EI检索：</strong>https://www.engineeringvillage.com/search/quick.url</p><blockquote><p>记得一定断掉代理，否则网站无法通过ip地址识别你是校园机构用户。</p></blockquote><h4 id="web-of-science-检索">2.1 Web of science 检索</h4><blockquote><p><strong>Web of science 检索:</strong>https://www.webofscience.com/wos/woscc/basic-search</p></blockquote><p>还是同样的以<code>YOLO:You only look once</code>为例，输入文章名点击检索，找到对应文章并点击进入（红框）。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326140131358.png" alt="image-20220326140131358"><figcaption aria-hidden="true">image-20220326140131358</figcaption></figure><p>然后就可以看到以下信息：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326140643347.png" alt="image-20220326140643347"><figcaption aria-hidden="true">image-20220326140643347</figcaption></figure><p>继续往下翻阅可以看到出版商和出版地：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326140820268.png" alt="image-20220326140820268"><figcaption aria-hidden="true">image-20220326140820268</figcaption></figure><p>最后综合GoogleScholar镜像中导出的<code>GB\T</code>引文和<code>web of science</code>查到的出版地，<code>YOLO</code>会议论文的参考文献格式如下：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Redmon J, Divvala S, Girshick R, et al. You <span class="hljs-keyword">only</span> look once: Unified, <span class="hljs-type">real</span>-<span class="hljs-type">time</span> <span class="hljs-keyword">object</span> detection[C]//Proceedings <span class="hljs-keyword">of</span> the IEEE conference <span class="hljs-keyword">on</span> computer vision <span class="hljs-keyword">and</span> pattern recognition. <span class="hljs-built_in">New</span> York:IEEE,<span class="hljs-number">2016</span>: <span class="hljs-number">779</span><span class="hljs-number">-788.</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>不确定最后的归属州<code>NY</code>需不需要添加，按理说只需要填写到具体城市就可以了，酌情参考。</p></blockquote><h4 id="ei检索">2.2 EI检索</h4><blockquote><p><strong>EI检索：</strong>https://www.engineeringvillage.com/search/quick.url</p></blockquote><p>用在检索页面的最上方输入文章名，找到对应文章，进入后点击<code>Detailed</code>。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326141705520.png" alt="image-20220326141705520"><figcaption aria-hidden="true">image-20220326141705520</figcaption></figure><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326141846669.png" alt="image-20220326141846669"><figcaption aria-hidden="true">image-20220326141846669</figcaption></figure><p>进入后就可以到该会议论文的<code>出版时间，论文集，出版商，出版地，页码</code>等详细信息。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326142338284.png" alt="image-20220326142338284"><figcaption aria-hidden="true">image-20220326142338284</figcaption></figure><blockquote><p>一般EI检索和Web ofscience检索出来的出版商会不一样，感觉EI检索的更规范一些，建议先用EI检索查找出版商，如果没找到对应论文再用webof science。</p></blockquote><p>最后综合之前的引文得到最终<code>YOLO</code>参考文献的格式为：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Redmon J, Divvala S, Girshick R, et al. You <span class="hljs-keyword">only</span> look once: Unified, <span class="hljs-type">real</span>-<span class="hljs-type">time</span> <span class="hljs-keyword">object</span> detection[C]//Proceedings <span class="hljs-keyword">of</span> the IEEE conference <span class="hljs-keyword">on</span> computer vision <span class="hljs-keyword">and</span> pattern recognition. Los Alamitos:IEEE Computer Society, <span class="hljs-number">2016</span>: <span class="hljs-number">779</span><span class="hljs-number">-788.</span><br></code></pre></td></tr></tbody></table></figure><h3 id="主要参考">主要参考：</h3><p>【知乎】：<a href="https://zhuanlan.zhihu.com/p/96910701">《参考文献[出版地: 出版社] 检索方法》</a></p><p>【CSDN】：<a href="https://blog.csdn.net/JaysonRen/article/details/121794249">《深度学习顶会：CVPR、ICCV、ECCV历年举办地点[2015~2021]》</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>参考文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云+frp实现内网穿透</title>
    <link href="/jasonyang.github.io/2022/03/10/%E9%98%BF%E9%87%8C%E4%BA%91+frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/jasonyang.github.io/2022/03/10/%E9%98%BF%E9%87%8C%E4%BA%91+frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云frp实现内网穿透">阿里云+frp实现内网穿透</h2><h3 id="云服务器购买">1. 云服务器购买</h3><hr><p>随便买一个就行，主要是需要服务的一个公网ip。（点击<code>立即购买</code>默认创建即可，操作系统可选<code>CentOS</code>）</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104116564.png" alt="image-20220310104116564" style="zoom:50%;"></p><h3 id="查看实例并开启远程连接">2. 查看实例并开启远程连接</h3><hr><p>点击<code>云服务器ECS-&gt;实例</code>进入实例管理界面，大概长这样：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104745377.png" alt="image-20220310104745377"><figcaption aria-hidden="true">image-20220310104745377</figcaption></figure><p>然后点击实例右边的<code>远程连接</code>打开服务器的控制终端。</p><blockquote><p>建议开启免密登陆，监控调试很方便。</p></blockquote><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104926368.png" alt="image-20220310104926368" style="zoom: 67%;"></p><p>点击打开后能够看到如下界面：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310105510245.png" alt="image-20220310105510245"><figcaption aria-hidden="true">image-20220310105510245</figcaption></figure><h3 id="在阿里云服务器下载frp相关文件">3.在阿里云服务器下载frp相关文件</h3><hr><p><strong>frp 是一个专注于内网穿透的高性能的反向代理应用，支持TCP、UDP、HTTP、HTTPS等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP节点的中转暴露到公网。</strong></p><blockquote><p>frp下载页面地址：https://github.com/fatedier/frp/releases</p><p>frp官方示例文档：https://gofrp.org/docs</p></blockquote><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310105731938.png" alt="image-20220310105731938" style="zoom:67%;"></p><p>选择这里的<code>linux_amd64</code>版本，然后鼠标放上面右键选择<code>复制链接地址</code>，之后切换回之前阿里云的终端控制台，使用<code>wget</code>指令下载frp文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/fatedier/frp/releases/download/v0.39.1/frp_0.39.1_linux_amd64.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>解压文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf  frp_0.39.1_linux_amd64.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>然后<code>cd</code>进入<code>frp_0.39.1_linux_amd64</code>目录，输入<code>ls</code>可以看到以下文件：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310110547047.png" alt="image-20220310110547047"><figcaption aria-hidden="true">image-20220310110547047</figcaption></figure><p><strong>文件解释：</strong></p><ul><li><code>frpc</code>——frp在客户端运行的文件，也就是需要穿透的内网环境下的主机需要运行的文件，与阿里云服务器这边无关可以删除。</li><li><code>frpc.ini</code>——frp客户端的配置文件，用于定义一些监听和转发端口啥的。</li><li><code>frps</code>——frp在服务器端运行的文件，这需要在阿里云服务器上运行。</li><li><code>frps.ini</code>——frp服务器端的配置文件。</li><li><code>systemd</code>——用于配置让frp服务一直在后台运行的文件，后面会讲。</li></ul><h3 id="开放阿里云服务器端口并设置frp后台运行">4.开放阿里云服务器端口，并设置frp后台运行。</h3><hr><h4 id="回到阿里云云服务器ecs-实例界面然后点击右侧的安全组点击默认的安全组进行配置管理">4.1回到阿里云“云服务器ECS-&gt;实例”界面，然后点击右侧的<code>安全组</code>，点击默认的安全组进行配置管理。</h4><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310112455190.png" alt="image-20220310112455190"><figcaption aria-hidden="true">image-20220310112455190</figcaption></figure><p>手动添加入端口，比如我添加了这几个，一般添加两个端口就行</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310112545443.png" alt="image-20220310112545443" style="zoom:67%;"></p><h4 id="回到云服务器的控制台查看修改并运行frps程序">4.2回到云服务器的控制台，查看、修改并运行<code>frps</code>程序。</h4><p><code>frps.ini</code>里面的内容如下：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span> <br></code></pre></td></tr></tbody></table></figure><blockquote><p>注意：7000是默认绑定的端口，这个端口与你自己开放的入端口的其中一个得对应，不然一会儿客户无法访问。</p></blockquote><p>然后执行下面的语句服务器端程序就运行了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前台启动</span><br>./frps -c ./frps.ini   <br> <br><span class="hljs-comment"># 后台启动（正常使用后推荐后台启动）</span><br>nohup ./frps -c ./frps.ini &amp;<br></code></pre></td></tr></tbody></table></figure><p>一般情况下后台启动已经能够满足正常要求，只要你的云服务器没有关机，程序就一直在运行，但是如果关机之后就得需要打开云服务器的控制终端重新运行一下<code>frps</code>程序。能不能让<code>frps</code>程序开机自启动，不用每次关机后手动打开呢？<code>systemd</code>文件就是用来干这件事儿的。</p><h4 id="使用-systemd-管理-frp-服务">4.3 使用 systemd 管理 frp 服务</h4><blockquote><p>下面部分基本<code>ctrl + C V</code>知乎<code>linux 技术栈</code>的文章，原文链接如下：</p><p>《使用 systemd 管理 frp 服务》:https://zhuanlan.zhihu.com/p/382950791</p></blockquote><ol type="1"><li><strong>systemd 服务单元</strong></li></ol><p>systemd 拥有 11个单元类型，分别是：服务(service)、套接字(socket)、设备(device)、挂载点(mount)、自动挂载点(automount)、启动目标(target)、交换分区或交换文件(swap)、被监视的路径(path)、任务计划(timer)、资源控制组(slice)、一组外部创建的进程(scope)。</p><p>其中，服务单元是以 <code>.service</code>为后缀的单元文件，封装了一个被 <code>systemd</code>监视与控制的进程。</p><p>服务的单元文件包括三个部分：<code>[Service]</code>、<code>[Unit]</code>和 <code>[Install]</code>。</p><p>在 GitHub 上下载的 frp 压缩包中已经包含了对应 frpc 和 frps 的服务的<strong>单元文件</strong>和<strong>单元模板文件</strong>。下面我们将分别讲解基于单元文件和基于单元模板文件进行管理frps 服务（frpc 服务类似）。</p><ol start="2" type="1"><li><strong>基于单元文件管理 frps 服务</strong></li></ol><p>我们先使用 frps 的单元文件（<code>frps.service</code>）进行管理 frps服务。我们先看一下 <code>frps.service</code> 的文件内容：</p><blockquote><p>进入阿里云服务器控制终端界面<code>cd systemd</code>，然后<code>cat frps.service</code>可以看到如下内容。</p></blockquote><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310141256842.png" alt="image-20220310141256842"><figcaption aria-hidden="true">image-20220310141256842</figcaption></figure><p>下面是参数解释：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Frp Server Service <span class="hljs-comment"># 服务描述</span><br><span class="hljs-attr">After</span>=network.target <span class="hljs-comment"># frps 将会在 network.service 启动完毕之后再启动</span><br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple <span class="hljs-comment"># 不论进程是否启动成功，systemctl start 都执行成功</span><br><span class="hljs-attr">User</span>=nobody <span class="hljs-comment"># 设置进程在执行时使用的用户</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure <span class="hljs-comment"># on-failure 表示仅在服务进程异常退出时重启</span><br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s <span class="hljs-comment"># 设置在重启服务前暂停多长时间</span><br><span class="hljs-attr">ExecStart</span>=/usr/bin/frps -c /etc/frp/frps.ini <span class="hljs-comment"># 在启动该服务时需要执行的命令行</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target <span class="hljs-comment"># 用于 systemctl enable 时创建软连接</span><br></code></pre></td></tr></tbody></table></figure><p>重点只需要关注<code>ExecStart</code>，这里面是该服务的执行命令，其实也就是我们之前手动启动的命令行语句。接下来有两种更改方式：</p><ul><li>更改<code>ExecStart</code>中命令语句的执行路径，因为<code>bin</code>文件内是没有<code>frps</code>程序的</li><li>将<code>frps</code>和<code>frps.ini</code>移入到指定<code>bin</code>和<code>etc/frp</code>目录。</li></ul><p>选择第二种方式部署<code>frp</code>服务，执行步骤：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在etc目录下创建frp文件夹</span><br><span class="hljs-built_in">cd</span> /etc<br>mkdir frp<br><br><span class="hljs-comment"># 返回刚才的systemd目录，复制文件</span><br><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">cd</span> frp_0.39.1_linux_amd64/systemd/<br><br><span class="hljs-comment"># 先拷贝.service文件， 需要在系统的目录下才能自启运行</span><br>sudo cp frps.service /usr/lib/systemd/system/<br><br><span class="hljs-comment"># 回到上一级，拷贝frp和.ini文件</span><br><span class="hljs-built_in">cd</span> ..<br>sudo cp frps /usr/bin/<br>sudo cp frps.ini /etc/frp/<br><br><span class="hljs-comment"># 启动frps服务</span><br>sudo systemctl start frps<br><br><span class="hljs-comment"># 停止frps服务</span><br>sudo systemctl stop frps<br><br><span class="hljs-comment"># 开启 frps 服务开机自启动</span><br>sudo systemctl <span class="hljs-built_in">enable</span> frps<br><br><span class="hljs-comment"># 禁用 frps 服务开机自启动</span><br>sudo systemctl <span class="hljs-built_in">disable</span> frps<br></code></pre></td></tr></tbody></table></figure><p>至此阿里云<code>frps</code>程序的配置部署完整结束，接下来是内网主机的客户端设置。</p><h3 id="内网主机的frp客户端配置">5. 内网主机的frp客户端配置</h3><hr><blockquote><p>frp下载页面地址：https://github.com/fatedier/frp/releases</p><p>frp官方示例文档：https://gofrp.org/docs</p></blockquote><p>同样去到frp的下载页面，下载对应版本的frp，我的内网主机是windows，所以下载的windows版本。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310143938760.png" alt="image-20220310143938760" style="zoom: 67%;"></p><p>解压同样可以看到<code>frpc  frpc_full.ini  frpc.ini  frps  frps_full.ini  frps.ini  LICENSE  systemd</code>这些文件，在配置客户端时只需要<code>frpc</code>和<code>frpc.ini</code>两个文件，其余都可以删掉（如果你的内网主机仍是Linux可以保留<code>systemd</code>文件）。</p><p>打开<code>frpc.ini</code>进行如下配置：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">tls_enable</span>=<span class="hljs-literal">true</span>  <span class="hljs-comment"># 这一行是我后面自己加的，原因是之前有段时间frps服务一直连不上，按照网上教程才添加的，最开始可以删除这一行。</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">120.77</span>.<span class="hljs-number">61.888</span> <span class="hljs-comment"># 这是你的阿里云服务器公网ip地址，在"云服务器ECS-&gt;实例"进入实例管理界面可以看到</span><br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span> <span class="hljs-comment"># 这是和frps服务器端绑定的端口，这是阿里云服务器安全组中开放的入端口</span><br><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp <span class="hljs-comment"># 默认</span><br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-comment"># 默认内网主机的本地回环地址</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span> <span class="hljs-comment"># 内网主机的端口，用于SSH连接</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span> <span class="hljs-comment"># 这是阿里云服务器安全组中开放的另一个入端口</span><br></code></pre></td></tr></tbody></table></figure><h3 id="利用winsw将frpc客户端程序封装成windows服务">6.利用winsw将frpc客户端程序封装成windows服务</h3><hr><p>完成<code>.ini</code>文件的修改配置之后，同样可以通过执行下面的命令行语句手动运行frpc客户端程序。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前台启动 （frp_windows文件夹下运行cmd）</span><br>frps -c frps.ini  <br></code></pre></td></tr></tbody></table></figure><p>但是当你的cmd窗口关闭之后吧，程序就自动停止了，如果内网主机是Linux的话同样可以采用之前类似的方法将对应<code>frpc.xxx</code>的文件移入相应路径，windows主机的话则需要winsw来对程序进行封装。</p><blockquote><p>winsw下载地址：https://github.com/winsw/winsw/releases</p></blockquote><p>找到对应的x64版本，下载到frp文件夹的相同目录下。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310150256035.png" alt="image-20220310150256035"><figcaption aria-hidden="true">image-20220310150256035</figcaption></figure><p>然后新建一个<code>.xml</code>文件，里面填写一些windows服务参数</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> # windows服务id<br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> # windows服务名<br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>frp client<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span> # 服务描述，可有可没有<br>  <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span> # 服务执行的程序文件<br>  <span class="hljs-tag">&lt;<span class="hljs-name">arguments</span>&gt;</span>-c frpc.ini<span class="hljs-tag">&lt;/<span class="hljs-name">arguments</span>&gt;</span> # 服务程序文件的超参数，其实就相当与吧 frpc -c frpc.ini拆开<br>  <span class="hljs-tag">&lt;<span class="hljs-name">onfailure</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"restart"</span> <span class="hljs-attr">delay</span>=<span class="hljs-string">"10 sec"</span>/&gt;</span> # 重启延时<br>  <span class="hljs-tag">&lt;<span class="hljs-name">log</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"reset"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span> # 服务日志记录<br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>添加好后命名为<code>winsw.xml</code>同样放在<code>frp</code>文件夹的目录。</p><p>然后在当前<code>frp</code>路径下打开<code>cmd</code>窗口，输入<code>winsw install</code>就可以创建服务了，配置成功后可以看到如下输出：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310151324896.png" alt="image-20220310151324896"><figcaption aria-hidden="true">image-20220310151324896</figcaption></figure><p>之后便可在任务管理器服务一栏中看到<code>frpc</code>服务已启动并显示正在运行，（如果显示<code>已停止</code>右键点击，选择<code>启动</code>即可）</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310151447585.png" alt="image-20220310151447585"><figcaption aria-hidden="true">image-20220310151447585</figcaption></figure><p>然后便可通过在你的外网主机上配置<code>120.77.61.888:6000</code>端口连接访问你的内网主机了，windows用户，用户名和密码就是开机的时候的用户名和密码，提供一份我的配置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">Host my_pc<br>  HostName 120.77.61.888 # 自己的公网ip<br>  Port 6000 # 自己开放的安全组的入端口，需要与frpc.ini中的remote_port一直。<br>  User Administrator # windows一般是这个用户名<br></code></pre></td></tr></tbody></table></figure><p>终于，完结撒花，特别感谢教研室硕哥的帮助指导。</p><h3 id="参考文章">参考文章</h3><hr><p>【知乎】使用 systemd 管理 frp服务：https://zhuanlan.zhihu.com/p/382950791</p><p>【CSDN】阿里云服务器实现frp内网穿透（<a href="https://blog.csdn.net/hesongzefairy/article/details/105543161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164629271016780264082198%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164629271016780264082198&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-105543161.pc_search_result_cache&amp;utm_term=%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F&amp;spm=1018.2226.3001.4187">完整教程</a>）</p><p>【CSDN】阿里云服务器实现 frp内网穿透：https://blog.csdn.net/cao0507/article/details/82758288?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164629271016780264082198%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164629271016780264082198&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2<sub>all</sub>first_rank_ecpm_v1~rank_v31_ecpm-7-82758288.pc_search_result_cache&amp;utm_term=%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F&amp;spm=1018.2226.3001.4187</p><blockquote><p>文章名称一样，内容稍有不同。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
      <tag>frp</tag>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02. 深度学习网络结构可视化</title>
    <link href="/jasonyang.github.io/2022/02/26/02.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/jasonyang.github.io/2022/02/26/02.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="深度学习网络结构可视化">02. 深度学习网络结构可视化</h2><h3 id="torchsummary">1. torchsummary</h3><p>安装:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> torchsummary<br></code></pre></td></tr></tbody></table></figure><p>使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> models<br><span class="hljs-keyword">from</span> torchsummary <span class="hljs-keyword">import</span> summary<br><br>device = torch.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br>vgg = models.vgg16().to(device)<br><br><span class="hljs-string">'''</span><br><span class="hljs-string"># summary 函数完整形式</span><br><span class="hljs-string">summary(model, input_size, batch_size=-1, device=torch.device('cuda:0'),dtypes=None)</span><br><span class="hljs-string">'''</span><br>summary(vgg, (<span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br></code></pre></td></tr></tbody></table></figure><p>输出大概长这个样子：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220226155818058.png" alt="image-20220226155818058"><figcaption aria-hidden="true">image-20220226155818058</figcaption></figure><p>官方链接及使用指南：https://github.com/sksq96/pytorch-summary</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>模型可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web地球——网页书签仓库</title>
    <link href="/jasonyang.github.io/2022/02/24/Web%E5%9C%B0%E7%90%83%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E4%B9%A6%E7%AD%BE%E4%BF%9D%E5%AD%98/"/>
    <url>/jasonyang.github.io/2022/02/24/Web%E5%9C%B0%E7%90%83%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E4%B9%A6%E7%AD%BE%E4%BF%9D%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="web地球网页书签仓库">Web地球——网页书签仓库</h2><p>JasonYang的网页书签收藏仓库</p><h3 id="科研学习">1. 科研学习</h3><blockquote><p>论文查找</p></blockquote><p>SEMANTIC SCHOLAR：https://www.semanticscholar.org/比较全大多数论文都可以找到</p><p>Paper with Code：https://paperswithcode.com/sota深度学习方向论文的分类+code+paper 适合入门查找论文</p><p>Martin Danelljan 主页：https://martin-danelljan.github.io/一个目标跟踪大佬的已发表的论文的主页</p><p>Paper Comparision：https://github.com/JudasDie/Comparison超哥和张志鹏大佬一起构建的SOT、MOT顶会论文仓库</p><p>Aminer：https://www.aminer.cn/channel/143AI汇总挖掘科研情报，找找顶尖论文，看看顶尖大师</p><p><strong>arXiv Daily:</strong> https://www.arxivdaily.com/每日推荐arXiv上面计算机视觉、统计学、金融学等方向的最新论文。</p><blockquote><p>论文下载</p></blockquote><p>SCI-Hub: https://sci-hub.se/ 老毛子创建的论文共享下载网站</p><blockquote><p>机器学习</p></blockquote><p>特征工程学习：https://leoncuhk.gitbooks.io/feature-engineering/content/一个大佬写的笔记仓库，包括特征预处理、构建、提取、选择等典型步骤</p><blockquote><p>深度学习</p></blockquote><p>在线卷积池化公式计算器：http://www.sqflash.com/cal.html</p><p>Pytorch Image Model:https://rwightman.github.io/pytorch-image-models/results/各种backbone模型</p><p>ImgAug: https://github.com/aleju/imgaug 图像数据增强方法</p><p>边写边搜：https://app.fir.ai/ 在线做笔记查阅</p><p>readpaper：https://readpaper.com/同济子豪兄等人创建的论文阅读记录平台</p><p>MistGPU：https://mistgpu.com/login/ GPU服务器租用</p><p>Featurize: https://featurize.cn/ 同上 GPU服务器租用</p><blockquote><p>公式编辑</p></blockquote><p>Latex 公式在线编辑器：https://www.latexlive.com/#%23可以识别公式图片并转换为latex格式（可以用mathpix app替代）</p><p>在线公式编辑：https://math.edrawsoft.cn/图形化公式符号插入，可以导出为<code>latex、mml</code>或者图片格式</p><blockquote><p>LeetCode学习</p></blockquote><p>LeetCode按照怎样的顺序来刷题比较好？https://www.zhihu.com/question/36738189/answer/908664455知乎问题</p><p>企业常考的LeetCode题目：https://codetop.cc/home按照企业考试频率整理的LeetCode题目</p><p>ACM金牌选手整理的LeetCode刷题顺序：https://zhuanlan.zhihu.com/p/388470520</p><p><strong>代码随想录</strong>：https://www.programmercarl.com/</p><blockquote><p>在线课程</p></blockquote><p>国立台湾大学在线课程：http://ocw.aca.ntu.edu.tw/ntu-ocw/ocw/coupage/6数学、艺术、还有文学课程</p><h3 id="工具类">2. 工具类</h3><blockquote><p>常用</p></blockquote><p>在线工具合集：https://www.67tool.com设计配色、视频格式转换、OCR识别、单位转换等等</p><p>Wallhaven：https://wallhaven.cc/ 高清电脑壁纸库</p><p>在线格式转换：https://www.alltoall.net/任意图像、视频、文档格式转换</p><p>I Love PDF：https://www.ilovepdf.com/zh-cn/merge_pdf超级好用的pdf文件在线合并以及压缩的网站</p><p>TempMail: https://temp-mail.org/en/临时邮箱用于注册一些不重要的网站</p><p>图贴士：https://www.tutieshi.com/compose/ 图片生成GIF</p><p>MarkDown emoji：https://www.webfx.com/tools/emoji-cheat-sheet/</p><p><strong>在线文件分享Airportal</strong>：https://airportal.cn/无须登陆注册，互联网分享文件</p><blockquote><p>图片处理</p></blockquote><p>皮卡智能抠图：https://www.picup.shop/apidoc-image-matting.html一个智能抠图网站，可以添加背景</p><p>BgRemover: https://www.aigei.com/bgremover/ 背景消除</p><blockquote><p>在线图表</p></blockquote><p>Apache ECharts：https://echarts.apache.org/zh/index.html 一个基于JavaScript 的开源可视化图表库</p><p>花火图表：https://hanabi.data-viz.cn/templates?lang=zh-CN在线动态图表制作</p><p>Processon：https://www.processon.com/ 在线流程图、思维导图制作</p><blockquote><p>颜色及编码工具</p></blockquote><p>RGB与16进制颜色编码对照表：https://www.sioe.cn/yingyong/yanse-rgb-16/可以任意指定RGB值</p><p>RGB颜色对照表：https://tool.oschina.net/commons?type=3 只有对照表</p><p>高质量论文配色参考：https://slandarer.blog.csdn.net/article/details/114157177?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2<sub>default</sub>CTRLIST<sub>default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2</sub>default<sub>CTRLIST</sub>default-1.no_search_link</p><blockquote><p>PPT素材 + icon图标</p></blockquote><p>Esayicon: https://www.easyicon.cc/ 简单易用</p><p>Iconfont阿里巴巴矢量图标库：https://www.iconfont.cn/ 图标丰富全面</p><p>Fotor 懒设计：https://www.fotor.com.cn/stickers 各式各样的PPT贴纸</p><p>稿定设计：https://www.gaoding.com/introduction平面、LOGO、PPT模板贴纸</p><p>BG-pattrens: http://bg-patterns.com/ PPT背景纹理素材</p><p>Pexels: https://www.pexels.com/zh-cn/ 高清图片素材</p><p>毛笔字体生成：http://www.akuziti.com/mb/可以生成多种毛笔字体保存为图像</p><p>字体转换：http://www.diyiziti.com/xingkai 功能同上</p><blockquote><p>PPT模板+简历模板</p></blockquote><p>KeyNote模板：http://www.ikeynote.cn/forum.php?mod=forumdisplay&amp;fid=42</p><p>创可贴：https://www.chuangkit.com/templatecenter 登陆获取模板</p><p>第一PPT：https://www.1ppt.com/ 免费、免登陆，就是样式有点儿丑</p><p>Slides Go: https://slidesgo.com/国外的PPT模板网站，免费用户每月限制下载10次</p><blockquote><p>软件下载</p></blockquote><p>MacWK：https://macwk.com/ 超全：Mac版本软件下载</p><p>MacBL：https://www.macbl.com/ 马可波罗 Mac版本软件下载</p><p>I tell You：https://msdn.itellyou.cn/ 正版本windows和office软件下载（不过学校提供正版软件！）</p><blockquote><p>语言表达&amp;文章纠错&amp;词频统计词云生成</p></blockquote><p>万词王-反向词典：https://wantwords.thunlp.org查找近义词或者查找与句子表述意思相近的词语</p><p>秘塔写作猫：https://xiezuocat.com/#/修改文章措辞表达，对“得、的、地”分不清真的很有用！</p><p>微词云：https://www.weiciyun.com/统计词频并可视化成词云，总结时可用</p><p>Highlight Code：https://highlightcode.com/ 代码高亮用于插入word文档</p><blockquote><p>计算机类书籍下载</p></blockquote><p>码农书籍网：https://www.manongbook.com/python/1944.html计算机编程类电子书，python java，linux基本都有</p><p>GitHub上的中文编程书目索引：https://github.com/justjavac/free-programming-books-zh_CN#%E7%9B%AE%E5%BD%95也比较全</p><p>GitHub上的经典编程书目索引：https://github.com/jobbole/awesome-programming-books经典书籍</p><h3 id="人文类">3. 人文类</h3><blockquote><p>优秀图书推荐</p></blockquote><p>豆瓣旧版图书TOP250：https://www.douban.com/doulist/43621091/排除最近一些畅销书的冲击，回味经典</p><blockquote><p>电子书下载</p></blockquote><p>Kindle电子书下载：https://zh.hk1lib.org 9000w+电子图书</p><p>熊猫搜书：https://xmsoushu.com/#/ 电子书下载</p><blockquote><p>历史</p></blockquote><p>全历史：https://www.allhistory.com/ 各个国家各个朝代历史文化学习</p><blockquote><p>杂</p></blockquote><p>Auto draw: https://www.autodraw.com/在线绘制简笔画，同时会有AI对目前的简笔画提供绘画建议</p><p>后续：https://houxu.app 热点事件、新闻后续报道</p><p>电影海报下载：http://www.impawards.com 各种电影海报下载</p><p>人人电影网：https://www.rrdynb.com/movie/经典、热门电影百度网盘保存</p><h3 id="其他">4. 其他</h3><blockquote><p>英语相关</p></blockquote><p>Anki共享单词卡片：https://ankiweb.net/shared/decks/english</p><p>BrainyQuote:https://www.brainyquote.com/?<strong>cf_chl_captcha_tk</strong>=pmd_FJEiJ.fORbZaza6gJ9H3lg6j6a4e1diHebA5NdIDVSQ-1630979858-0-gqNtZGzNA3ujcnBszQiR英文名言名句</p><blockquote><p>琐碎</p></blockquote><p>书签地球：https://www.bookmarkearth.com/分享个人书签的一个网站大概率找到宝藏网址</p><p>coffee BGM：https://bgmc-station.com/users/sign_incofee的常用BGM可以在放松或者学习的时候播放</p><p>在线打字游戏：https://play.typeracer.com随机打出一段英语语句，挺有趣的，可以没事打着玩。</p><p>mathor大佬：https://wmathor.com/index.php/about.html他的Transformer讲解很不错</p><p>国家自然基金查询：http://www.letpub.com.cn/index.php?page=grant可以查询心仪导师或者大牛在1997-2021年国家批准的自然基金项目</p><p>核爆范围：https://nuclearsecrecy.com/nukemap/查看当前原子弹或者氢弹爆炸的范围伤害</p><p>生成对称炫酷的图片：http://weavesilk.com/随便移动鼠标就是生成炫酷图片</p><p>矩阵计算器：http://www.yunsuan.info/cgi-bin/eigen_decomp.py矩阵理论学习利器，在线求特征值、SVD、QR分解之类的</p><p><strong>Typingclub</strong>：https://www.typingclub.com/在线标准打字练习网站， 超好玩，网站的动态效果做得太好了。</p><p><strong>Shields:</strong> https://shields.io/生成格式各样的数据图标</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>个人收藏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01. Pytorch 筛选部分网络层权重参数加载</title>
    <link href="/jasonyang.github.io/2022/02/20/Pytorch%20%E7%AD%9B%E9%80%89%E9%83%A8%E5%88%86%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9D%83%E9%87%8D%E5%8F%82%E6%95%B0%E5%8A%A0%E8%BD%BD/"/>
    <url>/jasonyang.github.io/2022/02/20/Pytorch%20%E7%AD%9B%E9%80%89%E9%83%A8%E5%88%86%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9D%83%E9%87%8D%E5%8F%82%E6%95%B0%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="pytorch-筛选部分网络层权重参数加载">01. Pytorch筛选部分网络层权重参数加载</h2><h3 id="从权重文件中筛选并加载">1. 从权重文件中筛选并加载</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pretrained_weight = torch.load(<span class="hljs-string">'weight.pth'</span>) <span class="hljs-comment"># 加载预训练的全部权重参数</span><br>new_net = My_Net() <span class="hljs-comment"># 定义自己的部分网络</span><br>new_net_dict = new_net.state_dict() <span class="hljs-comment"># 获取自己网络的权重参数</span><br>pretrained_dict = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> pretrained_weight.items() <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> net_dict} <span class="hljs-comment"># 筛选</span><br>new_net_dict.update(pretrained_dict) <span class="hljs-comment"># 更新自己网络的权重参数</span><br>new_net.load_state_dict(new_net_dict) <span class="hljs-comment"># 重新加载进自己的网络中</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>上面代码<code>筛选</code>步骤需要两个网络的网络层命名一样才能筛选成功，如果不一样参考下面网络层名映射的方法。</p></blockquote><h3 id="从pytorch官方模型中筛选部分层并加载">2.从Pytorch官方模型中筛选部分层并加载</h3><h4 id="加载预训练模型">1. 加载预训练模型</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision <span class="hljs-keyword">as</span> tv<br><br>pretrained_net = tv.models.alexnet(pretrained=<span class="hljs-literal">True</span>)<br>pretrained_weight = pretrained_net.state_dict()<br><br><span class="hljs-built_in">print</span>(pretrained_net)<br><span class="hljs-built_in">print</span>(pretrained_weight.keys())<br><br></code></pre></td></tr></tbody></table></figure><p>部分输出截取如下：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220163646781.png" alt="image-20220220163646781"><figcaption aria-hidden="true">image-20220220163646781</figcaption></figure><p>选取红框部分的网络参数加载</p><h4 id="自定义网络">2. 自定义网络</h4><p>根据已有模型的输入输出设计网络</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">My_net</span>(<span class="hljs-params">torch.nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(My_net, self).__init__()<br>        self.layer = torch.nn.Sequential(<br>            torch.nn.Linear(in_features=<span class="hljs-number">4096</span>, out_features=<span class="hljs-number">4096</span>, bias=<span class="hljs-literal">True</span>),<br>            torch.nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            torch.nn.Linear(in_features=<span class="hljs-number">4096</span>, out_features=<span class="hljs-number">1000</span>, bias=<span class="hljs-literal">True</span>)   <br>        )<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.layer(x)<br></code></pre></td></tr></tbody></table></figure><h4 id="实例化网络并确定映射关系">3. 实例化网络并确定映射关系</h4><p>因为权重参数是通过字典存储的，当你重新定义一样的网络（即时输入输出相同）但是每层的名称会不一样。导致无法加载。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">net = My_net()<br>net_dict = net.state_dict()<br>net_dict.keys()<br>need_weights = [<span class="hljs-string">'classifier.4.weight'</span>, <span class="hljs-string">'classifier.4.bias'</span>, <span class="hljs-string">'classifier.6.weight'</span>, <span class="hljs-string">'classifier.6.bias'</span>]<br>layer_name_map = { a: b <span class="hljs-keyword">for</span> a,b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(need_weights, net_dict.keys())} <span class="hljs-comment"># 网络层名称映射</span><br><span class="hljs-built_in">print</span>(layer_name_map)<br><span class="hljs-string">"""</span><br><span class="hljs-string">outs:</span><br><span class="hljs-string">{'classifier.4.weight': 'layer.0.weight',</span><br><span class="hljs-string"> 'classifier.4.bias': 'layer.0.bias',</span><br><span class="hljs-string"> 'classifier.6.weight': 'layer.2.weight',</span><br><span class="hljs-string"> 'classifier.6.bias': 'layer.2.bias'}</span><br><span class="hljs-string">"""</span><br></code></pre></td></tr></tbody></table></figure><h4 id="筛选并加载参数">4. 筛选并加载参数</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">pretrained_dict = {}<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> pretrained_weight.items():<br>    <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> need_weights:<br>        <span class="hljs-comment"># 通过映射获取自己网络的网络名</span><br>        pretrained_dict[layer_name_map[k]] = v<br><br>net.load_state_dict(pretrained_dict)<br></code></pre></td></tr></tbody></table></figure><p>END</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>Python</tag>
      
      <tag>权重加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows更改默认Python版本</title>
    <link href="/jasonyang.github.io/2022/02/20/windows%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/"/>
    <url>/jasonyang.github.io/2022/02/20/windows%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="windows更改默认python版本">Windows更改默认Python版本</h2><p>之前想为特定版本的Python安装依赖包时遇到无法切换Python默认版本的问题，于是记录一下解决过程。</p><blockquote><p>适用于windows直接安装的python版本之间切换或者直接安装的python版本与anaconda中base环境python版本的切换。如果直接在anaconda中切换版本直接使用<code>source activate &lt;env name&gt;</code>或者<code>conda activate &lt;env name&gt;</code>。</p></blockquote><h4 id="查看当前默认python版本">1.查看当前默认Python版本</h4><p>在windows命令行窗口输入<code>python -V</code>查看当前Python版本。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220144944093.png" alt="image-20220220144944093"><figcaption aria-hidden="true">image-20220220144944093</figcaption></figure><h4 id="打开环境变量编辑界面">2.打开环境变量编辑界面</h4><p>windows中指令的调用顺序或者优先级是按照环境变量排列的先后顺序确定的，因此要改变默认python版本只需要调整<code>python.exe</code>路径在环境变量中的先后。依次点击<code>开始菜单&gt;设置&gt;系统&gt;关于&gt;高级系统设置&gt;环境变量</code>，打开后可以看到以下页面。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220150355935.png" alt="image-20220220150355935"><figcaption aria-hidden="true">image-20220220150355935</figcaption></figure><p>有两组变量<code>用户变量</code>和<code>系统变量</code>，<code>系统变量</code>的优先级比用户变量优先级更高，因此即使你是<code>用户变量path</code>中的第一个也比<code>系统变量path</code>中的最后一个优先级低。</p><h4 id="确定python各版本路径">3.确定python各版本路径</h4><p>先确定切换的python版本的路径，在命令行窗口输入<code>where python</code>查看已安装的python的路径。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220151037991.png" alt="image-20220220151037991"><figcaption aria-hidden="true">image-20220220151037991</figcaption></figure><p>主要就两个：一个在C盘，一个在G盘（C盘的是3.7,G盘的是python3.9）。</p><h4 id="更改环境变量顺序">4.更改环境变量顺序</h4><p>然后分别点击<code>用户变量</code>和<code>系统变量</code>中的<code>Path</code>组，然后点击<code>编辑</code>，查看对应python的顺序，确保想设置为默认python版本的路径在前面，我这里python3.7在anacondapython3.9上面所以默认是python 3.7。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152025184.png" alt="image-20220220152025184"><figcaption aria-hidden="true">image-20220220152025184</figcaption></figure><p>如果我更改环境变量顺序为下图所示：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152226491.png" alt="image-20220220152226491"><figcaption aria-hidden="true">image-20220220152226491</figcaption></figure><p>此时重新打开命令行窗口，并输入<code>python -V</code>则会返回python3.9</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152410083.png" alt="image-20220220152410083"><figcaption aria-hidden="true">image-20220220152410083</figcaption></figure><p>至此python默认版本更改完毕。</p><blockquote><p>注意：有些时候你的不同版本python变量路径分别在<code>用户变量</code>和<code>系统变量</code>的path中，这时可以把其中一个路径删除，在同一个组（<code>用户变量</code>组或<code>系统变量</code>组）内添加，并确定优先顺序。</p></blockquote><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TMUX 简易使用方法</title>
    <link href="/jasonyang.github.io/2022/02/18/TMUX%20%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/jasonyang.github.io/2022/02/18/TMUX%20%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="tmux-简易使用方法">TMUX 简易使用方法</h2><blockquote><p><strong>主要参考：</strong></p><p>阮一峰 Tmux使用教程：https://www.ruanyifeng.com/blog/2019/10/tmux.html</p><p>Tmux使用手册：http://louiszhai.github.io/2017/09/30/tmux/#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E4%BC%9A%E8%AF%9D</p></blockquote><p><strong>基本概念：</strong>输入tmux命令就相当于开启了一个服务器，此时默认将新建一个会话，然后会话中默认新建一个窗口，窗口中默认新建一个面板。tmux会话、窗口、面板之间的联系如下：</p><ul><li><p>一个tmux<code>session</code>（会话）可以包含多个<code>window</code>（窗口），窗口默认充满会话界面，因此这些窗口中可以运行相关性不大的任务。</p></li><li><p>一个<code>window</code>又可以包含多个<code>pane</code>（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。</p></li></ul><h3 id="tmux-安装">0. tmux 安装</h3><hr><h4 id="root-用户安装">ROOT 用户安装：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ sudo apt-get install tmux<br><br><span class="hljs-comment"># CentOS 或 Fedora</span><br>$ sudo yum install tmux<br><br><span class="hljs-comment"># Mac</span><br>$ brew install tmux<br></code></pre></td></tr></tbody></table></figure><h4 id="非root-用户安装">非ROOT 用户安装：</h4><p>非root用户安装tmux参考以下链接：</p><p><a href="https://zhuanlan.zhihu.com/p/155662601">知乎：非root用户安装tmux</a></p><blockquote><p>如果使用<code>wget</code>产生类似<code>无法解析github.com</code>的错误信息可以利用链接进入GitHub仓库下载后传入安装位置。</p></blockquote><h3 id="基本用法">1. 基本用法</h3><hr><p>最简单也是最常用的tmux使用流程是：新建会话、在新建的会话中运行程序、分离会话、下次使用接入会话</p><h4 id="创建会话">创建会话</h4><ol type="1"><li>使用tmux快速创建会话</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>指定创建会话的名称</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s test-1<br></code></pre></td></tr></tbody></table></figure><p>上面表示创建一个名为<code>test</code>的会话。会话创建完后会在当前窗口的下方出现一个小绿条，类似这种：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220218101122309.png" alt="image-20220218101122309"><figcaption aria-hidden="true">image-20220218101122309</figcaption></figure><p>小绿条左边显示会话名称<code>test-1</code>、窗格(pane)序号<code>0</code>以及窗口名称<code>bash</code>（窗格和窗口的简单操作后面会提到）。小绿条右边则显示会话的创建时间及其他一些信息。</p><h4 id="运行程序">运行程序</h4><p>在刚才创建好的会话中键入自己想运行的程序指令，然后该指令便会一直在后台运行并不会随着SSH连接的断开而停止运行。例如在刚才的会话中运行<code>train.py</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python train.py<br></code></pre></td></tr></tbody></table></figure><p>就像正常的SSH连接一样程序开始运行。</p><h4 id="会话分离">会话分离</h4><p>经过上面的操作程序已经正常运行起来了，接下来我们可以用<code>detach</code>将这个会话与SSH窗口分离开，让它自己在后台运行。</p><p>具体操作如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux detach<br></code></pre></td></tr></tbody></table></figure><p>然后小绿条消失，会话窗口恢复到SSH连接窗口。</p><blockquote><p>可能在运行程序之后，你的程序会一直打印输出导致你无法输入上述指令这时可以利用先按一次<code>Ctrl+b</code>松开后再按<code>d</code>快捷键分离会话。</p></blockquote><h4 id="会话接入">会话接入</h4><p>一个小时之后我们想看看自己的程序跑得怎么样了，这时使用<code>attach</code>便能接入会话查看训练过程。具体指令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 接入之前 test 会话</span><br>$ tmux attach -t <span class="hljs-built_in">test</span><br></code></pre></td></tr></tbody></table></figure><h4 id="退出会话">退出会话</h4><p>会话分离操作只是将任务放置后台托管并没有断开连接，如果想在程序运行完之后断开连接退出会话则需要使用快捷键<code>Ctrl+d</code>或者键入<code>exit</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></tbody></table></figure><h3 id="其他操作">2. 其他操作</h3><h4 id="会话操作">会话操作</h4><ul><li>创建会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>查看会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ctrl+b + s 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux ls<br><span class="hljs-comment"># or</span><br>$ tmux list-session<br></code></pre></td></tr></tbody></table></figure><ul><li>分离会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ctrl+b + d 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux detach<br></code></pre></td></tr></tbody></table></figure><ul><li>接入会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>杀死（退出）会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ctrl+d</span><br><span class="hljs-comment"># or</span><br>$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>切换会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>重命名会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;<br></code></pre></td></tr></tbody></table></figure><h4 id="窗格操作">窗格操作</h4><ul><li>划分窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分为上下两个窗格</span><br><span class="hljs-comment"># ctrl+b + " 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux split-window<br><br><br><span class="hljs-comment"># 划分为左右两个窗格</span><br><span class="hljs-comment"># ctrl+b + % 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux split-window -h<br></code></pre></td></tr></tbody></table></figure><ul><li>移动光标</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></tbody></table></figure><blockquote><p>除了使用上面的显示指令外也可以通过<code>ctrl+b</code>和<code>键盘上下左右方向键来移动光标</code>。</p></blockquote><ul><li>交换窗格位置</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></tbody></table></figure><p>貌似无法支持窗格左右移动？</p><ul><li>查看窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux list-pane<br></code></pre></td></tr></tbody></table></figure><ul><li>移除窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除当前光标所在窗格</span><br><span class="hljs-comment"># ctrl+b + x 分开按</span><br><br><span class="hljs-comment"># 移除指定序号0的窗格</span><br>$ tmux kill-pane -t 0<br></code></pre></td></tr></tbody></table></figure><h4 id="窗口操作">窗口操作</h4><ul><li>创建窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>重命名窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给当前窗口重名命</span><br>$ tmux rename-window &lt;new-name&gt;<br><br>$ tmux rename-window -t  &lt;old-name&gt; &lt;new-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>查看窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux list-window<br></code></pre></td></tr></tbody></table></figure><ul><li>切换窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>关闭窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除指定的窗口</span><br>$ tmux kill-window -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>END</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tmux</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>风格迁移</title>
    <link href="/jasonyang.github.io/2021/11/30/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
    <url>/jasonyang.github.io/2021/11/30/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="风格迁移">风格迁移</h2><hr><h3 id="什么是风格迁移">1. 什么是风格迁移</h3><h4 id="风格迁移任务介绍">1.1 风格迁移任务介绍</h4><hr><p>简而言之，风格迁移即是将一种图像的画风（颜色、纹理等）融合到另一幅图像中，使得融合后的图像能够以风格图像的色彩风格呈现原始图像的内容（任务、景物等前景）。具体示例可见下方图示。</p><center class="half"><img src="style.png" style="zoom:50%;"><img src="content.png" style="zoom:50%;"></center><p><img src="fuse.png" style="zoom:50%;"></p><p>向风格迁移网络中输入风格图像<code>style</code>和内容图像<code>content</code>，网络便会输出融合<code>style</code>和<code>content</code>的新图像<code>style transfer</code>。</p><h4 id="风格迁移网络">1.2 风格迁移网络</h4><hr><p>基于深度学习的风格迁移任务的难点在于如何度量图片的风格，如若找到一种可以度量图像风格的数学模型，便可以基于反向传播训练风格迁移网络，以达到良好的风格迁移效果。</p><ol type="1"><li>Gram Matrix</li></ol><p>2015年Gatys利用GramMatrix实现了图像风格的定量计算方法，现在大多数图像风格迁移的风格度量均采用GramMatrix或者Gram Matrix的改进版本。因为本文所用风格度量方法也是基于GramMatrix的，于是先简单介绍一下什么是Gram Matrix。</p><p><img src="gram.png" alt="gram" style="zoom: 25%;"></p><p>当输入一幅图像（<code>2xWxH</code>）进入卷积神经网络时，图像经过卷积层会得到<code>CxWxH</code>的图像特征，在特征的每个通道特征<code>1xWxH</code>上保留了图像的高语义特征（包括内容和风格），但是不同通道之间的学习到的特征内容是不同。比如输入是一幅人脸图像，经过卷积网络之后可能通道1学习到了人脸鼻子特征，而通道2学习到了眼睛特征，它们的特征主体是不一样的，但同时他们来源于同一幅图像，他们的风格应该是一样的，由此Gatys通过计算不同通道特征向量<code>W*H</code>的的协方差矩阵（<code>CxC</code>）定量刻画图像的风格。具体做法是将卷积网络中特征图每个通道的特征reshape成一个向量（<code>1xWxH-&gt;1xWH</code>）然后计算不同通道特征的（偏心）协方差矩阵，这个就矩阵就是GramMatrix。操作示意图如上所示（图源<a href="https://blog.csdn.net/Hi_maxin/article/details/84979580?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BBgram&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-84979580.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">CSDN</a>）：</p><ol start="2" type="1"><li>风格转换网络结构</li></ol><p>使用的风格转换网络来源于Cui的《Multi-style Transfer: GeneralizingFast Style Transfer to Several Genres》，网络结构图如下所示。</p><p><img src="transnet.png" style="zoom: 50%;"></p><p>从图中可以看到风格转换网络由两个网络拼接而成，<code>Image Transform Net</code>用于向陌生的图像融合学习到的风格特征；<code>Loss Network</code>仅用在网络训练阶段，借用<code>Loss Network</code>以得到图像的内容损失和风格损失，以此更新模型参数。具体而言，输入陌生图片<span class="math inline">\(x\)</span>（一般情况下也是内容图像），经过<code>Image Transform Net</code>得到融合新风格的图像<span class="math inline">\(\hat{y}\)</span>，然后将风格迁移后图像<span class="math inline">\(\hat{y}\)</span>、风格图像<span class="math inline">\(y_{s}\)</span>和内容图像（也即原始图像）<span class="math inline">\(y_{c}\)</span>分别送入<code>Loss Network</code>，<code>Loss Network</code>是VGG-16的特征提取网络。分别保存三幅图像在前、后卷积层的输出响应（特征图），针对风格迁移后图像<span class="math inline">\(\hat{y}\)</span>和风格图像<span class="math inline">\(y_{s}\)</span>分别计算其GramMatrix，然后利用<code>MSELoss()</code>度量风格差异；针对风格迁移后图像<span class="math inline">\(\hat{y}\)</span>和内容图像<span class="math inline">\(y_{c}\)</span>直接使用<code>MSELoss()</code>度量图像之间特征主体的差异。</p><h3 id="基于pytorch的快速风格迁移实例">2.基于Pytorch的快速风格迁移实例</h3><hr><blockquote><p>环境：windows 10 + RTX3060 + CUDA 11.4</p></blockquote><blockquote><p>requirements：</p></blockquote><figure class="highlight tcl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tcl">matplotlib==<span class="hljs-number">3.4</span><span class="hljs-number">.3</span><br>numpy==<span class="hljs-number">1.21</span><span class="hljs-number">.4</span><br>Pillow==<span class="hljs-number">8.4</span><span class="hljs-number">.0</span><br>torch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span><br>torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.1</span><br>tqdm==<span class="hljs-number">4.62</span><span class="hljs-number">.3</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>代码主要参考:https://blog.csdn.net/weixin_48866452/article/details/109309245</p></blockquote><hr><h4 id="数据集构建">2.1 数据集构建</h4><hr><p>对于风格迁移任务来说训练样本不需要太多，最少两张图片便可完成风格转换的训练。本次选取了3张风格图片与6张内容图片构建风格迁移的数据集。风格和内容图片示例如下：</p><p><img src="datas.png"></p><p><img src="datac.png"></p><blockquote><p>样本图片来自于这个<a href="https://github.com/irasin/Pytorch_Style_Swap/tree/master">GitHub仓库</a>。</p></blockquote><p>具体的内容数据集加载方式如下方代码所示：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Content_Dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>(Content_Dataset, self).__init__()<br>        r_path = <span class="hljs-string">'dataset/content/'</span> <span class="hljs-comment"># 存放内容图片的路径</span><br>        c_img_name = os.listdir(r_path)<br>        self.c_img_path = [r_path+i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c_img_name]<br>        self.transforms = T.Compose([<br>            T.Resize((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)),<br>            T.ToTensor(),<br>        ])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index</span>):</span><br>        c_img = Image.<span class="hljs-built_in">open</span>(self.c_img_path[index])<br>        <br>        <span class="hljs-keyword">return</span> self.transforms(c_img)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.c_img_path)<br><br></code></pre></td></tr></tbody></table></figure><h4 id="风格迁移网络-1">2.2 风格迁移网络</h4><hr><p>迁移网络采用自编码结构，先用卷积将图像尺度缩小并学习高语义特征，再利用上采样将图像尺度放大，保证图像风格变换前后大小不变。迁移网络的Pytorch实现如下：</p><ol type="1"><li>TransNet</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResBlock</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channels</span>):</span><br>        <span class="hljs-built_in">super</span>(ResBlock, self).__init__()<br>        self.layer = nn.Sequential(<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(channels), <span class="hljs-comment"># 在图像像素上，对每个通道的HW做归一化。</span><br>            nn.ReLU(),<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(channels)<br>        )<br>        self.relu = nn.ReLU()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.relu(self.layer(x)+x)<br>    <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransNet</span>(<span class="hljs-params">nn.Module</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TransNet, self).__init__()<br>        self.layer = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">128</span>),<br>            nn.ReLU(),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            nn.Upsample(scale_factor=<span class="hljs-number">2</span>, mode=<span class="hljs-string">'nearest'</span>),<br>            nn.Conv2d(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.Upsample(scale_factor=<span class="hljs-number">2</span>, mode=<span class="hljs-string">'nearest'</span>),<br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>),<br>            nn.Sigmoid()<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.layer(x)<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>LossNet</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vgg16</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>(Vgg16, self).__init__()<br>        <span class="hljs-comment"># 直接加载预训练的VGG16网络提取图像特征</span><br>        loss_net = M.vgg16(pretrained=<span class="hljs-literal">True</span>)<br>        loss_net = loss_net.features<br>        self.feature1 = loss_net[:<span class="hljs-number">4</span>]<br>        self.feature2 = loss_net[<span class="hljs-number">4</span>:<span class="hljs-number">9</span>]<br>        self.feature3 = loss_net[<span class="hljs-number">9</span>:<span class="hljs-number">16</span>]<br>        self.feature4 = loss_net[<span class="hljs-number">16</span>:<span class="hljs-number">23</span>]<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        feature1 = self.feature1(x)<br>        feature2 = self.feature2(feature1)<br>        feature3 = self.feature3(feature2)<br>        feature4 = self.feature4(feature3)<br><br>        <span class="hljs-keyword">return</span> feature1, feature2, feature3, feature4<br>    <br></code></pre></td></tr></tbody></table></figure><h4 id="必要的工具函数">2.3 必要的工具函数</h4><hr><p>因为风格迁移没有定量评估迁移好坏的指标（一般都是通过人眼自行观察风格迁移结果去确定迁移性能），所以这里的工具函数目前包括Gram矩阵的计算函数和训练过程可视化函数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义gram矩阵</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_gram_matrix</span>(<span class="hljs-params">feature_map</span>):</span><br>    n, c, h, w = feature_map.shape<br>    feature_map = feature_map.reshape(n*c, h*w)<br>    gram_matrix = t.mm(feature_map, feature_map.t())<br>    <span class="hljs-keyword">return</span> gram_matrix.div(n*c*h*w)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练过程损失可视化</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">training_process_visualization</span>(<span class="hljs-params">data</span>):</span><br>    style_loss = data[<span class="hljs-string">'style_loss'</span>]<br>    content_loss = data[<span class="hljs-string">'content_loss'</span>]<br>    total_loss = data[<span class="hljs-string">'total_loss'</span>]<br><br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(content_loss)), content_loss)<br>    plt.title(<span class="hljs-string">'content_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'content_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'content_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">2</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(style_loss)), style_loss)<br>    plt.title(<span class="hljs-string">'style_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'style_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'style_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">3</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(total_loss)), total_loss)<br>    plt.title(<span class="hljs-string">'total_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'total_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'total_loss.png'</span>)<br>    plt.show()<br></code></pre></td></tr></tbody></table></figure><hr><p>通常在工具函数中还包括了存储网络超参数的<code>config.py</code>文件，本次风格迁移使用的超参数文件如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>():</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/hosi.jpg'</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/la_muse.jpg'</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/trial.jpg'</span><br>    style_img = <span class="hljs-string">'dataset/style/sketch.png'</span><br>    nw = <span class="hljs-number">0</span> <span class="hljs-comment"># 多线程加载数据集（windows多线程加载有问题，所以改成了0）</span><br>    bs = <span class="hljs-number">3</span> <span class="hljs-comment"># batchsize</span><br>    epochs = <span class="hljs-number">150</span> <br>    lr = <span class="hljs-number">0.001</span><br>    wc = <span class="hljs-number">1</span> <span class="hljs-comment"># 内容损失的权重</span><br>    ws = <span class="hljs-number">100000</span> <span class="hljs-comment"># 风格损失的权重</span><br>    result_path = <span class="hljs-string">'checkpoints'</span> <span class="hljs-comment"># 训练结果保存文件夹</span><br>    save_frequency = <span class="hljs-number">30</span> <span class="hljs-comment"># 每30个epoch保存一次</span><br>    trans = T.ToTensor()<br></code></pre></td></tr></tbody></table></figure><h4 id="网络训练及测试">2.4 网络训练及测试</h4><hr><p><strong>网络训练：</strong>通过更改<code>config.py</code>文件中的<code>style_img</code>路径更改训练的风格图片，然后完成2.1节所示3种风格的学习。具体的<code>train.py</code>如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> tqdm._tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torchvision.utils <span class="hljs-keyword">import</span> save_image<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><br><span class="hljs-keyword">from</span> dataset.my_dataset <span class="hljs-keyword">import</span> Content_Dataset<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> utils.tools <span class="hljs-keyword">import</span> get_gram_matrix, training_process_visualization<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> TransNet, Vgg16<br><br><br><span class="hljs-comment"># 初始化超参数实例</span><br>opt = Config()<br>device = t.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> t.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br><br><span class="hljs-comment"># 加载风格图片</span><br>img_style = opt.trans(Image.<span class="hljs-built_in">open</span>(opt.style_img)).unsqueeze(<span class="hljs-number">0</span>)<br>img_style = img_style.expand(opt.bs, img_style.shape[<span class="hljs-number">1</span>], img_style.shape[<span class="hljs-number">2</span>], img_style.shape[<span class="hljs-number">3</span>])<br>img_style = img_style.to(device)<br><br><span class="hljs-comment"># 创建结果保存文件夹</span><br><span class="hljs-comment"># 创建文件夹</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(opt.result_path):<br>    os.mkdir(opt.result_path)<br><br><span class="hljs-comment"># 初始化内容图片加载器</span><br>content_dataset = Content_Dataset()<br>content_loader = data.DataLoader(content_dataset, opt.bs, num_workers=opt.nw)<br><br><span class="hljs-comment"># 定义模型、优化器、损失函数</span><br>trans_net = TransNet().to(device)<br>loss_net = Vgg16().to(device).<span class="hljs-built_in">eval</span>()<br><br><br>optimizer = t.optim.AdamW(trans_net.parameters(), lr=opt.lr)<br>loss_func = nn.MSELoss().to(device)<br><br><br><span class="hljs-comment"># 利用Vgg16和Gram Matrix度量风格</span><br><span class="hljs-comment"># 此处不用管风格图片的大小因为最后生成的gram matrix大小均为NCxNC</span><br>styles = []<br>features = loss_net(img_style)<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> features:<br>    <span class="hljs-comment"># 这里一定得加上detach()截断风格输入，不然会保留的风格图片的梯度，导致BP失败</span><br>    styles.append(get_gram_matrix(f).detach())<br><br><span class="hljs-comment"># 用于保存训练过程中的损失</span><br>style_loss = []<br>content_loss = []<br>total_loss = []<br><br><span class="hljs-comment"># 更改为tqdm模块内的trange函数以了解训练时间</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(<span class="hljs-number">1</span>, opt.epochs+<span class="hljs-number">1</span>):<br>    trans_net.train()<br>    <span class="hljs-keyword">for</span> i, image <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(content_loader):<br>        image_c = image.to(device)<br>        <span class="hljs-comment"># print(image_c.shape)</span><br>        image_g = trans_net(image_c)<br>       <br>        <span class="hljs-comment"># 计算风格损失</span><br>        loss_s = <span class="hljs-number">0.0</span><br>        outs = loss_net(image_g)<br>        <span class="hljs-keyword">for</span> out, style <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(outs, styles):<br>            loss_s += loss_func(get_gram_matrix(out), style)<br><br>        <span class="hljs-comment"># 计算内容损失</span><br>        contents = loss_net(image_c)<br>        loss_c2 = loss_func(outs[<span class="hljs-number">1</span>], contents[<span class="hljs-number">1</span>])<br><br>        <span class="hljs-comment"># 总损失</span><br>        loss = loss_c2 * opt.wc + loss_s * opt.ws<br>        <span class="hljs-comment"># print(epoch, loss.item(), loss_c2.item(), loss_s.item())</span><br>        style_loss.append(loss_s.item())<br>        content_loss.append(loss_c2.item())<br>        total_loss.append(loss.item())<br><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br>    <span class="hljs-comment"># lr_adjust.step()</span><br><br>    <br>    <span class="hljs-comment"># 中途保存模型</span><br>    <span class="hljs-keyword">if</span> epoch % opt.save_frequency == <span class="hljs-number">0</span>:<br>        all_data = <span class="hljs-built_in">dict</span>(<br>                optimizer=optimizer.state_dict(),<br>                model=trans_net.state_dict(),<br>                info=<span class="hljs-string">u'模型和优化器的所有参数'</span><br>            )<br>        p = opt.style_img.split(<span class="hljs-string">'/'</span>)[-<span class="hljs-number">1</span>]<br>        p = opt.result_path + <span class="hljs-string">"/"</span> + p.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>]<br>        t.save(all_data, <span class="hljs-string">'{}_trans_net_{}.pth'</span>.<span class="hljs-built_in">format</span>(p, epoch))<br>        img_path = <span class="hljs-string">'{}_fuse_{}.jpg'</span>.<span class="hljs-built_in">format</span>(p, epoch)<br>        _, _, h, w = img_style.size()<br>        trans = T.Resize((h, w))<br><br>        save_image([img_style.clone()[<span class="hljs-number">0</span>],trans(image_c[<span class="hljs-number">0</span>]), trans(image_g[<span class="hljs-number">0</span>])], <br>        img_path, padding=<span class="hljs-number">0</span>, normalize=<span class="hljs-literal">True</span>, <span class="hljs-built_in">range</span>=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        <br>data = {<span class="hljs-string">'style_loss'</span>:style_loss, <span class="hljs-string">'content_loss'</span>:content_loss, <span class="hljs-string">'total_loss'</span>:total_loss}<br>training_process_visualization(data)<br></code></pre></td></tr></tbody></table></figure><p>训练过程的损失变化图如下：</p><center class="half"><img src="content_loss.png" alt="content_loss" style="zoom:50%;"><img src="style_loss.png" alt="style_loss" style="zoom: 50%;"><img src="total_loss.png" alt="total_loss" style="zoom:50%;"></center><p><strong>网络测试：</strong>构建<code>test.py</code>文件，加载训练时保存的模型参数，传入需要进行风格迁移的图片，得到风格迁移结果。具体的测试文件如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> name<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.data.dataset <span class="hljs-keyword">import</span> T<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> TransNet<br><span class="hljs-keyword">from</span> torchvision.utils <span class="hljs-keyword">import</span> save_image<br><br>opt = Config()<br>device = t.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> t.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br>trans_net = TransNet().to(device)<br><br>images = glob.glob(<span class="hljs-string">'dataset/content/**'</span>)<br>styles = [<span class="hljs-string">'hosi'</span>, <span class="hljs-string">'la_muse'</span>, <span class="hljs-string">'sketch'</span>, <span class="hljs-string">'trial'</span>]<br><span class="hljs-comment"># 遍历所有content图片</span><br><span class="hljs-keyword">for</span> img_p <span class="hljs-keyword">in</span> images: <br>img = opt.trans(Image.<span class="hljs-built_in">open</span>(img_p)).unsqueeze(<span class="hljs-number">0</span>)<br>img = img.to(device)<br><span class="hljs-comment"># 遍历风格</span><br><span class="hljs-keyword">for</span> style <span class="hljs-keyword">in</span> styles:<br>pred_models = [<span class="hljs-string">'checkpoints/{}_trans_net_{}.pth'</span>.<span class="hljs-built_in">format</span>(style, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>, <span class="hljs-number">151</span>, <span class="hljs-number">30</span>)]<br>outs = []<br>outs.append(img[<span class="hljs-number">0</span>])<br><span class="hljs-comment"># 遍历风格的不同epoch模型</span><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> pred_models:<br>all_data = t.load(m)<br>trans_net.load_state_dict(all_data[<span class="hljs-string">'model'</span>])<br>trans_net.<span class="hljs-built_in">eval</span>() <span class="hljs-comment"># 设置为推理模式</span><br>outs.append(trans_net(img)[<span class="hljs-number">0</span>])<br>name = style + <span class="hljs-string">'_'</span> + img_p[<span class="hljs-number">16</span>:]<br>save_image(outs, name, padding=<span class="hljs-number">0</span>, normalize=<span class="hljs-literal">True</span>, <span class="hljs-built_in">range</span>=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure><h4 id="迁移结果展示">2.5 迁移结果展示</h4><hr><p>最后得到的风格迁移结果如下：</p><p><img src="out1.png"></p><p><img src="out2.png"></p><p><img src="out3.png"></p><p>综合以上三种风格的迁移可视化结果可以看出，（从纵轴上观察）网络在处理人物或者动物图像时，过度的看重了图像的主体特征（内容），忽略了图像风格，这样的情况应该可以通过候选不断调整内容损失和风格损失的权重取得两者之间的平衡去解决，但限于时间和算力，并未做过多的尝试。（从横轴上观察）随着网络训练的加深，迁移后图像的风格也更加自然（虽然我觉得其实<code>epoch=30</code>的时候更像是图像迁移的最终目的<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。</p><h3 id="总结">3. 总结</h3><p>通过这次风格迁移的学习（当然也只是最基础的部分），也让我大致了解风格迁移任务的整体流程，目前完成的效果因为训练时间的限制并不是太好，整体来看有点儿像是风格滤镜那种，不像第一节介绍那种实现图片风格的完全卡通化，后面如果有时间再来好好研究一下。这次任务也让我了解一些新的东西比如：利用<code>Gram Matrix</code>去定量衡量图片风格，自编码网络结构的搭建，利用<code>glob</code>库直接生成目录内文件路径以及不用重复造轮子直接利用Pytorch官方的<code>save_img()</code>保存<code>tensor</code>为图片等等。再接再厉，继续学习<span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>!</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Neural Style</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于CIFAR-10的Pytorch深度学习模板构建</title>
    <link href="/jasonyang.github.io/2021/11/13/%E5%9F%BA%E4%BA%8ECIFAR-10%E7%9A%84Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA/"/>
    <url>/jasonyang.github.io/2021/11/13/%E5%9F%BA%E4%BA%8ECIFAR-10%E7%9A%84Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="基于cifar-10的pytorch深度学习模板构建">基于CIFAR-10的Pytorch深度学习模板构建</h2><p>构建了一个基于CIFAR-10数据集的pytorch版本深度学习baseline，便于以后更快的迁移到其它深度学习任务中去。代码详情请参看<a href="https://github.com/JayHeYang/deep-learning-baseline">GitHub</a>，如有错误，请指正。</p><h2 id="数据集加载">### 数据集加载</h2><ol type="1"><li><p>首先需要从CIFAR-10官网下载打包好的数据集</p><p>CIFAR-10数据集官网：http://www.cs.toronto.edu/~kriz/cifar.html</p><ul><li><p>下载对应Python版本的数据集文件并解压</p></li><li><p>根据官网上的Python加载方式加载数据集</p></li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unpickle</span>(<span class="hljs-params">file</span>):</span><br>    <span class="hljs-keyword">import</span> pickle<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> fo:<br>        <span class="hljs-built_in">dict</span> = pickle.load(fo, encoding=<span class="hljs-string">'bytes'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span><br><br>file = <span class="hljs-string">'/Users/morvan/Downloads/cifar-10-batches-py/data_batch_1'</span><br><span class="hljs-built_in">print</span>(unpickle(file).keys())<br></code></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_keys([<span class="hljs-string">b'batch_label'</span>, <span class="hljs-string">b'labels'</span>, <span class="hljs-string">b'data'</span>, <span class="hljs-string">b'filenames'</span>])<br></code></pre></td></tr></tbody></table></figure><p>经过以上解码加载之后，对返回值<code>dict</code>取<code>dict[b'labels']</code>和<code>dict[b'data']</code>分别获取batch1中的标签和数据，同理可以依次获得batch2-5以及test_batch的标签和数据。</p><blockquote><p><code>dict[b'labels']</code>返回一个长度为10000的列表，每个元素取值范围为0-9，分别对应10个类别的标签。</p></blockquote><blockquote><p><code>dict[b'data']</code>返回一个[10000,3072]的矩阵，存储每张样本图片的RGB像素值。前1024（32x32）是R通道的像素数据，后面依次是B、G通道。</p></blockquote><ol start="2" type="1"><li>完成训练和测试集的样本的解压加载之后，开始第二步：构造数据集加载器类。这个类有三个主要的构造函数分别是：<ol type="1"><li><code>__init__()</code>用于初始化数据集路径和定义一些数据增强Pipline。</li><li><code>__getitem__()</code>用于依据所以获取对应数据增强后的样本（data+label）。</li><li><code>__len__()</code>返回样本集的样本数据量。</li></ol></li></ol><p>具体数据集加载器类构造如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cifar10_Dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data_roots, trans</span>):</span><br>        self.transforms = trans<br>        <span class="hljs-keyword">for</span> k, data_root <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_roots):<br>            data = unpickle(data_root)[<span class="hljs-string">b'data'</span>]<br>            label = unpickle(data_root)[<span class="hljs-string">b'labels'</span>]<br>            <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>                self.all_data = data<br>                self.all_label = label<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># shape-&gt;(50000, 3072) or (10000, 3072)</span><br>                self.all_data = np.vstack((self.all_data, data)) <br>                <span class="hljs-comment"># shape-&gt;(50000, ) or (10000, )</span><br>                self.all_label = self.all_label + label <br>        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-comment"># 调整数据形状为图片格式 (3x32x32), 之后调整通道和图片宽高的排序（CHW-&gt;HWC）</span><br>        sample = np.reshape(self.all_data[idx], (<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)).transpose((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br>        img = Image.fromarray(sample)<br>        img = self.transforms(img) <span class="hljs-comment"># 3x32x32</span><br>        <span class="hljs-keyword">return</span> img, self.all_label[idx]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.all_label)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># storage location datasets</span><br>    file = <span class="hljs-string">'/Users/morvan/Downloads/cifar-10-batches-py/data_batch_1'</span><br>    roots = [file] <br>    trans = T.Compose([<br>        T.RandomCrop(<span class="hljs-number">32</span>),<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>]),<br>    ])<br>    dataset = Cifar10_Dataset(roots, trans)<br>    <span class="hljs-built_in">print</span>(dataset.__getitem__(<span class="hljs-number">10</span>)[<span class="hljs-number">0</span>].shape)<br></code></pre></td></tr></tbody></table></figure><p>至此数据集加载器类构造完成。</p><h3 id="网络模型搭建">网络模型搭建</h3><hr><p>网络模型为ResNet18，这里直接使用Pytorch官方提供的版本（手动更改最后全连接层的节点数为class_num=10）。</p><ol type="1"><li>ResNet18</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResNet18</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, num_classes</span>):</span><br>        <span class="hljs-built_in">super</span>(ResNet18, self).__init__()<br>        resnet18 = M.resnet18(pretrained=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 更改ResNet18最后全连接层的节点数以适应cifar10</span><br>        resnet18.fc = nn.Linear(resnet18.fc.in_features, num_classes)<br>        self.resnet = resnet18<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.resnet(x)<br></code></pre></td></tr></tbody></table></figure><h3 id="工具函数及超参数设置">工具函数及超参数设置</h3><hr><p>构造了两个工具函数<code>calculation_accuracy()</code>和<code>training_process_visualization()</code>分别用于计算准确率和训练过程的可视化。</p><ol type="1"><li>calculation_accuracy()</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculation_accuracy</span>(<span class="hljs-params">pred, label</span>):</span><br>    pred = pred.cpu().detach().numpy() <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>    pred = np.argmax(pred, axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>    right_count = np.<span class="hljs-built_in">sum</span>(pred == label.cpu().numpy()) <br>    acc = right_count / label.size(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> acc<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>training_process_visualization()</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">training_process_visualization</span>(<span class="hljs-params">data</span>):</span><br>    train_acc = data[<span class="hljs-string">'train_acc'</span>]<br>    train_loss = data[<span class="hljs-string">'train_loss'</span>]<br>    test_acc = data[<span class="hljs-string">'test_acc'</span>]<br><br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_loss)), train_loss)<br>    plt.title(<span class="hljs-string">'trian_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'trian loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'step'</span>)<br>    plt.savefig(<span class="hljs-string">'train_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">2</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_acc)), train_acc)<br>    plt.title(<span class="hljs-string">'train_acc'</span>)<br>    plt.ylabel(<span class="hljs-string">'train acc'</span>)<br>    plt.xlabel(<span class="hljs-string">'step'</span>)<br>    plt.savefig(<span class="hljs-string">'train_acc.png'</span>)<br><br>    plt.figure(<span class="hljs-number">3</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(test_acc)), test_acc)<br>    plt.title(<span class="hljs-string">'test_acc'</span>)<br>    plt.ylabel(<span class="hljs-string">'test acc'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'test_acc.png'</span>)<br>    plt.show()<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>config.py</li></ol><p>这个文件一般用来存储模型训练过程中的学习率，数据增强，batchsize，损失函数等超参数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>():</span><br>    train_roots = [<span class="hljs-string">'F:/DeepL/cifar-10-batches-py/data_batch_'</span><br>                        +<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)]<br>    test_roots = [<span class="hljs-string">'F:/DeepL/cifar-10-batches-py/test_batch'</span>]<br>    net = <span class="hljs-string">'Res'</span> <span class="hljs-comment"># 网络结构</span><br>    num_classes = <span class="hljs-number">10</span> <span class="hljs-comment"># 类别数</span><br>    nw = <span class="hljs-number">0</span> <span class="hljs-comment"># 多线程加载数据集（windows多线程加载有问题，所以改成了0）</span><br>    wd = <span class="hljs-number">0.001</span> <span class="hljs-comment"># 权重衰减</span><br>    m = <span class="hljs-number">0.9</span> <span class="hljs-comment"># SGD动量</span><br>    bs = <span class="hljs-number">512</span> <span class="hljs-comment"># batchsize</span><br>    epochs = <span class="hljs-number">20</span> <br>    lr = <span class="hljs-number">0.001</span><br>    <span class="hljs-comment"># 自定义训练和测试数据集所用的数据增强</span><br>    train_trans = T.Compose([<br>        T.RandomCrop(<span class="hljs-number">32</span>),<br>        T.RandomRotation((-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)),<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])])<br>    test_trans = T.Compose([<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])])<br>    <br></code></pre></td></tr></tbody></table></figure><h3 id="训练和测试">训练和测试</h3><hr><h4 id="训练步骤">训练步骤</h4><ol type="1"><li>初始化超参数实例</li><li>定义数据集加载器实例</li><li>定义模型、优化器、损失函数、学习率调整器</li><li>用于保存训练过程中的损失和准确率（可以不用）</li><li>通过两层<code>for</code>循环开始迭代训练<ol type="1"><li>取数据（<code>net.train()</code>）</li><li>优化器梯度置零</li><li>前向传播预测</li><li>计算损失并反向传播</li><li>学习率调整</li><li>每个epoch测试一次（<code>net.eval()</code>）</li></ol></li><li>根据记录的数据可视化训练过程</li></ol><p>完整的<code>train.py</code>如下所示</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">from</span> tqdm._tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> torch.optim.lr_scheduler <span class="hljs-keyword">import</span> StepLR<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><br><span class="hljs-keyword">from</span> dataset.my_dataset <span class="hljs-keyword">import</span> Cifar10_Dataset<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> utils.tools <span class="hljs-keyword">import</span> calculation_accuracy, training_process_visualization<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> ResNet18<br><br><br><span class="hljs-comment"># 初始化超参数实例</span><br>opt = Config()<br><br><span class="hljs-comment"># 初始化训练集、测试集加载器实例</span><br>trainset = Cifar10_Dataset(data_roots=opt.train_roots, trans=opt.train_trans)<br>trainset_loader = data.DataLoader(trainset, opt.bs, num_workers=opt.nw, shuffle=<span class="hljs-literal">True</span>)<br>testset = Cifar10_Dataset(data_roots=opt.test_roots, trans=opt.test_trans)<br>testset_loader = data.DataLoader(testset, opt.bs, num_workers=opt.nw)<br><br><span class="hljs-comment"># 定义模型、优化器、损失函数、学习率调整器</span><br>net = ResNet18(opt.num_classes)<br>optimizer = t.optim.SGD(net.parameters(), lr=opt.lr, momentum=opt.m, weight_decay=opt.wd)<br>loss_func = nn.CrossEntropyLoss()<br>lr_adjust = StepLR(optimizer, step_size=<span class="hljs-number">30</span>, gamma=<span class="hljs-number">0.1</span>)  <br><br><span class="hljs-comment"># 用于保存训练过程中的损失和准确率</span><br>train_loss = []<br>train_acc = []<br>test_acc = []<br><br><span class="hljs-keyword">if</span> t.cuda.is_available():<br>    net.cuda()<br>    loss_func.cuda()<br><br><span class="hljs-comment"># 更改为tqdm模块内的trange函数以了解训练时间</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(<span class="hljs-number">1</span>, opt.epochs+<span class="hljs-number">1</span>):<br>    net.train()<br>    <span class="hljs-keyword">for</span> i, (data, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trainset_loader):<br>        <span class="hljs-keyword">if</span> t.cuda.is_available():<br>            data, label = data.cuda(), label.cuda()<br><br>        optimizer.zero_grad()<br>        pred = net(data)<br><br>        loss = loss_func(pred, label)<br>        acc = calculation_accuracy(pred, label)<br>        loss.backward()<br>        optimizer.step()<br><br>         <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>        train_loss.append(loss.cpu().detach().numpy())<br>        train_acc.append(acc)<br>        <span class="hljs-comment"># print('loss:', loss.cpu().detach().numpy(), "acc", acc)</span><br>    lr_adjust.step()<br><br>    <br>    <span class="hljs-comment"># 每训练完一轮进行一次测试</span><br>    net.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">for</span> j, (data, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(testset_loader):<br>        <span class="hljs-keyword">if</span> t.cuda.is_available():<br>            data, label = data.cuda(), label.cuda()<br>        test_pred = net(data)<br>        <br>        all_pred = test_pred <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> t.vstack((all_pred, test_pred))<br>        all_label = label <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> t.cat((all_label, label))<br>    <br>    acc = calculation_accuracy(all_pred, all_label)<br>    test_acc.append(acc)<br><br><br>data = {<span class="hljs-string">'train_loss'</span>:train_loss, <span class="hljs-string">'train_acc'</span>:train_acc, <span class="hljs-string">'test_acc'</span>:test_acc}<br>training_process_visualization(data)<br></code></pre></td></tr></tbody></table></figure><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>baseline</tag>
      
      <tag>Cifar10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git操作指南</title>
    <link href="/jasonyang.github.io/2021/09/25/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <url>/jasonyang.github.io/2021/09/25/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="git-操作指令">Git 操作指令</h2><h3 id="git-是什么">0. Git 是什么</h3><hr><p>Git是一个先进便捷的分布式版本控制系统。它可以实现对纯文本文件（code、txt、csv、md...）的修改提示（具体到某行）、回退到之前的版本、创建不同分支等等操作，这些操作都是可协作的。</p><h3 id="创建本地仓库预备">1. 创建本地仓库（预备）</h3><hr><p>打开GitBash命令行窗口，然后配置一下自己的名字和邮箱（自报家门），方便协作者看到是谁修改提交了版本，配置之后全局有效，你在当前电脑上的每个Git仓库都是使用这个配置。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"jasonyang"</span><br>$ git config --global user.email <span class="hljs-string">"jayheyang@gmail.com"</span><br></code></pre></td></tr></tbody></table></figure><ol type="1"><li><strong>切换到想要建立仓库的文件目录。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /h/code<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li><strong>在当前目录创建新的文件夹<code>learngit</code>,然后切换到<code>learngit</code>目录。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir learngit<br>$ <span class="hljs-built_in">cd</span> learngit <br></code></pre></td></tr></tbody></table></figure><blockquote><p>可使用<code>pwd</code>指令查看当前目录</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>out-&gt; /h/code/learngit<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>使用<code>git init</code>命令使得该目录变成可以被Git管理的仓库（文件夹）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br></code></pre></td></tr></tbody></table></figure><h3 id="将文件添加到仓库">2. 将文件添加到仓库</h3><hr><ol type="1"><li><strong>编写文本文件，可以是<code>.py</code>，<code>.md</code>，<code>.txt</code>等，编写<code>readme.txt</code>，并保存到当前Git目录。</strong></li></ol><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># readme.txt</span><br>Git is <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> control <span class="hljs-keyword">system</span>.<br>balabala...<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li><strong>把文件添加到Git的暂存区。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add readme.txt<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>把所有暂存区的文件提交到Git仓库。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">"wrote a readme file"</span><br></code></pre></td></tr></tbody></table></figure><p><code>-m</code>指令表示对本次提交的文件添加一个说明。</p><h3 id="常用指令">3. 常用指令</h3><hr><h4 id="基础储备">3.1 基础储备</h4><hr><ul><li><strong>basic command</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init <br>$ git add test.py<br>$ git commit -m <span class="hljs-string">"modified XXXX"</span><br></code></pre></td></tr></tbody></table></figure><ol type="1"><li><strong>查看当前仓库状态，了解是否有些文件被删改。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li><strong>查看当前工作区文件与版本库文件有什么不同。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff readme.txt <span class="hljs-comment"># readme.txt与当前版本库里readme.txt的不同</span><br>$ git diff HEAD^ -- readme.txt <span class="hljs-comment"># readme.txt与上一个版本（上一次提交）里的readme.txt的异同。</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>找到不同之后可以根据情况使用<code>git add</code>和<code>git commit</code>添加并提交文件，或者使用<code>git reset</code>回退到修改前的版本。</p></blockquote><ol start="3" type="1"><li><strong>查看提交的版本日志，包括分支（如果有的话）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><br>or<br>$ git <span class="hljs-built_in">log</span> --pretty=oneline<br><br>$ git <span class="hljs-built_in">log</span> --graph <span class="hljs-comment"># 可以看到分支的合并流程图</span><br></code></pre></td></tr></tbody></table></figure><p><code>--pretty=oneline</code>可以让返回的日志信息更加简略。</p><ol start="4" type="1"><li><strong>版本回退（针对已经进行<code>git add</code>甚至<code>git commit</code>操作的情况）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset <span class="hljs-comment"># 移除仓库暂存区的修改，但不改变工作区文件，相当于撤销git add操作。</span><br>$ git reset &lt;commit id&gt; <span class="hljs-comment"># 将仓库分支回退到指定&lt;commit id&gt;版本， 其余同上。</span><br>$ git reset --hard <span class="hljs-comment"># 清除暂存区和工作区的改动。会强制修改工作区文件。</span><br>$ git reset --hard &lt;commit id&gt; <span class="hljs-comment"># 将仓库分支回退到指定&lt;commit id&gt;版本， 其余同上。</span><br><br>$ git reset --hard HEAD^ <span class="hljs-comment"># 回退到当前版本的上一个版本</span><br>$ git reset --hard HEAD~1 <span class="hljs-comment"># 回退到当前版本的上一个版本</span><br><br>$ git reset --hard HEAD^^ <span class="hljs-comment"># 回退到当前版本的上两个版本</span><br>$ git reset --hard HEAD~2 <span class="hljs-comment"># 回退到当前版本的上两个版本。</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>&lt;commit id&gt;</code>可以不用写全，类似<code>1098abd</code>这种前面几位就可以了。</p></blockquote><blockquote><p>没有加<code>--hard</code>的命令手动打开本地工作区文件例如<code>readme.txt</code>不会看到修改的内容撤销了，加了<code>--hard</code>的命令则会看到文件的内容回到了修改之前。</p></blockquote><ol start="5" type="1"><li><strong>撤销修改（针对还未将修改文件提交到暂存区或者仓库的情况）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -- readme.txt<br></code></pre></td></tr></tbody></table></figure><p>撤销工作区里<code>readme.txt</code>文件最近的一次修改，如果文件提交到暂存区，则需要采用第4点的<code>git reset</code>操作进行回退。</p><blockquote><p>注意：如果不小心将工作区文件<code>rm</code>删除了，也可以使用<code>git checkout -- &lt;file name&gt;</code>进行误删恢复，<code>checkout</code>指令就是保证工作区和版本库的文件一致。</p></blockquote><ol start="6" type="1"><li><p><strong>彻底删除文件</strong></p><ol type="1"><li>删除工作区文件</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rm test.py<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>删除版本仓库文件</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rm test.py<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="3" type="1"><li>向Git仓库报告本次删除操作</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">"remove test.py"</span><br></code></pre></td></tr></tbody></table></figure><p></p></li><li><p><strong>为每次提交打标签</strong></p><ol type="1"><li>为最近一次提交打标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.0 <span class="hljs-comment"># 为当前提交commit-&gt;HEAD打上v1.0的标签</span><br>$ git tag -a v1.0 -m <span class="hljs-string">"version 1.0 released"</span> <span class="hljs-comment"># 打标签同时，提供标签说明</span><br></code></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>为指定<code>commit id</code>打标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v0.9 f64c633 <br>$ git tag -a v1.0 -m <span class="hljs-string">"version 1.0 released"</span> f64c633<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="3" type="1"><li>查看标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag <span class="hljs-comment"># 查看已打的标签</span><br>$ git show v1.0 <span class="hljs-comment"># 详细查看v1.0本次提交操作</span><br></code></pre></td></tr></tbody></table></figure><p></p><ol start="4" type="1"><li>删除标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v1.0<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="5" type="1"><li>推送标签到远程、删除远程标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin v1.0 <span class="hljs-comment"># 推送v1.0标签到远程`origin`分支</span><br>$ git push origin --tags <span class="hljs-comment"># 一次性推送所有标签</span><br></code></pre></td></tr></tbody></table></figure><p></p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v1.0 <span class="hljs-comment"># 先删除本地标签</span><br>$ git push origin :refs/tags/v1.0 <span class="hljs-comment"># 用'push'删除远程</span><br></code></pre></td></tr></tbody></table></figure><p></p></li></ol><h4 id="分支管理">3. 分支管理</h4><hr><p>分支是Git里面关键的功能，其能够实现平行化版本时间线，也能合并不同分支时间线的版本。推荐创建以下分支：</p><ul><li>master 默认创建的分支，负责更迭正式版本。</li><li>dev协作分支，团队成员之间相互协作，测试版本更迭情况将在此分支的时间线上体现。</li><li>bug bug分支，一般只在本地库，用于修改程序bug。</li><li>feature 记录更迭自己本地更改的版本。</li></ul><p>团队协作的Git版本库分支示意图（图源<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480">廖雪峰官方网站</a>）:</p><p><img src="1.png"></p><ol type="1"><li><strong>创建、查看分支</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev <span class="hljs-comment"># 创建并切换到dev分支</span><br>$ git switch -c dec <span class="hljs-comment"># 创建并切换到dev分支</span><br><br>$ git checkout master <span class="hljs-comment"># 切换到master分支</span><br>$ git switch master <span class="hljs-comment"># 切换到master分支</span><br></code></pre></td></tr></tbody></table></figure><p><code>switch</code>和<code>checkout</code>都可实现分支的创建与切换，老版本的<code>Git</code>使用<code>checkout</code>进行分支管理和文件恢复，现在分别由<code>switch</code>和<code>restore</code>管理。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-comment"># 查看当前版本库所有的分支</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>各个分支之前管理的版本文件相互独立，修改一个分支的版本文件不会影响另一个分支。</p></blockquote><ol start="2" type="1"><li><strong>合并、删除分支</strong></li></ol><p><strong>合并分支</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge dev <span class="hljs-comment"># 将dev分支合并到当前分支</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>单独调用<code>git merge</code>命令时会采用<code>Fast-Forward</code>合并模式，合并完成之后会将分支<code>dev</code>时间上的<code>commit</code>混合到分支<code>master</code>的时间线上去，此时如果实行版本回退则会回退到<code>dev</code>分支所提交的内容，而不是目标<code>master</code>分支上的内容。</p></blockquote><p>上述问题的解决办法就是使用<code>git merge --no-ff</code>指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge --no-ff -m <span class="hljs-string">"merge with no fast-forward"</span> dev<br></code></pre></td></tr></tbody></table></figure><p>该指令可以保留<code>dev</code>分支的提交信息,在分支<code>master</code>上进行版本回退时，可以正确退回<code>master</code>分支上的上一个版本，而不是<code>dev</code>分支上的上一个版本。</p><p><code>no-ff</code>合并操作包含了一次<code>git commit</code>，因此<code>-m</code>参数是为了加上提交说明。</p><blockquote><p>合并分支时，如果当前分支和被合并的分支都在上一个版本基础上进行了修改，合并会失败。同时发生合并冲突的文件例如<code>readme.txt</code>会自动添加内容告诉我们发生冲突的地方，此时需要手动修改冲突的文件。</p></blockquote><p><code>readme.txt</code>冲突发生后，打开文件可看到如下提示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Git is a version control system.<br>balabala...<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">Creating a new branch is quick AND simple.</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></code></pre></td></tr></tbody></table></figure><p>然后需要手动修改<code>readme.txt</code>文件为：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Git is <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> control <span class="hljs-keyword">system</span>.<br>balabala...<br>Creating <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch is quick <span class="hljs-keyword">and</span> simple.<br></code></pre></td></tr></tbody></table></figure><p>之后再执行<code>git add</code>和<code>git commit -m</code>提交到版本仓库，手动解决合并冲突。</p><p><strong>删除分支</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d dev <span class="hljs-comment"># 删除dev分支</span><br></code></pre></td></tr></tbody></table></figure><p>如果分支未合并，使用上面的删除指令会报错，这时需要使用下面的指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -D dev <span class="hljs-comment"># 删除dev分支</span><br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>暂存工作区的任务</strong></li></ol><p>当遇到正在写的任务没写完，又发现了一个紧急任务时，需要当前任务先暂存起来，先处理紧急任务，处理完成之后再回到当前的任务中来。Git提供了解决方案：<code>git stash</code>。</p><ol type="1"><li>存储当前的任务(假设在<code>dev</code>分支)</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>去到紧急任务的分支，处理紧急任务</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch master<br>$ git XXX<br>....<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>回到之前任务分支，恢复任务</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch dev<br>$ git stash list <span class="hljs-comment"># 查看被暂存的所有任务列表</span><br>$ git stash pop <span class="hljs-comment"># 恢复最近的一个暂存任务</span><br>$ git stash pop stash@{0} <span class="hljs-comment"># 恢复暂存的标号0任务，标号从list的输出信息中得到</span><br></code></pre></td></tr></tbody></table></figure><h3 id="远程仓库操作">4. 远程仓库操作</h3><hr><ol start="0" type="1"><li><strong>预备工作</strong></li></ol><p>第1步：创建私钥和公钥：打开<code>Git Bash</code>命令行窗口，输入下列指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">"jayheyang@gmail.com"</span>?<br></code></pre></td></tr></tbody></table></figure><blockquote><p>地址记得改成自己的email！！！</p></blockquote><p>创建完成之后会在用户目录下（例如<code>/c/Users/Administrator</code>）找到<code>.ssh</code>文件夹，里面会有两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><p>第2步：打开GitHub，登陆。然后依次点击：<code>用户头像</code>-&gt;<code>Settings</code>-&gt;左侧边栏的<code>SSH and GPG keys</code>-&gt;<code>New SSH key</code>。</p><p>第3步：打开<code>id_rsa.pub</code>文件，<code>ctrl A</code>全选，<code>ctrl C</code>复制，切换到GitHub页面，<code>Title栏</code>随便写，相当于给你的这个密钥起名字。然后在<code>Key栏</code>中粘贴刚才复制的文本。</p><p><strong>预备工作完成。</strong></p><ol type="1"><li><p><strong>关联本地仓库与远程仓库</strong></p><ul><li>在GitHub上创建repository</li><li>进入创建的repo，获取SSH链接（形如<code>git@github.com:JayHeYang/learngit.git</code>）,打开<code>Git Bash</code>并切换到Git版本库目录，然后输入以下指令关联。</li></ul><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:JayHeYang/learngit.git<br></code></pre></td></tr></tbody></table></figure><p></p><p><code>origin</code>是默认的远程仓库名，可自行修改。</p></li><li><p><strong>将本地仓库文件<code>push</code>上去</strong></p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin master<br></code></pre></td></tr></tbody></table></figure><p><code>-u</code>的作用是将<code>本地master</code>分支和<code>远程master</code>分支关联起来，后面只需要进行<code>$ git push origin master</code>指令即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master <span class="hljs-comment"># push到远程端的master分支</span><br>$ git push origin dev <span class="hljs-comment"># push到远程端的dev分支</span><br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>查看所关联的远程库，或者删除与远程库的关联</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v <span class="hljs-comment"># 查看当前本地仓库关联的远程库</span><br>$ git remote rm origin <span class="hljs-comment"># 解除与远程库origin的关联</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>git remote rm</code>指令只是完成了解绑，如果要删除远程库中的文件还得在GitHub上修改。</p></blockquote><ol start="4" type="1"><li><p><strong>从远程仓库克隆文件</strong></p><p>1.切换到需要存储克隆文件的目录：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir clonetest<br>$ <span class="hljs-built_in">cd</span> clonetest<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>获取需要克隆仓库的SSH连接（形如<code>git@github.com:JayHeYang/learngit.git</code>）执行<code>clone</code>指令。</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:JayHeYang/learngit.git<br></code></pre></td></tr></tbody></table></figure><p></p><p>克隆完成。</p></li></ol><p>如果是其他协作人从远程仓库clone时默认只能看到<code>master</code>分支，如果想要在<code>dev</code>分支上做开发，需要创建远程<code>origin</code>的<code>dev</code>分支到本地，用以下命令行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -d dev origin/dev <br>或者<br>$ git switch -c dev origin/dev<br></code></pre></td></tr></tbody></table></figure><p>5.<strong>抓取分支并<code>push</code>上去</strong></p><p>多人协作的流程是： 第1步：按照任务要求在本地分支上完成修改。第2步：从远程仓库抓取分支，在本地合并，解决冲突。第3步：将本地分支<code>push</code>到远程分支上，更新进度。</p><p>遵循以下命令顺序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch dev <span class="hljs-comment"># 切换到工作分支</span><br>或者<br>$ git checkout -d dev origin/dev <span class="hljs-comment"># 将远程`origin`的`dev`分支创建到本地</span><br><br>$ git branch --set-upstream-to=origin/dev dev <span class="hljs-comment"># 将本地分支与远程分支绑定</span><br><br>$ git pull <span class="hljs-comment"># 抓取远程dev分支（抓取完成之后会自动进行合并）</span><br>$ git pull origin master <span class="hljs-comment"># 也可以直接指定分支抓取</span><br><br>手动解决合并冲突（如果有的话）<br><br>$ git add test.py <span class="hljs-comment"># 添加解决冲突后的文件</span><br><br>$ git commit -m <span class="hljs-string">"fix bug"</span><br><br>$ git push origin dev <span class="hljs-comment"># push到远程分支</span><br></code></pre></td></tr></tbody></table></figure><p><strong>2022年3月3日11:09:23 更新：</strong></p><hr><p><strong>注意</strong>：在<code>github</code>创建<code>repo</code>时如果添加了<code>readme.md</code>或者<code>LINCESE</code>等文件则在<code>push</code>之前得用以下操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git pull origin main --allow-unrelated-histories <span class="hljs-comment"># 使用这个指令，来把远程仓库和本地同步，消除两个文档间的差异，其实也就是把远端文件下载下来</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>为了回避种族歧视，现在创建<code>repo</code>默认将<code>master</code>更改为了<code>main</code>。</p></blockquote><p><code>Git</code>速查表：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/1009686-20160824100127870-1820786836.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="参考文献">参考文献</h3><hr><p>廖雪峰的Git的教程：https://www.liaoxuefeng.com/wiki/896043488029600</p><p>Git快查表：https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf</p><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simple Online and Realtime Tracking</title>
    <link href="/jasonyang.github.io/2021/09/23/Simple-Online-and-Realtime-Tracking/"/>
    <url>/jasonyang.github.io/2021/09/23/Simple-Online-and-Realtime-Tracking/</url>
    
    <content type="html"><![CDATA[<h2 id="paper-note-simple-online-and-realtime-tracking">Paper Note ——Simple Online and Realtime Tracking</h2><h3 id="文献简介">1.文献简介</h3><hr><ul><li>作者：Alex Bewley、Zongyuan Ge、Lionel Ott</li><li>关键词：Computer Vision, Multiple Object Tracking, Detection, DataAssociation</li><li>年份&amp;期刊（会议）名：IEEE 2016</li></ul><h3 id="结构和内容">2. 结构和内容</h3><hr><ol type="1"><li>介绍目标跟踪的任务流程，目前算法存在的问题和本文算法的优势</li><li>阐述研究背景和现状</li><li>介绍方法论<ul><li>检测模型</li><li>运动评估模型</li><li>数据关联</li><li>消失目标与先出现目标的销毁与创建</li></ul></li><li>实验部分</li></ol><h3 id="创新点实验成果汇总">3.创新点/实验成果汇总</h3><hr><ol type="1"><li>提出了端到端的跟踪模型，运用了tracking bydetection的思想，把主要关注点放在了assignment。</li><li>提出了跟踪领域的baseline。</li><li>运用Kalman filter和Hungarianalgorithm进行匀速模型估计和人物关联。（cost matrix 是IOUdistance）。</li><li>在score较高的情况下达到了一个高的FPS。</li></ol><h3 id="需要改进的地方">4.需要改进的地方</h3><hr><ol type="1"><li>仅用IOU的距离度量不能完全表达目标和预测之间的联系度。</li><li>检测的模型不算特别先进（当时还不错，backbone应该是在性能与运算量之间取了平衡）。</li><li>没有整合其他的人体信息，无法处理行人长时被遮挡的情况。</li></ol><h3 id="重要内容摘录">5.重要内容摘录</h3><hr><ul><li><p>指标的描述方法值得借鉴 <img src="sort1.png"></p></li><li><p>算法速度和性能的二维展示图 <img src="sort2.png"></p></li></ul><p>z</p>]]></content>
    
    
    <categories>
      
      <category>目标跟踪</category>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Hexo框架下Fluid主题自带搜索框一直loading的问题</title>
    <link href="/jasonyang.github.io/2021/08/26/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E4%B8%8BFluid%E4%B8%BB%E9%A2%98%E6%90%9C%E7%B4%A2%E4%B8%80%E7%9B%B4loading%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/jasonyang.github.io/2021/08/26/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E4%B8%8BFluid%E4%B8%BB%E9%A2%98%E6%90%9C%E7%B4%A2%E4%B8%80%E7%9B%B4loading%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="解决hexo框架下fluid主题自带搜索框一直loading的问题">解决Hexo框架下Fluid主题自带搜索框一直loading的问题</h1><p>最开始根据Fluid主题创建个人博客时发现搜索框一直显示loading，不能进行本地搜索。最开始尝试百度和Google解答无果，便搁置了下去。最近有了时间便开始尝试解决，最终使用了一种可行的方案达到了本地搜索效果。</p><h2 id="问题描述">问题描述</h2><p>fluid主题无法搜索的问题如下：当点击博客页面的<strong>搜索</strong>按钮时，搜索页面会一直显示<strong>Loading</strong>，如下图所示：</p><p><img src="1.jpg"></p><h2 id="寻找原因">寻找原因</h2><p>打开自己的博客根文件夹，如我的就是<code>blog</code>，然后打开<code>themes\fluid\_config.yml</code>，找到<code>search</code>模块，如下所示：</p><p><img src="2.jpg"></p><p>从图中可以看到我们搜索索引的文件是<code>local-search.xml</code>，然命令行切换到<code>blog</code>目录启动hexo三连发。</p><figure class="highlight sas"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">cd blog<br>hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo s<br></code></pre></td></tr></tbody></table></figure>打开Chrome浏览器，通过localhost链接打开博客主页，然后点击搜索按钮，使用F12查看报错信息，可以看到如下报错。<p></p><p><img src="3.jpg"></p><p>可以发现是因为找不到这个搜索文件引发的报错，因此就有了解决方案version1。</p><h2 id="解决方案version1">解决方案version1</h2><p>因为搜索框一直loading的原因是找不到生成的<code>.xml</code>文件，然后尝试在自己的<code>blog</code>文件夹中查找<code>local-search.xml</code>文件，发现确实有随着<code>hexo g</code>命令一起生成的<code>local-search.xml</code>文件，但是文件内部并没有博客的内容，因此即使更换为该文件同样无法起到搜索作用（这个本地搜索功能本质上就是检索<code>.xml</code>文件内部的内容，因此没有博客内容的<code>.xml</code>文件起不到任何检索作用）。</p><p>接下来仔细查看<code>blog</code>文件夹，发现在<code>blog\public\</code>文件夹内生成了一个<code>search.xml</code>文件，该文件包含了博客内部的内容应该能起到检索作用。那么，开始修改！同样，打开<code>blog\themes\fluid\_config.yml</code>，找到<code>search</code>模块，更改path如下所示：</p><p><img src="4.jpg"></p><p>再次启动hexo三连大法，然后可以看到<code>主页</code>的搜索已经可以正常检索了，然而当点击到<code>分类</code>d等其他页面时，再点击搜索，同样还是Loading。</p><p><img src="5.jpg"> <img src="1.jpg"></p><p>再次使用F12查看问题</p><p><img src="6.jpg"></p><p>发现全使用<code>search.xml</code>之后在跳转其他页面时Fluid会自动在地址上加入页面标签，比如分类页面就加上了<code>categories</code>(主页时是<code>http://localhost:4000/jasonyang.github.io/search.xml</code>，而分类页变为了<code>http://localhost:4000/jasonyang.github.io/categories/search.xml</code>)</p><p>然后就想到了使用绝对的文件索引地址，由此再每次切换页面时检索文件的地址就不会发生变化。</p><h2 id="解决方案version2">解决方案version2</h2><p>因为这个博客是为了部署到GitHub上面，因此这里将<code>blog\themes\fluid\_config.yml</code>，文件<code>search</code>版块的path更改为<code>博客项目的地址</code>+<code>search.xml</code>。例如：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">path: <span class="hljs-regexp">//</span>jayheyang.github.io<span class="hljs-regexp">/jasonyang.github.io/</span>search.xml<br></code></pre></td></tr></tbody></table></figure><p>最后<code>hexo d</code>部署到GitHub Pages，测试结果如下：</p><p><img src="7.jpg"></p><hr><p>挖个坑，2021年8月13日之后在使用<code>hexo d</code>部署时会遇到<code>Spawn failed</code>错误，网上搜索该错误的解决方法都不对，改天再说如何解决。</p><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hexo和GitHub搭建自己的博客网站</title>
    <link href="/jasonyang.github.io/2021/08/26/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/jasonyang.github.io/2021/08/26/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="基于hexo和github搭建自己的博客网站">基于Hexo和GitHub搭建自己的博客网站</h3><p>单边联动，基本框架搭建请参考Luo Xu的博客：点击<a href="https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/">这里</a>跳转。</p><h3 id="主题使用">主题使用</h3><p>本篇博客采用的是Fluid主题，主题的仓库链接如下：https://github.com/fluid-dev/hexo-theme-fluid</p><p>主题的详细使用指南：https://fluid-dev.github.io/hexo-fluid-docs/guide/</p><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown简易指南</title>
    <link href="/jasonyang.github.io/2021/07/28/Markdown%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/"/>
    <url>/jasonyang.github.io/2021/07/28/Markdown%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown简易指南">Markdown简易指南</h1><h2 id="文档标题">文档标题</h2><p>文档的标题级别通过<code>#</code>数量的多少来衡量，<code>#</code>号数量越多则级别越大，但字号越小。最后一个<code>#</code>号和标题文字之间有一个空格，且文档最多支持六级标题，具体示例如下：</p><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><p><img src="1.jpg"></p><h2 id="创建列表">创建列表</h2><h3 id="创建无序列表">创建无序列表</h3><p>在英文输入法下，通过输入<code>-</code>符号创建无序列表。</p><ul><li>无序列表1</li><li>无序列表2</li></ul><h3 id="创建有序列表">创建有序列表</h3><p>在英文输入法下，通过输入<code>1.</code>数字标记创建有序列表</p><ol type="1"><li>有序列表1</li><li>有序列表2</li></ol><p><img src="2.jpg"></p><h3 id="列表嵌套">列表嵌套</h3><p>再完成一种列表的创建之后回车下一行（可能需要删除掉下一行自动添加的同级列表标记），键入<code>Tap</code>创建嵌套列表，嵌套列表的类型由<code>Tap</code>后输入的<code>-</code>或者<code>1.</code>符号决定。</p><ol type="1"><li>有序列表1<ul><li>无序列表1.1</li><li>无序列表1.2</li></ul></li><li>有序列表2<ol type="1"><li>有序列表2.1</li><li>有序列表2.2</li></ol></li></ol><p><img src="3.jpg"></p><h3 id="创建任务清单列表">创建任务清单列表</h3><p>在英文输入法下通过键入<code>- [ ]</code>创建未完成的任务清单；通过键入<code>- [x]</code>创建已完成的任务清单。任务清单同样可以嵌套，方法同样是利用<code>Tap</code>缩进决定嵌套级别，然后通过规定符号标记确定嵌套列表的类型。</p><ul class="task-list"><li><input type="checkbox" disabled="">这是一个未完成的任务：锻炼<ol type="1"><li>手臂肌肉锻炼</li><li>篮球技巧联系</li></ol></li></ul><div>            <input type="checkbox" disabled="" checked="checked">这是一个已完成的任务：刷B站          </div><div>            <input type="checkbox" disabled="" checked="checked">木鱼水心的视频          </div><div>            <input type="checkbox" disabled="" checked="checked">何同学的视频          </div><p><img src="4.jpg"></p><h2 id="创建分割线">创建分割线</h2><p>可以发现在创建文档标题时，一二级标题下面会自动存在分割线，而其他的标题下面没有分割线，而通过三个以上的<code>*</code>或者<code>-</code>符号可以手动创建分割线。</p><hr><hr><p><img src="5.jpg"></p><h2 id="创建表格">创建表格</h2><p>在英文输入法下，通过<code>|</code>和<code>-</code>的组合可以创建表格。</p><table><thead><tr class="header"><th>表头1</th><th>表头2</th><th>表头3</th></tr></thead><tbody><tr class="odd"><td>内容1</td><td>内容2</td><td>内容3</td></tr><tr class="even"><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><table><thead><tr class="header"><th>序号</th><th>标题</th><th>网址</th></tr></thead><tbody><tr class="odd"><td>01</td><td>百度</td><td><a href="https://www.baidu.com" class="uri">https://www.baidu.com</a></td></tr><tr class="even"><td>02</td><td>谷歌</td><td><a href="https://www.google.com" class="uri">https://www.google.com</a></td></tr></tbody></table><p><img src="6.jpg"></p><h3 id="表格的对齐格式">表格的对齐格式</h3><p>通过在<code>----</code>两天添加英文冒号可以指定表格每列的对齐方式，<code>:----</code>、<code>:----:</code>和<code>----:</code>分别表示左对齐、居中对齐和右对齐。</p><table><thead><tr class="header"><th style="text-align: left;">序号（左对齐）</th><th style="text-align: center;">标题（居中对齐）</th><th style="text-align: right;">网址（右对齐）</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">01</td><td style="text-align: center;">百度</td><td style="text-align: right;"><a href="https://www.baidu.com" class="uri">https://www.baidu.com</a></td></tr><tr class="even"><td style="text-align: left;">02</td><td style="text-align: center;">谷歌</td><td style="text-align: right;"><a href="https://www.google.com" class="uri">https://www.google.com</a></td></tr></tbody></table><p><img src="7.jpg"></p><h2 id="插入图片">插入图片</h2><p>通过<code>![图片描述](图片网址)</code>在文档中插入图片，图片网址可以是本地地址也可以是网络图片地址，图片描述可以省略。</p><figure><img src="markdown_logo.png" alt="Markdown Logo"><figcaption aria-hidden="true">Markdown Logo</figcaption></figure><p><img src="8.jpg"></p><h2 id="插入链接">插入链接</h2><p>通过<code>[链接说明](网址链接)</code>在文档中插入网址连接，一般来说链接说明不能省略。</p><p><a href="https://www.baidu.com/">百度</a></p><p><a href="https://www.google.com/">谷歌</a></p><p><a href="https://www.github.com/">GitHub</a></p><p><img src="9.jpg"></p><h3 id="多次引用同一个网址可以为网址指定索引标签">多次引用同一个网址，可以为网址指定索引标签</h3><p>通过<code>[索引标签]:网址连接</code>创建网址的索引标签，然后在使用<code>[链接说明][索引标签]</code>索引网址。</p><p>这里是我们常用的几个网址连接： <a href="https://www.google.com/">谷歌</a> 、<a href="https://www.baidu.com/">百度</a>和 <a href="https://www.github.com/">GitHub</a></p><p><img src="10.jpg"></p><h3 id="插入目录锚点实现文章内部点击跳转">插入目录锚点（实现文章内部点击跳转）</h3><p>通过<code>[目录名称](#索引标签)</code>生成目录锚点，索引标签必须和要跳转的标题章节名称对应（注：该方法只能跳转到文档标题开头处，正文不能跳转）。如果图方便生成文档目录的话可以直接采用<code>[TOC]</code>命令生成当前文档的目录。</p><p>目标检测入门算法：</p><ul><li><a href="#YOLO算法简介">YOLO</a></li><li><a href="#Faster%20R-CNN算法简介">Faster R-CNN</a></li><li><a href="#SSD算法简介">SSD</a></li></ul><h4 id="yolo算法简介">YOLO算法简介</h4><h4 id="faster-r-cnn算法简介">Faster R-CNN算法简介</h4><h4 id="ssd算法简介">SSD算法简介</h4><p><img src="11.jpg"></p><h4 id="快捷生成目录">快捷生成目录</h4><p>[TOC]</p><h2 id="插入代码块">插入代码块</h2><h3 id="插入行内代码">插入行内代码</h3><p>通过使用成对的左上撇号（`）插入行内代码。</p><p>就如<code>train_func</code>所示，巴拉巴拉......</p><h3 id="插入整段代码块">插入整段代码块</h3><p>通过使用成对的三个左上撇号（`）在文档中插入代码块，同时在第一组左上撇号的后面输入代码块使用的脚本语言例如python。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_func</span>()</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-string">'hello, world!'</span></span>)</span><br></code></pre></td></tr></tbody></table></figure><p><img src="12.jpg"></p><h2 id="插入公式">插入公式</h2><p>分数：<span class="math display">\[ f(x,y) = \frac{x^2}{y^3}\]</span></p><p>省略号：<span class="math display">\[ f(x_1, x_2, \ldots, x_n) = x_1+ x_2 + \cdots + x_n \]</span></p><p><img src="13.jpg"></p><h2 id="标记引用段落">标记引用段落</h2><p>某几句话或者一句话需要特别标注是可以采用“引用”样式，使用方法是在需要引用的文字前面添加<code>&gt;</code>符号。</p><blockquote><p>这句话很重要，引用起来。</p></blockquote><h3 id="可以嵌套引用">可以嵌套引用</h3><blockquote><p>这是第一级引用、</p><blockquote><p>这是第二级引用</p><blockquote><p>这是第三级引用</p></blockquote></blockquote></blockquote><p><img src="14.jpg"></p><h2 id="常用标记">常用标记</h2><p>下面介绍正文的一些处理样式包括粗体、斜体、删除线、文本高亮、下划线、上下标等等。</p><p><strong>粗体</strong>、<em>斜体</em>、==高亮==、<del>删除线</del>、<u>下划线</u>、我是<sup>上标</sup>、我是<sub>下标</sub></p><p><img src="15.jpg"></p><h3 id="转义符号">转义符号</h3><p>因为在Markdown中星号、加减号、括号等都有相应的指示作用，因此如果需要展示使用这些符号本身是需要用到转义字符<code>\</code>。</p><p>\ ' * _ {} [] () + . !</p><p><img src="16.jpg"></p><h3 id="插入emoji表情">插入emoji表情</h3><p>插入emoji表情的方法如下，即在成对的<code>:</code>中间填入表情对应的英文名称即可。</p><p><span class="github-emoji"><span>🥶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f976.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🥵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f975.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>更多表情符号请参考这个<a href="https://www.einsition.com/tools/emojicheatsheet">链接</a></p><p><img src="17.jpg"></p><h2 id="高级操作">高级操作</h2><hr><h3 id="导出pdf时指定分页">1. 导出PDF时指定分页</h3><p>插入如下代码块可在导出PDF时指定位置分页：<code>&lt;div STYLE="page-break-after: always;"&gt;&lt;/div&gt;</code></p><h3 id="插入多张图片并插入图注">2. 插入多张图片，并插入图注</h3><center><img style="width: 45%;" src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231914234.png"><img style="width: 45%;" src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231930826.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">图2 【左】无滤波器的输入（黄）与 ap0（蓝）【右】带滤波器的输入（黄）与ap0（蓝）</div></center><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 45%;"</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">"https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231914234.png"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 45%;"</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">"https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231930826.png"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:orange; border-bottom: 1px solid #d9d9d7;</span></span><br><span class="hljs-string"><span class="hljs-tag">    display: inline-block;</span></span><br><span class="hljs-string"><span class="hljs-tag">    color: #999;</span></span><br><span class="hljs-string"><span class="hljs-tag">    padding: 2px;"</span>&gt;</span>图2 【左】无滤波器的输入（黄）与 ap0（蓝）    【右】带滤波器的输入（黄）与ap0（蓝）<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h2 id="注意事项">注意事项</h2><p>通常在正文与列表项、表格项、文档标题之间都需要留有空行。</p><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/jasonyang.github.io/"/>
    <url>/jasonyang.github.io/</url>
    
    <content type="html"><![CDATA[<p>Hello 大家好，我是JasonYang，目前在电子科技大学读研究生，研究方向是模式识别。</p><p>这个博客主要用于记录和积累学习路上的知识、经验，以求形成系统的体系，也便于以后忘记时及时复习巩固。</p><p>有时也会分享一些读书或观影笔记（如果研究生有时间看课外书的话<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），先就这样吧<span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
    
  </entry>
  
  
  
</search>
