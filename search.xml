<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>（转载）Pytorch运行时指定对应序号的显卡</title>
    <link href="/jasonyang.github.io/2022/09/26/Python%E6%8C%87%E5%AE%9A%E5%AF%B9%E5%BA%94%E5%BA%8F%E5%8F%B7%E7%9A%84%E6%98%BE%E5%8D%A1/"/>
    <url>/jasonyang.github.io/2022/09/26/Python%E6%8C%87%E5%AE%9A%E5%AF%B9%E5%BA%94%E5%BA%8F%E5%8F%B7%E7%9A%84%E6%98%BE%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="pytorch运行时指定对应序号的显卡">Pytorch运行时指定对应序号的显卡</h1><p>原文链接：https://zhuanlan.zhihu.com/p/166161217</p><h2 id="在代码中指定">1. 在代码中指定</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os <br>os.environ[<span class="hljs-string">'CUDA_VISIBLE_DEVICES'</span>] = <span class="hljs-string">'2'</span> <br></code></pre></td></tr></tbody></table></figure><h2 id="在命令行中执行代码时指定">2. 在命令行中执行代码时指定</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CUDA_VISIBLE_DEVICES='2' python3 train.py<br></code></pre></td></tr></tbody></table></figure><h2 id="在命令行中执行脚本文件时指定">3.在命令行中执行脚本文件时指定</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CUDA_VISIBLE_DEVICES='2' sh run.sh<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>（转载）详解IoU、GIoU、DIoU、CIoU、EIoU和DIoU-NMS</title>
    <link href="/jasonyang.github.io/2022/09/20/%E8%AF%A6%E8%A7%A3IoU%E3%80%81GIoU%E3%80%81DIoU%E3%80%81CIoU%E3%80%81EIoU%E5%92%8CDIoU-NMS/"/>
    <url>/jasonyang.github.io/2022/09/20/%E8%AF%A6%E8%A7%A3IoU%E3%80%81GIoU%E3%80%81DIoU%E3%80%81CIoU%E3%80%81EIoU%E5%92%8CDIoU-NMS/</url>
    
    <content type="html"><![CDATA[<h1 id="详解iougioudioucioueiou和diou-nms">详解IoU、GIoU、DIoU、CIoU、EIoU和DIoU-NMS</h1><p>原文链接：https://aitechtogether.com/article/18153.html</p><p><strong>考虑的回归框的特性</strong></p><ul><li>IOU Loss：考虑了重叠面积，归一化坐标尺度；</li><li>GIOULoss：考虑了重叠面积，基于IOU解决边界框不相交时loss等于0的问题；</li><li>DIOULoss：考虑了重叠面积和中心点距离，基于IOU解决GIOU收敛慢的问题；</li><li>CIOULoss：考虑了重叠面积、中心点距离、纵横比，基于DIOU提升回归精确度；</li><li>EIOULoss：考虑了重叠面积，中心点距离、长宽边长真实差，基于CIOU解决了纵横比的模糊定义，并添加FocalLoss解决BBox回归中的样本不平衡问题。</li></ul><p><strong>对比简表</strong></p><table><colgroup><col style="width: 2%"><col style="width: 19%"><col style="width: 19%"><col style="width: 19%"><col style="width: 19%"><col style="width: 19%"></colgroup><thead><tr class="header"><th>IOU Loss</th><th>GIOU Loss</th><th>DIOU Loss</th><th>CIOU Loss</th><th>EIOU Loss</th><th></th></tr></thead><tbody><tr class="odd"><td>优点</td><td>IOU算法是目标检测中最常用的指标，具有尺度不变性，满足非负性；同一性；对称性；三角不等性等特点。</td><td>GIOU在基于IOU特性的基础上引入最小外接框解决检测框和真实框没有重叠时loss等于0问题。</td><td>DIOU在基于IOU特性的基础上考虑到GIOU的缺点，直接回归两个框中心点的欧式距离，加速收敛。</td><td>CIOU就是在DIOU的基础上增加了检测框尺度的loss，增加了长和宽的loss，这样预测框就会更加的符合真实框。</td><td>EIOU在CIOU的基础上分别计算宽高的差异值取代了纵横比，同时引入FocalLoss解决难易样本不平衡的问题。</td></tr><tr class="even"><td>缺点</td><td>1.如果两个框不相交，不能反映两个框距离远近2.无法精确的反映两个框的重合度大小</td><td>1.当检测框和真实框出现包含现象的时候GIOU退化成IOU2.两个框相交时，在水平和垂直方向上收敛慢</td><td>回归过程中未考虑Boundingbox的纵横比，精确度上尚有进一步提升的空间</td><td>1. 纵横比描述的是相对值，存在一定的模糊 2.未考虑难易样本的平衡问题</td><td>待定</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IoU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文总结-基于Transformer的MOT系列论文</title>
    <link href="/jasonyang.github.io/2022/09/17/%E5%9F%BA%E4%BA%8ETransformer%E7%9A%84%E7%B3%BB%E5%88%97MOT/"/>
    <url>/jasonyang.github.io/2022/09/17/%E5%9F%BA%E4%BA%8ETransformer%E7%9A%84%E7%B3%BB%E5%88%97MOT/</url>
    
    <content type="html"><![CDATA[<h1 id="基于Transformer的MOT系列论文"><a href="#基于Transformer的MOT系列论文" class="headerlink" title="基于Transformer的MOT系列论文"></a>基于Transformer的MOT系列论文</h1><h2 id="1-Unified-Transformer-Tracker-for-Object-Tracking-CVPR-2022"><a href="#1-Unified-Transformer-Tracker-for-Object-Tracking-CVPR-2022" class="headerlink" title="1. Unified Transformer Tracker for Object Tracking (CVPR 2022)"></a>1. Unified Transformer Tracker for Object Tracking (CVPR 2022)</h2><p><span class="github-emoji"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>作者：</strong> <img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220831100309975.png" alt="image-20220831100309975"></p><p><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> arXiv: <a href="https://arxiv.org/abs/2203.15175">https://arxiv.org/abs/2203.15175</a> </p><h3 id="1-1-摘要"><a href="#1-1-摘要" class="headerlink" title="1.1 摘要"></a>1.1 摘要</h3><p>作为计算机视觉中的一个重要领域，目标跟踪已经形成了两个独立的社区，分别研究单目标跟踪（SOT）和多目标跟踪（MOT）。 然而，由于两个任务的训练数据集和跟踪对象不同，当前一种跟踪场景中的方法不容易适应另一种。 尽管 UniTrack [45] 证明了具有多个头部的共享外观模型可用于处理单个跟踪任务，但它未能利用大规模跟踪数据集进行训练，并且在单个对象跟踪上表现不佳。 在这项工作中，我们提出了统一transformer跟踪器 (Unified Transformer Tracker)，以使用一种范式解决不同场景中的跟踪问题。 在我们的 UTT 中开发了一个跟踪转换器（track transformer）来跟踪 SOT 和 MOT 中的目标，其中利用目标特征和跟踪框架特征之间的相关性来定位目标。 我们证明了 SOT 和 MOT 任务都可以在这个框架内解决，并且可以通过交替优化单个任务数据集上的 SOT 和 MOT 目标来同时对模型进行端到端训练。 在 SOT 和 MOT 数据集上训练的统一模型在多个基准上进行了广泛的实验。</p><h3 id="1-2-方法与总结"><a href="#1-2-方法与总结" class="headerlink" title="1.2 方法与总结"></a>1.2 方法与总结</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220831102300539.png" alt="image-20220831102300539"></p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>前向传播流程：</strong></p><p>给定参考帧图像和目标的bbox（对应SOT参考帧为第1帧，MOT参考帧为当前帧的前一帧），首先经过一个共享权重的特征提取网络，得到参考帧和当前帧的特征图$\mathbf{R, S<em>t}$。然后在参考帧特征图的目标所在区域进行ROI 1x1 池化,的到目标向量当做Query, $Q=F</em>{origin} \in \mathbb{R}^{N \times C}$, $N$为待跟踪目标数，$C$为特征嵌入的维度。同时当前帧展平后的特征图（$HW$个特征向量）作为Key和Value，进行Transformer交叉注意力的运算，得到融合空间信息（本身的Query可理解为提取了目标的外观特征）的目标特征嵌入$F<em>o$。之后增强后的目标特征嵌入$F_o$与当前帧的特征进行相关注意力的计算并根据相关注意力的相应度提取候选区域$S</em>{RoI}^{t}$。最后嵌入特征再经过L层自注意力融合，然后再与候选区域$S_{RoI}^{t}$计算相关注意力，最后增强后的特征$F’_o$送入bbox 回归head得到跟踪结果。PS：这里的L层注意力都会输出一次bbox的预测结果，当前层的预测结果为后面层提供候选区域。</p><p><span class="github-emoji"><span>🍂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f342.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>总结：</strong></p><p>这篇论文将Siamese + Transformer结构较好的结合了起来，通过给定参考帧特征和bbox位置，提取待跟踪目标特征嵌入，之后结合当前帧特征图，融合目标上下文信息。之后增强后的特征嵌入与当前帧特征进行相关滤波提取目标潜在候选区域，减少了后续Transformer交叉注意力（文中为进一步减少计算量，改进为相关注意力）的计算量。最后多层级精细化预测的bbox预测方法，也能较好修正预测结果，每层都有相应的监督信息，模型更好收敛。</p><p>不足的是，这篇论文提出的融合SOT和MOT，但是其在跟踪多个目标时，无法独立解决新目标出现的问题，还需融入一个目标检测模块去更新新出现的目标，造成较大的时延。</p><h2 id="2-MeMOT-Multi-Object-Tracking-with-Memory（CVPR-2022-Oral）"><a href="#2-MeMOT-Multi-Object-Tracking-with-Memory（CVPR-2022-Oral）" class="headerlink" title="2. MeMOT: Multi-Object Tracking with Memory（CVPR 2022 Oral）"></a>2. MeMOT: Multi-Object Tracking with Memory（CVPR 2022 Oral）</h2><p><span class="github-emoji"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>作者：</strong> </p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220831162305234.png" alt="image-20220831162305234"></p><p><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> arXiv: <a href="https://arxiv.org/abs/2203.16761">https://arxiv.org/abs/2203.16761</a></p><h3 id="2-1-摘要"><a href="#2-1-摘要" class="headerlink" title="2.1 摘要"></a>2.1 摘要</h3><p>我们提出了一种在线跟踪算法，该算法在一个通用框架下执行<strong>目标检测和数据关联</strong>，能够在很长一段时间后关联目标。 这是通过保留一个大的时空内存来存储被跟踪目标的身份嵌入，并根据需要自适应地引用和聚合来自内存的有用信息来实现的。 我们的模型称为 MeMOT，由三个主要模块组成，它们都是基于 Transformer 的：1）Hypothesis Generation，在当前视频帧中生成目标提议； 2) Memory Encoding，从内存中提取每个被跟踪目标的核心（主要是外观）信息； 3) Memory Decoding，同时解决多目标跟踪的目标检测和数据关联任务。 在广泛采用的 MOT 基准数据集上进行评估时， 观察到MeMOT达到具有竞争力的跟踪性能。</p><h3 id="2-2-方法与总结"><a href="#2-2-方法与总结" class="headerlink" title="2.2 方法与总结"></a>2.2 方法与总结</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220831162857555.png" alt="image-20220831162857555"></p><p><span class="github-emoji"><span>🍂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f342.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>总结：</strong></p><p>论文的亮点在于在一个模型框架实现了目标检测与数据关联（跟踪），而不需要额外的匈牙利匹配算法，且能够完成长时丢失目标找回。具体实现是在跟踪过程中维持一个较大的目标外观特征嵌入表（300 x 24, 主要就是外观特征吧，虽然有Transformer的位置编码，但是还是缺少显式的目标前帧位置信息，或许可以再添加一个buffer？）,各自目标的嵌入表进行长短期嵌入的特征聚合（交叉注意力+自注意力，具体看论文Fig 3），以此得到待跟踪目标的特征嵌入并作为跟踪查询$Q<em>{trk}$，同时基于Transformer检测器的范式，也会在当前帧生成检测查询$Q</em>{det}$，之后这两个查询concat起来以当前帧的编码后特征$E^t$作为K，V进行解码，最后查询特征在经过一个预测头得到各自查询条目（对应检测目标or跟踪目标）的可见度，唯一性以及bbox。后续匹配就是根据可见度和唯一性的乘积大小阈值化处理，不存在检测与跟踪双端匹配的问题。</p><p>PS：模型唯一性输出大小影响着最后跟踪的性能，论文中查询条目唯一性是指这个是否是新目标的概率，在设置唯一性标签时，跟踪查询$Q<em>{trk}$中条目的唯一性为1、检测查询$Q</em>{det}$中条目只有之前未被跟踪时（新进入场景的目标）其唯一性标签才为1。然后当条目分配到背景时（基于Transformer的目标检测都有一个双端匹配，看条目是匹配到目标还是背景），其唯一性标签为1，但是可见度标签为0。</p><p>所思，感觉这种基于Transformer进行目标特征（外观或者位置）聚合的方式获取特征向量进行跟踪目标的找回特别适合soccerNet和DanceTrack这种人物进入和离开场景较少的数据集，感觉可以尝试发力。</p><h2 id="3-TransTrack-Multiple-Object-Tracking-with-Transformer"><a href="#3-TransTrack-Multiple-Object-Tracking-with-Transformer" class="headerlink" title="3. TransTrack: Multiple Object Tracking with Transformer"></a>3. TransTrack: Multiple Object Tracking with Transformer</h2><p><span class="github-emoji"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>作者：</strong> </p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220831215354450.png" alt="image-20220831215354450"></p><p><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> arXiv: <a href="https://arxiv.org/abs/2012.15460">https://arxiv.org/abs/2012.15460</a></p><p><span class="github-emoji"><span>🍃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f343.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> github: https: //github.com/PeizeSun/TransTrack</p><h3 id="3-1-摘要"><a href="#3-1-摘要" class="headerlink" title="3.1 摘要"></a>3.1 摘要</h3><p>在这篇工作中，我们提出了 TransTrack，这是一个简单有效解决多目标跟踪问题的方案。 TransTrack 利用了Transformer架构，这是一种基于注意力的查询键机制（Query-Key）。 它应用前一帧的目标特征作为当前帧的查询，并引入一组可学习的目标查询（learnable object query）以检测新来的目标。 它通过一次前向传播完成目标检测和目标关联，建立了一种新颖的联合检测和跟踪范式，简化了检测跟踪方法中复杂的多步骤设置。 在 MOT17 和 MOT20 基准上，TransTrack 分别实现了 74.5% 和 64.5% 的 MOTA，达到了与SOTA可竞争的性能。 我们希望 TransTrack 能够为多目标跟踪提供一个新颖的视角。 本篇工作的代码位于：<a href="https://github.com/PeizeSun/TransTrack。">https://github.com/PeizeSun/TransTrack。</a></p><h3 id="3-2-方法与总结"><a href="#3-2-方法与总结" class="headerlink" title="3.2 方法与总结"></a>3.2 方法与总结</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220831221548727.png" alt="image-20220831221548727"></p><p><span class="github-emoji"><span>🍂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f342.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>总结：</strong></p><p>这篇工作应该是最早将Transformer引入MOT领域的吧，实现思路也比较简单直接，就是使用两组query，一组检测query（来自于可学习的一组参数，依照DETR设定），另一组跟踪query（来自于之前检测query并经过了交叉注意力加权）。然后分别得到检测框、跟踪框，最后再对两组框进行匹配，达到滤除重复框的作用。这样来看上面两篇工作都是对其的改进，第一篇Unified tracking改进了搜索特征精细化提取的方式（不用在整张图上进行查询），并精简化了交叉注意力机制，改为了相关注意力；第二篇则是主要聚焦于如何得到鲁棒的轨迹（以及跟踪上的目标一般叫做轨迹）特征，以此设计了一个buffer去聚合轨迹长时间的特征，以期实现鲁棒跟踪。</p><p>比较喜欢其中一句话：将检测器编程跟踪器只需要加运动模型（KF）或者夹外观模型（ReID）（Two commonly used signals to upgrade a detector to a tracker are motion and appearance features.）</p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> 论文还顺带证明了几个观点：</p><ul><li>大训练数据集对模型效果提升显著，同时混合大数据集进行微调，比单独微调效果要好；</li><li>直接适用FPN的特征，比用ResNet + 普通Transformer Encoder之后特征要好不少，但是比不上Deformable Encoder之后的特征；</li></ul><p>有一点不是很明白，就是文章为什么没有将后续的两个单独但是相同结构的解码器合并成一个呢？把两组query 拼接起来送入一个解码器也可以目标检测与匹配呀？文章最后也没有进行消融实验或是说明原因。</p><blockquote><p>刚发现原因，因为在文章中object query 和 track query 需要单独自注意力编码，如果合在一起就容易两者特征融合在一起了（但是貌似用mask也能实现特征屏蔽呀。）</p></blockquote><h2 id="4-TransCenter-Transformers-with-Dense-Representations-for-Multiple-Object-Tracking"><a href="#4-TransCenter-Transformers-with-Dense-Representations-for-Multiple-Object-Tracking" class="headerlink" title="4. TransCenter: Transformers with Dense Representations for Multiple-Object Tracking"></a>4. TransCenter: Transformers with Dense Representations for Multiple-Object Tracking</h2><p><span class="github-emoji"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>作者：</strong> </p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220907142132229.png" alt="image-20220907142132229"></h2><p><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> arXiv: <a href="https://arxiv.org/abs/2103.15145">https://arxiv.org/abs/2103.15145</a></p><h3 id="4-1-摘要"><a href="#4-1-摘要" class="headerlink" title="4.1 摘要"></a>4.1 摘要</h3><p>自推出以来，Transformer 已在各种任务中证明了卓越的性能，近年来引起了视觉界的关注，在这些领域进行了图像分类和目标检测等工作。尽管有这一波浪潮，但使用 Transformer 构建准确高效的多目标跟踪 (MOT) 方法并非易事。我们认为，直接应用具有二次复杂性和噪声初始化稀疏查询不足的（基础）Transformer架构对于 MOT 来说不是最优的。受最近研究的启发，我们提出了 TransCenter，这是一种基于Transformer的 MOT 架构，具有密集表示，用于准确跟踪所有目标，同时保持合理的运行时间。在方法论上，我们建议使用由高效Transformer（PVT）架构产生的密集图像相关的多尺度检测查询。查询允许从密集的热图输出中全局且稳健地推断目标的位置。同时，一组高效的稀疏跟踪查询与 TransCenter 解码器中的图像特征交互，以随时间关联对象位置。 TransCenter 在具有两个跟踪（公共/私有）设置的两个标准 MOT 基准测试中表现出显着的性能改进并大大优于当前最先进的基准。所提出的用于 MOT 的高效且准确的变压器架构已通过广泛的消融研究得到证明，与更幼稚的替代方案和并行工作相比，证明了它的优势。代码将在 <a href="https://github.com/yihongxu/transcenter">https://github.com/yihongxu/transcenter</a> 上公开（只有一个README）。</p><h3 id="4-2-方法与总结"><a href="#4-2-方法与总结" class="headerlink" title="4.2 方法与总结"></a>4.2 方法与总结</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220907144056412.png" alt="image-20220907144056412"></p><p><span class="github-emoji"><span>🍂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f342.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>总结：</strong></p><p>我感觉这篇文章的两点在于描述了如何在Transformer中融入多尺度检测，至于提出的将原始DETR系列延续下来的可学习的检测查询（learnable detection query）替换成所谓“密集表示的detection query”其本质就是特征图经过连接层之后的特征表示，况且为了算法性能与效率的平衡也舍弃了查询与键值的交互，遂感觉这个密集查询有点儿“不正规”。在“检测密集查询”的多尺度特征融合方面采用上采样、拼接、卷积的模式，然后基于此预测Heatmaps和宽高；跟踪查询是常规的Transformer范式：前一帧特征嵌入与当前帧特征图交互，然后FFN预测输出，不过本篇文章回归的是待跟踪目标的中心坐标偏置，而不是单独的bbox。最后论文的方法比较和消融实验做得特别详细，不同训练数据集、私有还是公共检测器以及各种模块组合搭配的消融实验都有。</p><p><span class="github-emoji"><span>⚡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/26a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>有用的观点：</p><ul><li>之前使用ResNet50提取初级特征，然后在融合Transformer Encoder的方式并没有直接使用图像Patch进行编码的PVT系列提取的特征有效，且前者更耗时。</li></ul><h2 id="5-TransMOT-Spatial-Temporal-Graph-Transformer-for-Multiple-Object-Tracking"><a href="#5-TransMOT-Spatial-Temporal-Graph-Transformer-for-Multiple-Object-Tracking" class="headerlink" title="5.TransMOT: Spatial-Temporal Graph Transformer for Multiple Object Tracking"></a>5.TransMOT: Spatial-Temporal Graph Transformer for Multiple Object Tracking</h2><p><span class="github-emoji"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>作者：</strong> </p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220911093629577.png" alt="image-20220911093629577"></p><p><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> arXiv: <a href="https://arxiv.org/abs/2104.00194">https://arxiv.org/abs/2104.00194</a></p><h3 id="5-1-摘要"><a href="#5-1-摘要" class="headerlink" title="5.1 摘要"></a>5.1 摘要</h3><p>跟踪视频中的多个目标依赖于对目标的时空交互进行建模（文章聚焦于轨迹和检测之间的亲和度矩阵）。在本文中，我们提出了一种名为 TransMOT 的解决方案，它利用强大的基于图的Transformer来有效地模拟目标之间的空间和时间交互。 TransMOT 通过将跟踪目标的轨迹安排为一组稀疏加权图，并构建空间图transformer编码器层、时间transformer编码器层和空间图transformer解码器层，从而有效地对大量物体的交互进行建模。在图表上。 TransMOT 不仅比传统的 Transformer 计算效率更高，而且还实现了更好的跟踪精度。为了进一步提高跟踪速度和准确性，我们提出了一个级联关联框架来处理需要大量计算资源在 TransMOT 中建模的低分检测和长期遮挡。所提出的方法在包括 MOT15、MOT16、MOT17 和 MOT20 在内的多个基准数据集上进行了评估，并在所有数据集上实现了最先进的性能。</p><h3 id="5-2-方法与总结"><a href="#5-2-方法与总结" class="headerlink" title="5.2 方法与总结"></a>5.2 方法与总结</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220911094721534.png" alt="image-20220911094721534"></p><p><span class="github-emoji"><span>🍂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f342.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>总结：</strong></p><p>文章依据之前多帧的轨迹信息，构建了多个以边界框IoU为邻接关系和邻接权重，以嵌入后的外观特征（+位置特征，这里不清楚加没加位置特征）为节点特征的图结构。然后基于这些关系图，在单帧维度上聚合轨迹的空间信息，在单个轨迹（T帧）维度上聚合轨迹的时间线索。对于当前帧检测候选目标，仍构建关系图，聚合空间线索。然后编码后的检测候选目标特征复制N份（N为之前带匹配的轨迹个数），用作“Query”查询，与编码后轨迹特征计算交叉注意力，最后得到MxN的关联矩阵。此外为了应对轨迹消失或者新轨迹生成，文章还在之前多帧和当前帧各添加了一个虚拟节点，当前帧的虚拟节点可连接多个之前轨迹节点，表示轨迹消失（或被遮挡）；之前帧的虚拟节点，也可以连接多个当前帧检测节点，表示新轨迹生成。最后文章还提出了级联匹配的策略，用KF加IoU匹配滤除掉置信度的框，以缓解transformer计算过大的问题；同时结合轨迹最后出现的位置和外观特征，利用所提的正则化的顶距离和欧拉距离处理长时遮挡。</p><p>这篇文章主要工作在于利用transformer和图结构的时空建模能力去构建轨迹与检测的亲和度矩阵，利用IoU构建邻接网络的思路值得借鉴，能够较好的减少自注意力机制的计算量。最后的疑惑是文章在节点特征的选取以及某些轨迹在之前的某一帧缺失时如何补偿的问题没有详细说明。</p><h2 id="6-TrackFormer-Multi-Object-Tracking-with-Transformers"><a href="#6-TrackFormer-Multi-Object-Tracking-with-Transformers" class="headerlink" title="6. TrackFormer: Multi-Object Tracking with Transformers"></a>6. TrackFormer: Multi-Object Tracking with Transformers</h2><p><span class="github-emoji"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>作者：</strong> </p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220914195000699.png" alt="image-20220914195000699"></p><p><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> arXiv:<a href="https://arxiv.org/abs/2101.02702">https://arxiv.org/abs/2101.02702</a></p><p><span class="github-emoji"><span>🍃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f343.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> github: <a href="https://github.com/timmeinhardt/trackformer">https://github.com/timmeinhardt/trackformer</a></p><h3 id="6-1-摘要"><a href="#6-1-摘要" class="headerlink" title="6.1  摘要"></a>6.1  摘要</h3><p>多目标跟踪 (MOT) 任务的挑战性在于需要同时完成跟踪初始化、身份匹配和时空轨迹关联。我们将此任务表述为帧到帧集合预测（set prediction）问题，并引入 TrackFormer，这是一种基于编码器-解码器 Transformer 架构的可端到端训练 MOT 方法。我们的模型通过基于视频序列的集合轨迹预测的注意力实现帧间数据关联。 Transformer 解码器从静态目标查询（object query）初始化新轨道，提出一个新的带有目标身份信息的“轨迹查询（track query ）”用于在空间和时间上自回归地跟踪已有轨迹。这两种查询类型都受益于自注意力和编码器-解码器（交叉注意力）对全局帧级特征的交互，从而省去了任何额外的图优化、运动或外观建模。 TrackFormer 引入了一种新的注意力跟踪范式，虽然其设计简单，但能够在多目标跟踪（MOT17 和 MOT20）和分割（MOTS20）任务上实现最先进的性能。该代码可在 <a href="https://github.com/timmeinhardt/trackformer">https://github.com/timmeinhardt/trackformer</a> 获取。</p><h3 id="6-2-方法与总结"><a href="#6-2-方法与总结" class="headerlink" title="6.2 方法与总结"></a>6.2 方法与总结</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220914203831332.png" alt="image-20220914203831332"></p><p><span class="github-emoji"><span>🍂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f342.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>总结：</strong></p><p>我感觉这篇文章读起来好拗口呀，以为它是第一篇基于transformer的MOT，但是从arXiv上面的时间来看也没有Transtrack这篇文章出来的早（20年12月和21年1月），不过也算同时期的工作吧。文章的主要做法也是和TransTrack相似的：在传统DETR检测器的“object query”的基础上增加了“track query”（这个query来自上一帧经过交叉注意力交互之后的object query），同样对所有query进行解码，然后回归每个查询对应的bbox和class。两者的不同在于，transtrack对两种不同的query单独解码预测回归，而本篇文章会将两种类型的query拼接起来，进行自注意力交互。因此在transtrack中主要是想通过更多的query来实现跟踪的查全率，而这篇文章则更想明确两种不同query的分工，object query只用负责检测新出现的目标就好了，跟踪的任务交给track query,所以本篇文章在GT框分配时，优先分配（目前在当前帧仍存在）给track query预测的bbox。这个应该就是两篇文章思路上的不同了。</p><p>最后就是文章使用的三种数据增强感觉挺有帮助的：</p><ul><li>不顺序采用邻近两帧图像进行训练，而是随机从前后邻近帧中选择两个图像组成训练对；</li><li>为每次随机屏蔽一些track query（来自前一帧的前景objecy query）,这个操作可以减少对track query的依赖，从而保证检测和跟踪的平衡性。</li><li>每次从预测为背景的object query中选择一些加入track query，用于改善模型在面对目标被遮挡时的轨迹误删除。</li></ul><h2 id="7-MOTR-End-to-End-Multiple-Object-Tracking-with-Transformer"><a href="#7-MOTR-End-to-End-Multiple-Object-Tracking-with-Transformer" class="headerlink" title="7. MOTR: End-to-End Multiple-Object Tracking with Transformer"></a>7. MOTR: End-to-End Multiple-Object Tracking with Transformer</h2><p><span class="github-emoji"><span>🐋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f40b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <strong>作者：</strong> </p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220916200914128.png" alt="image-20220916200914128"></p><p><span class="github-emoji"><span>🌐</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f310.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> arXiv:<a href="https://arxiv.org/abs/2105.03247">https://arxiv.org/abs/2105.03247</a></p><p><span class="github-emoji"><span>🍃</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f343.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> github: <a href="https://github.com/megvii-research/MOTR">https://github.com/megvii-research/MOTR</a></p><h3 id="7-1-摘要"><a href="#7-1-摘要" class="headerlink" title="7.1 摘要"></a>7.1 摘要</h3><p>目标的时间建模是多目标跟踪 (MOT) 中的一个关键挑战。现有方法通过基于运动和基于外观相似性的启发式的关联检测来进行跟踪。关联的后处理特性阻止了对视频序列中时间变化的端到端利用。在本文中，我们提出了 MOTR，它扩展了 DETR [6]，并引入了“跟踪查询”（track query）来对整个视频中的跟踪实例进行建模。跟踪查询被逐帧传输和更新，以随着时间的推移执行迭代预测。我们建议使用 tracklet 感知标签（tracklet-aware label assignment）分配来训练跟踪查询(track query)和新生目标查询（object query）。我们进一步提出时间聚合网络（temporal aggregation networkl）和集体平均损失（collective average loss）来增强时间关系建模。 DanceTrack 上的实验结果表明，MOTR 在 HOTA 指标上显着优于最先进的方法 ByteTrack [42] 6.5%。在 MOT17 上，MOTR 在关联性能方面优于我们的同期工作 TrackFormer [18] 和 TransTrack [29]。 MOTR 可以作为未来时间建模和基于 Transformer 的跟踪器研究的更强大的基线。代码可在 <a href="https://github.com/megvii-research/MOTR">https://github.com/megvii-research/MOTR</a> 获得。</p><h3 id="7-2-方法与总结"><a href="#7-2-方法与总结" class="headerlink" title="7.2 方法与总结"></a>7.2 方法与总结</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220916202136510.png" alt="image-20220916202136510"></p><p><span class="github-emoji"><span>🍂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f342.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><strong>总结：</strong></p><p>这篇文章主要看重于目标跟踪的时序建模，也算是第一个将track query和object query 明确分工的工作。track query 负责从始至终预测前一帧的轨迹；object query 则只负责预测每帧相对于前帧新出现的目标（具体GT分配上就只给object query分配每帧新出现的带有新id的Bbox）。这样的一种指定方式能够保证其在DanceTrack这种人员基本不退出也不进入场景的目标带来极大的好处，只用管好之前帧的目标当前在哪儿就行。track query 同样是从前一帧的object query中传播过来，但还增加了一个时间特征聚合模块（就是将不同帧同id的目标的特征表示self-attention聚合一下，然后再用作track query）。因为取消了轨迹关联这一步，MOTR需要每次依据query预测的置信度分数进行目标的初始化和删除，此外在模型训练作者也使用了类似于TrackFormer的真轨迹删除和假轨迹添加的情况，增强模型的稳定性。</p><blockquote><p>不过最后作者也提到这种明确query分工的模式，与object query检测前景的设计初衷是相违背的，所以本文方法在MOTA指标上并不高，object query 被track query 抑制了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>Transformer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>（转载）在Windows中安装Cython-bbox</title>
    <link href="/jasonyang.github.io/2022/09/13/%E5%9C%A8Windows%E4%B8%AD%E5%AE%89%E8%A3%85Cython-bbox/"/>
    <url>/jasonyang.github.io/2022/09/13/%E5%9C%A8Windows%E4%B8%AD%E5%AE%89%E8%A3%85Cython-bbox/</url>
    
    <content type="html"><![CDATA[<h1 id="在windows中安装cython-bbox">在Windows中安装Cython-bbox</h1><p>转载自：https://www.jianshu.com/p/2ab8d6493cc6</p><p>用文中的方法2安装成功，在此备份一下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python -m pip install git+https://github.com/yanfengliu/cython_bbox.git<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>Cython-bbox</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python常用工具函数汇总</title>
    <link href="/jasonyang.github.io/2022/07/23/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/"/>
    <url>/jasonyang.github.io/2022/07/23/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="常用工具函数汇总">常用工具函数汇总</h1><p>[TOC]</p><hr><h2 id="绘制矩形框">绘制矩形框</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -------------------------------- #</span><br><span class="hljs-comment"># 绘制矩形框</span><br><span class="hljs-comment"># -------------------------------- #</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drawn_rectangle</span>(<span class="hljs-params">img_path, bboxs, map_bboxs</span>):</span><br>    <span class="hljs-comment"># bboxs = [x1, y1, x2, y2]</span><br><br>    save_path = <span class="hljs-string">'/home/hjy/DeepLearning/OC_SORT/YOLOX_outputs/dance_val_eval/vis_embedding/'</span><br>    img_path = <span class="hljs-string">'/data/hjy/Datasets/DanceTrack/images/val/'</span> + img_path[<span class="hljs-number">0</span>]<br>    img0 = cv2.imread(img_path)<br><br>    <span class="hljs-comment"># 绘制GT</span><br>    bboxs = np.array(bboxs, dtype=np.int32)<br>    <span class="hljs-keyword">for</span> bbox <span class="hljs-keyword">in</span> bboxs:<br>        xy1 = (bbox[<span class="hljs-number">0</span>], bbox[<span class="hljs-number">1</span>])<br>        xy2 = (bbox[<span class="hljs-number">2</span>], bbox[<span class="hljs-number">3</span>])<br>        cv2.rectangle(img0, xy1, xy2, (<span class="hljs-number">50</span>,<span class="hljs-number">205</span>,<span class="hljs-number">50</span>), thickness=<span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 绘制映射后的bbox</span><br>    <span class="hljs-keyword">for</span> bbox <span class="hljs-keyword">in</span> map_bboxs:<br>        xy1 = (bbox[<span class="hljs-number">0</span>], bbox[<span class="hljs-number">1</span>])<br>        xy2 = (bbox[<span class="hljs-number">2</span>], bbox[<span class="hljs-number">3</span>])<br>        cv2.rectangle(img0, xy1, xy2, (<span class="hljs-number">0</span>,<span class="hljs-number">191</span>,<span class="hljs-number">255</span>), thickness=<span class="hljs-number">2</span>)<br>    save_path = save_path + img_path.split(<span class="hljs-string">'/'</span>)[-<span class="hljs-number">1</span>]<br>    cv2.imwrite(save_path, img0)<br>    <span class="hljs-built_in">print</span>(save_path)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'writting .......'</span>)<br></code></pre></td></tr></tbody></table></figure><h2 id="可视化heatmap">可视化Heatmap</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">vis_heatmap</span>(<span class="hljs-params">heatmaps</span>):</span><br>    <span class="hljs-keyword">for</span> ii, heatmap <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(heatmaps):<br>        heatmap = heatmap.cpu().numpy()<br>        plt.imshow(heatmap, cmap=plt.cm.jet)<br>        plt.show()<br></code></pre></td></tr></tbody></table></figure><h2 id="相关滤波">相关滤波</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br>    res = []<br>    <span class="hljs-keyword">for</span> ii <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(c_x)):<br>        out = F.conv2d(id_features, f).view(<span class="hljs-number">152</span>, <span class="hljs-number">272</span>)<br>        res.append(out)<br></code></pre></td></tr></tbody></table></figure><h2 id="边框等比缩放并填充">边框等比缩放并填充</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">letterbox</span>(<span class="hljs-params">img, height=<span class="hljs-number">608</span>, width=<span class="hljs-number">1088</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">              color=(<span class="hljs-params"><span class="hljs-number">127.5</span>, <span class="hljs-number">127.5</span>, <span class="hljs-number">127.5</span></span>)</span>):</span>  <span class="hljs-comment"># resize a rectangular image to a padded rectangular</span><br>    shape = img.shape[:<span class="hljs-number">2</span>]  <span class="hljs-comment"># shape = [height, width]</span><br>    ratio = <span class="hljs-built_in">min</span>(<span class="hljs-built_in">float</span>(height) / shape[<span class="hljs-number">0</span>], <span class="hljs-built_in">float</span>(width) / shape[<span class="hljs-number">1</span>])<br>    new_shape = (<span class="hljs-built_in">round</span>(shape[<span class="hljs-number">1</span>] * ratio), <span class="hljs-built_in">round</span>(shape[<span class="hljs-number">0</span>] * ratio))  <span class="hljs-comment"># new_shape = [width, height]</span><br>    <span class="hljs-built_in">print</span>(new_shape)<br>    dw = (width - new_shape[<span class="hljs-number">0</span>]) / <span class="hljs-number">2</span>  <span class="hljs-comment"># width padding</span><br>    dh = (height - new_shape[<span class="hljs-number">1</span>]) / <span class="hljs-number">2</span>  <span class="hljs-comment"># height padding</span><br>    top, bottom = <span class="hljs-built_in">round</span>(dh - <span class="hljs-number">0.1</span>), <span class="hljs-built_in">round</span>(dh + <span class="hljs-number">0.1</span>)<br>    left, right = <span class="hljs-built_in">round</span>(dw - <span class="hljs-number">0.1</span>), <span class="hljs-built_in">round</span>(dw + <span class="hljs-number">0.1</span>)<br><br>    img = cv2.resize(img, new_shape, interpolation=cv2.INTER_AREA)  <span class="hljs-comment"># resized, no border</span><br>    img = cv2.copyMakeBorder(img, top, bottom, left, right, cv2.BORDER_CONSTANT, value=color)  <span class="hljs-comment"># padded rectangular</span><br>    <span class="hljs-keyword">return</span> img, ratio, dw, dh<br></code></pre></td></tr></tbody></table></figure><h2 id="opencv读取显示视频">OpenCV读取显示视频</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check_video</span>():</span><br><br>    cap = cv2.VideoCapture(<span class="hljs-string">'videos/test_dance.avi'</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">'video W:{}, video H:{}, video fps:{}, video count:{}'</span>.<span class="hljs-built_in">format</span>(<br>        cap.get(cv2.CAP_PROP_FRAME_WIDTH),<br>        cap.get(cv2.CAP_PROP_FRAME_HEIGHT),<br>        cap.get(cv2.CAP_PROP_FPS),<br>        cap.get(cv2.CAP_PROP_FRAME_COUNT)<br><br>    ))<br>    <span class="hljs-keyword">while</span>(cap.isOpened()):<br>        ret, frame = cap.read()<br>        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br><br>        cv2.imshow(<span class="hljs-string">'frame'</span>,gray)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">1</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-built_in">ord</span>(<span class="hljs-string">'q'</span>):<br>            <span class="hljs-keyword">break</span><br><br>    cap.release()<br>    cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure><h2 id="opencv图片生成视频">OpenCV图片生成视频</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">visualization_one_test_video</span>():</span><br>    PATH = <span class="hljs-string">'/data/hjy/Datasets/DanceTrack/train2/dancetrack0066/img1'</span><br>    FPS = <span class="hljs-number">20</span><br>    SIZE = (<span class="hljs-number">1920</span>, <span class="hljs-number">1080</span>)<br>    <span class="hljs-comment"># SIZE = (1280, 720)</span><br>    save_path = <span class="hljs-string">'./vis_result/'</span> + <span class="hljs-string">'test_dance.avi'</span><br>    fourcc = cv2.VideoWriter_fourcc(*<span class="hljs-string">'XVID'</span>)<br>    videoWriter = cv2.VideoWriter(save_path,fourcc,FPS, SIZE, <span class="hljs-literal">True</span>)<span class="hljs-comment">#最后一个是保存图片的尺寸</span><br>    <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> tqdm.tqdm(<span class="hljs-built_in">sorted</span>(glob.glob(PATH + <span class="hljs-string">'/*'</span>))):<br>        frame = cv2.imread(f)<br>        videoWriter.write(frame)<br><br>    videoWriter.release()<br>    cv2.destroyAllWindows()<br></code></pre></td></tr></tbody></table></figure><h2 id="parser-简易使用">Parser 简易使用</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse <br><br><span class="hljs-comment">#定义一个求和函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>(<span class="hljs-params">x,y</span>):</span><br>    <span class="hljs-keyword">return</span> x+y<br><br><span class="hljs-comment">#创建解析器</span><br>parser = argparse.ArgumentParser(description=<span class="hljs-string">'test'</span>)<br><span class="hljs-comment">#添加参数</span><br>parser.add_argument(<span class="hljs-string">'--x'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">10</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'Random seed.'</span>)<br>parser.add_argument(<span class="hljs-string">'--y'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">20</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'Random seed.'</span>)<br><span class="hljs-comment">#解析参数</span><br>args = parser.parse_args()<br><span class="hljs-comment">#使用参数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">sum</span>(args.x,args.y)) <span class="hljs-comment">#结果：30</span><br></code></pre></td></tr></tbody></table></figure><h2 id="绘制跟踪结果">绘制跟踪结果</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_color</span>(<span class="hljs-params">idx</span>):</span><br>    idx = idx * <span class="hljs-number">3</span><br>    color = ((<span class="hljs-number">37</span> * idx) % <span class="hljs-number">255</span>, (<span class="hljs-number">17</span> * idx) % <span class="hljs-number">255</span>, (<span class="hljs-number">29</span> * idx) % <span class="hljs-number">255</span>)<br>    <span class="hljs-keyword">return</span> color<br><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot_tracking</span>(<span class="hljs-params">image, tlwhs, obj_ids, scores=<span class="hljs-literal">None</span>, frame_id=<span class="hljs-number">0</span>, fps=<span class="hljs-number">0.</span>, ids2=<span class="hljs-literal">None</span></span>):</span><br>    im = np.ascontiguousarray(np.copy(image))<br>    im_h, im_w = im.shape[:<span class="hljs-number">2</span>]<br>    top_view = np.zeros([im_w, im_w, <span class="hljs-number">3</span>], dtype=np.uint8) + <span class="hljs-number">255</span><br><br>    <span class="hljs-comment">#text_scale = max(1, image.shape[1] / 1600.)</span><br>    <span class="hljs-comment">#text_thickness = 2</span><br>    <span class="hljs-comment">#line_thickness = max(1, int(image.shape[1] / 500.))</span><br>    text_scale = <span class="hljs-number">2</span><br>    text_thickness = <span class="hljs-number">2</span><br>    line_thickness = <span class="hljs-number">3</span><br><br>    radius = <span class="hljs-built_in">max</span>(<span class="hljs-number">5</span>, <span class="hljs-built_in">int</span>(im_w/<span class="hljs-number">140.</span>))<br>    cv2.putText(im, <span class="hljs-string">'frame: %d fps: %.2f num: %d'</span> % (frame_id, fps, <span class="hljs-built_in">len</span>(tlwhs)),<br>                (<span class="hljs-number">0</span>, <span class="hljs-built_in">int</span>(<span class="hljs-number">15</span> * text_scale)), cv2.FONT_HERSHEY_PLAIN, <span class="hljs-number">2</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), thickness=<span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">for</span> i, tlwh <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tlwhs):<br>        x1, y1, w, h = tlwh<br>        intbox = <span class="hljs-built_in">tuple</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">int</span>, (x1, y1, x1 + w, y1 + h)))<br>        obj_id = <span class="hljs-built_in">int</span>(obj_ids[i])<br>        id_text = <span class="hljs-string">'{}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>(obj_id))<br>        <span class="hljs-keyword">if</span> ids2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            id_text = id_text + <span class="hljs-string">', {}'</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">int</span>(ids2[i]))<br>        color = get_color(<span class="hljs-built_in">abs</span>(obj_id))<br>        cv2.rectangle(im, intbox[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>], intbox[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>], color=color, thickness=line_thickness)<br>        cv2.putText(im, id_text, (intbox[<span class="hljs-number">0</span>], intbox[<span class="hljs-number">1</span>]), cv2.FONT_HERSHEY_PLAIN, text_scale, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>),<br>                    thickness=text_thickness)<br>    <span class="hljs-keyword">return</span> im<br><br></code></pre></td></tr></tbody></table></figure><h2 id="生成树状目录结构">生成树状目录结构</h2><h3 id="版本1">版本1</h3><p>代码来源暂时找到不了，也是CSDN上一个博主的代码：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># tree.py</span><br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> Path<br><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> WindowsPath<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>, <span class="hljs-type">List</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectionTree</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 direction_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">'WorkingDirection'</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 direction_path: <span class="hljs-built_in">str</span> = <span class="hljs-string">'.'</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 ignore_list: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]] = <span class="hljs-literal">None</span></span>):</span><br>        self.owner: WindowsPath = Path(direction_path)<br>        self.tree: <span class="hljs-built_in">str</span> = direction_name + <span class="hljs-string">'/\n'</span><br>        self.ignore_list = ignore_list<br>        <span class="hljs-keyword">if</span> ignore_list <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.ignore_list = []<br>        self.direction_ergodic(path_object=self.owner, n=<span class="hljs-number">0</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tree_add</span>(<span class="hljs-params">self, path_object: WindowsPath, n=<span class="hljs-number">0</span>, last=<span class="hljs-literal">False</span></span>):</span><br>        <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> last:<br>                self.tree += <span class="hljs-string">'│'</span> + (<span class="hljs-string">'    │'</span> * (n - <span class="hljs-number">1</span>)) + <span class="hljs-string">'    └────'</span> + path_object.name<br>            <span class="hljs-keyword">else</span>:<br>                self.tree += <span class="hljs-string">'│'</span> + (<span class="hljs-string">'    │'</span> * (n - <span class="hljs-number">1</span>)) + <span class="hljs-string">'    ├────'</span> + path_object.name<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> last:<br>                self.tree += <span class="hljs-string">'└'</span> + (<span class="hljs-string">'──'</span> * <span class="hljs-number">2</span>) + path_object.name<br>            <span class="hljs-keyword">else</span>:<br>                self.tree += <span class="hljs-string">'├'</span> + (<span class="hljs-string">'──'</span> * <span class="hljs-number">2</span>) + path_object.name<br>        <span class="hljs-keyword">if</span> path_object.is_file():<br>            self.tree += <span class="hljs-string">'\n'</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">elif</span> path_object.is_dir():<br>            self.tree += <span class="hljs-string">'/\n'</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">filter_file</span>(<span class="hljs-params">self, file</span>):</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> self.ignore_list:<br>            <span class="hljs-keyword">if</span> re.fullmatch(item, file.name):<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">direction_ergodic</span>(<span class="hljs-params">self, path_object: WindowsPath, n=<span class="hljs-number">0</span></span>):</span><br>        dir_file: <span class="hljs-built_in">list</span> = <span class="hljs-built_in">list</span>(path_object.iterdir())<br>        dir_file.sort(key=<span class="hljs-keyword">lambda</span> x: x.name.lower())<br>        dir_file = [f <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> <span class="hljs-built_in">filter</span>(self.filter_file, dir_file)]<br>        <span class="hljs-keyword">for</span> i, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dir_file):<br>            <span class="hljs-keyword">if</span> i + <span class="hljs-number">1</span> == <span class="hljs-built_in">len</span>(dir_file):<br>                <span class="hljs-keyword">if</span> self.tree_add(item, n, last=<span class="hljs-literal">True</span>):<br>                    self.direction_ergodic(item, n + <span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">if</span> self.tree_add(item, n, last=<span class="hljs-literal">False</span>):<br>                    self.direction_ergodic(item, n + <span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    i_l = [<br>        <span class="hljs-string">'\.git'</span>, <span class="hljs-string">'__pycache__'</span>, <span class="hljs-string">''</span>, <span class="hljs-string">'venv'</span>, <span class="hljs-string">'\.idea'</span>, <span class="hljs-string">'.+\.jpg'</span>, <span class="hljs-string">'.+\.png'</span>,<br>        <span class="hljs-string">'image'</span>, <span class="hljs-string">'css'</span>, <span class="hljs-string">'admin'</span>, <span class="hljs-string">'beizhu.txt'</span>,<br>          ]<br>    tree = DirectionTree(ignore_list=i_l, direction_path=<span class="hljs-string">'/home/hjy/DeepLearning/summer_practice_baseline/'</span>)<br>    <span class="hljs-built_in">print</span>(tree.tree)<br><br></code></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220813145725737.png" alt="image-20220813145725737" style="zoom:25%;"></p><h3 id="版本2">版本2</h3><p>代码来源：https://blog.csdn.net/zichen_ziqi/article/details/107775556</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 显示文件夹树状目录</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path<br> <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs_showdir</span>(<span class="hljs-params">path, depth</span>):</span><br>    <span class="hljs-keyword">if</span> depth == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">"root:["</span> + path + <span class="hljs-string">"]"</span>)<br> <br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> os.listdir(path):<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">'.git'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> item:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">"|      "</span> * depth + <span class="hljs-string">"+--"</span> + item)<br>            newitem = path +<span class="hljs-string">'/'</span>+ item<br>            <span class="hljs-keyword">if</span> os.path.isdir(newitem):<br>                dfs_showdir(newitem, depth +<span class="hljs-number">1</span>)<br> <br> <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    path = <span class="hljs-string">""</span>             <span class="hljs-comment"># 文件夹路径</span><br>    dfs_showdir(path, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 显示文件夹的树状结构</span><br></code></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220813145521942.png" alt="image-20220813145521942" style="zoom:30%;"></p><h2 id="python判断文件或者目录是否存在如果不存在则创建">Python判断文件或者目录是否存在，如果不存在则创建</h2><p>转载至CSDN，原文链接：https://blog.csdn.net/u013247765/article/details/79050947</p><h4 id="判断目录是否存在">判断目录是否存在</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>dirs = <span class="hljs-string">'/Users/joseph/work/python/'</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(dirs):<br>    os.makedirs(dirs)<br></code></pre></td></tr></tbody></table></figure><h4 id="判断文件是否存在">判断文件是否存在</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br>filename = <span class="hljs-string">'/Users/joseph/work/python/poem.txt'</span><br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(filename):<br>    os.system(<span class="hljs-string">r"touch {}"</span>.<span class="hljs-built_in">format</span>(path))<span class="hljs-comment">#调用系统命令行来创建文件</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>工具函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Quasi-Dense Similarity Learning for Multiple Object Tracking</title>
    <link href="/jasonyang.github.io/2022/06/19/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-Quasi-Dense%20Similarity%20Learning%20for%20Multiple%20Object%20Tracking/"/>
    <url>/jasonyang.github.io/2022/06/19/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-Quasi-Dense%20Similarity%20Learning%20for%20Multiple%20Object%20Tracking/</url>
    
    <content type="html"><![CDATA[<h1 id="阅读笔记-quasi-dense-similarity-learning-for-multiple-object-tracking">阅读笔记-Quasi-DenseSimilarity Learning for Multiple Object Tracking</h1><p>论文连接：https://arxiv.org/pdf/2006.06664.pdf</p><h2 id="摘要">摘要</h2><h3 id="原文">原文</h3><p>​ Similarity learning has been recognized as a crucial step for objecttracking. However, existing multiple object tracking methods only usesparse ground truth matching as the training objective, while ignoringthe majority of the informative regions on the images. In this paper, wepresent Quasi-Dense Similarity Learning, which densely samples hundredsof region proposals on a pair of images for contrastive learning. We candirectly combine this similarity learning with existing detectionmethods to build QuasiDense Tracking (QDTrack) without turning todisplacement regression or motion priors. We also find that theresulting distinctive feature space admits a simple nearest neighborsearch at the inference time. Despite its simplicity, QDTrackoutperforms all existing methods on MOT, BDD100K, Waymo, and TAOtracking benchmarks. It achieves 68.7 MOTA at 20.3 FPS on MOT17 withoutusing external training data. Compared to methods with similardetectors, it boosts almost 10 points of MOTA and significantlydecreases the number of ID switches on BDD100K and Waymo datasets. Ourcode and trained models are available at http://vis.xyz/pub/qdtrack.</p><h3 id="译文">译文</h3><p>​相似性学习已被认为是对象跟踪的关键步骤。然而，现有的多目标跟踪方法仅使用稀疏的地面实况匹配作为训练目标，而忽略了图像上的大部分信息区域。在本文中，我们提出了准密集相似性学习，它在一对图像上密集采样数百个区域提议以进行对比学习。我们可以直接将这种相似性学习与现有的检测方法结合起来构建准密集跟踪（QDTrack），而无需转向位移回归或运动先验。我们还发现，由此产生的独特特征空间允许在推理时进行简单的最近邻搜索。尽管简单，但QDTrack 在 MOT、BDD100K、Waymo 和 TAO跟踪基准上优于所有现有方法。在不使用外部训练数据的情况下，它在 MOT17上以 20.3 FPS 的速度实现了 68.7MOTA。与具有类似检测器的方法相比，它提高了近 10 个点的MOTA，并显着减少了 BDD100K 和 Waymo 数据集上的 ID开关数量。我们的代码和经过训练的模型可在 http://vis.xyz/pub/qdtrack获得。</p><h2 id="总体思路">总体思路</h2><h3 id="以前的外观嵌入学习方法">以前的外观嵌入学习方法</h3><p>​以前MOT中的外观嵌入学习，要么是检测后单独使用ReID方法获得（a），要么就是联合检测和嵌入特征分类一同训练(b)，还有一类方法就是构建GT框的正负样本(c)，然后利用tripletloss训练。以上这些方法使用的都是只有GT框，都忽略了图像上的大部分信息区域，这些区域同样可当做负样本来扯远真实目标区域特征与其的距离，增强特征嵌入的判别性。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220619165204406.png" alt="image-20220619165204406" style="zoom:50%;"></p><h3 id="训练框架">训练框架</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220619195444443.png" alt="image-20220619195444443" style="zoom:80%;"></p><p>​上面是整体的训练框图，首先是关键帧和参考帧用作输入，整体结构采用FasterR-CNN框架，基于RPN结构生成许多感兴趣的区域，然后这些区域特征用于类别判断和边框回归以及增加一个4conv+1fc的embeddingshead用于提取这些RoIs对应的特征，即一个RoI的bbox有一个与之对应的embedding特征。最后对提取的特征利用非参数的softmax和 cross entropy对特征进行学习，已获取更好的目标嵌入表示。</p><p>​嵌入特征学习方面，根据bbox框和GT框的IoU判断，高于0.7则人为是正样本，低于0.3则认为是负样本（背景），同时对于关键帧中的每个bbox（对于背景bbox，其在参考帧对应的正样本同样为背景bbox），其在参考帧对应的正样本定义为和关键帧的bbox代表相同物体的那些bbox，剩下的其它样本都是负样本。然后利用下述的公式进行嵌入特征提取的损失计算：<span class="math display">\[\mathcal{L}_{\text {embed }}=\log \left[1+\sum_{\mathbf{k}^{+}}\sum_{\mathbf{k}^{-}} \exp \left(\mathbf{v} \cdot\mathbf{k}^{-}-\mathbf{v} \cdot \mathbf{k}^{+}\right)\right]\]</span> ​ 其中<span class="math inline">\(\bf{v}\)</span>代表关键帧中的bbox对应的嵌入向量，$\bf{k,v}<span class="math inline">\(是一对正样本（在两帧中对应不同时刻的同一物体）的情况，对应的\)</span>c=1<span class="math inline">\(，否则\)</span>c=0$。</p><p>最后的训练损失函数如下: <span class="math display">\[\mathcal{L}=\mathcal{L}_{\text {det }}+\gamma_{1} \mathcal{L}_{\text{embed }}+\gamma_{2} \mathcal{L}_{\text {aux }}\]</span> 其中<span class="math inline">\(\gamma_1=0.25,\gamma_2=1\)</span>。</p><h3 id="推理流程">推理流程</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220619201006198.png" alt="image-20220619201006198" style="zoom:80%;"></p><p>​ 上图是QDTrack的在线推理过程，此时关键帧为当前时刻<span class="math inline">\(t\)</span>，参考帧为之前多个时刻，参考帧中包含需要跟踪的目标，包括：激活的轨迹、暂时消失的轨迹以及背景目标，背景目标是用来关联当前检测到的一些背景bbox。然后对于这些bbox对应的嵌入特征使用双端softmax进行相似度匹配计算，计算公式如下：<span class="math display">\[\mathbf{f}(i, j)=\left[\frac{\exp \left(\mathbf{n}_{i} \cdot\mathbf{m}_{j}\right)}{\sum_{k=0}^{M-1} \exp \left(\mathbf{n}_{i} \cdot\mathbf{m}_{k}\right)}+\frac{\exp \left(\mathbf{n}_{i} \cdot\mathbf{m}_{j}\right)}{\sum_{k=0}^{N-1} \exp \left(\mathbf{n}_{k} \cdot\mathbf{m}_{j}\right)}\right] / 2\]</span> ​然后文章直接依据双端匹配分数确定跟踪结果，即分数高的匹配边说明关键帧和参考帧是一致的，跟踪成功；分数低的匹配边说明两帧之间目标不一致，如果此时关键帧中的检测bbox置信度又比较高的话说明这是一个新出现的物体，此时初始化目标轨迹，其余的低分匹配被删除。但是这里有一个问题就是<strong>根据匹配公式会存在两个高分匹配边，他们来自参考帧的不同目标，但是他们可能都连接了同一个物体，此时如何分配他们之间的连接关系？是通过贪婪匹配原则，先把最高匹配的边分配了在看剩余的还是说用其他二分图匹配的算法？</strong></p><h2 id="总结">总结</h2><p>这篇文章最大的亮点就是充分利用了检测器的检测框，并且通过一种简单的正负样本指定策略和非参数化的softmax交叉熵损失函数以一种对抗学习的方式完成对嵌入特征的优化，同时基于双端softmax的目标相似度计算保证了相互匹配的一致性，可见简单使用相似度阈值完成轨迹-检测之间的关联。</p>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>对抗学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux和Shell学习记录</title>
    <link href="/jasonyang.github.io/2022/06/16/Linux%E5%92%8CShell%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/jasonyang.github.io/2022/06/16/Linux%E5%92%8CShell%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="linux和shell学习记录">Linux和Shell学习记录</h1><p>总结记录韩顺平老师《2021图解Linux》课程里面的内容，主要是基础部分。</p><p>课程链接：https://www.bilibili.com/video/BV1Sv411r7vd/</p><h2 id="vim使用">vim使用</h2><h3 id="进入vim编辑器">进入vim编辑器</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim hello.txt<br></code></pre></td></tr></tbody></table></figure><p>进入后模型是<code>查看（一般）模式</code>，此模式下可进行快捷操作例如：<code>删除、复制、撤销</code>等。键盘键入<code>i</code>即可进入<code>编辑（插入）模式</code>，此模型下可进行文本编辑。键盘键入<code>ESC</code>回到<code>查看模式</code>，在此基础上键入<code>:</code>进入命令行模式，进行文件的保存。</p><p><strong>三种模式的切换示意图：</strong></p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220615160727673.png" alt="image-20220615160727673" style="zoom:50%;"></p><h3 id="快捷键">快捷键</h3><ol type="1"><li>查看模式<ol type="1"><li><code>yy</code>拷贝光标所在的行，此时移动光标至需要粘贴的位置，键入<code>p</code>粘贴；<ol type="1"><li><code>5yy</code>拷贝光标行及以下4行，同样键入<code>p</code>粘贴；</li></ol></li><li><code>dd</code>删除光标所在的行；<ol type="1"><li><code>5dd</code>删除光标行及以下4行；</li></ol></li><li><code>u</code>撤销上一次操作；</li><li><code>gg</code>将光标快速跳到文件最首行；</li><li><code>G</code>将光标快速跳到文件最末行；<ol type="1"><li><code>20 shift+g</code>，将光标跳到第20行；</li></ol></li><li><code>.</code>单独的小数点，表示重复上一个动作；上一条指令是<code>dd</code>，则键入<code>.</code>代表删除光标所在行。</li></ol></li><li>命令行模式<ol type="1"><li>取消、显示行号<ol type="1"><li>命令行模式下输入<code>:set nu</code>显示文件行号；</li><li>命令行模式下输入<code>:set nonu</code>关闭显示文件行号；</li></ol></li><li>查找关键字符<ol type="1"><li>键入<code>/abc</code>，并回车，向下查找文件中是否存在<code>abc</code>，默认返回字符的第一个位置，然后键入<code>n</code>继续查找下一个匹配的字符；</li><li>键入<code>?abc</code>，并回车，向上查找文件中是否存在<code>abc</code>，默认返回字符上面最近位置，然后键入<code>n</code>继续查找下一个匹配的字符；</li></ol></li><li>保存及退出<ol type="1"><li>命令行模式下键入<code>:wq</code>保存并退出文件；</li><li><code>:wq!</code>强制保存退出；</li><li><code>:q!</code>强制退出不保存；</li><li><code>:q</code>普通退出。</li></ol></li></ol></li></ol><h2 id="linux-开关机和用户登录注销">Linux 开关机和用户登录注销</h2><h3 id="关机和重启">关机和重启</h3><ol type="1"><li><p>关机</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown -h now # 立该进行关机<br>shutdown -h 1 # "hello, 1 分钟后会关机了"<br>halt # 立刻关机<br></code></pre></td></tr></tbody></table></figure></li><li><p>重启</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">shutdown -r now # 立即重启<br>reboot # 立即重启<br></code></pre></td></tr></tbody></table></figure></li><li><p>同步（将内存中的数据写到磁盘）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sync # 把内存的数据同步到磁盘.<br></code></pre></td></tr></tbody></table></figure><blockquote><p>注：一般在关机或者重启前先执行一遍<code>sync</code>指令。</p></blockquote></li></ol><h3 id="用户登录于注销">用户登录于注销</h3><ol type="1"><li><p>登录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - root<br></code></pre></td></tr></tbody></table></figure><p>然后输入root账户的密码即可；从高权限用于切换到低权限用户不需要密码；反之则需要。</p></li><li><p>注销</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">logout<br></code></pre></td></tr></tbody></table></figure><p>退出当前登录的用户，一般在ssh连接时常用。</p></li></ol><h2 id="linux-用户管理">Linux 用户管理</h2><h3 id="添加查看切换删除用户">添加、查看、切换、删除用户</h3><p>只有<code>root</code>用户才能进行其它用户的管理。</p><ol type="1"><li><p>添加用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">useradd tom # 添加tom用户 ubuntu系统默认不创建家目录，但是CentOS会自动创建<br>useradd -m tom # 添加tom用户，并创建tom的家目录<br></code></pre></td></tr></tbody></table></figure></li><li><p>设置用户密码</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">passwd tom<br></code></pre></td></tr></tbody></table></figure></li><li><p>查看用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">id tom<br></code></pre></td></tr></tbody></table></figure><p>查看<code>tom</code>用户所处的组</p></li><li><p>切换用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">su - tom<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除用户</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">userdel tom # 只删除用户，保留用户文件<br>userdel -r tom # 删除用户及其家目录文件<br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="用户组管理添加修改删除组">用户组管理——添加、修改、删除组</h3><p>Linux内每个用户是以用户组来进行管理的，同组内的用户权限相同，因此可根据需要将不同用户放入不同的组中，然后给不同的组赋予不同的权限。</p><p>Linux在创建用户时，默认会创建与用户名一致的组，并把该用户放到该组中。如果需要在创建用户时指定对应的组，需使用<code>-g</code>参数。</p><p><code>useradd -g students -m tom # 创建tom，并将其移动到students组中</code></p><ol type="1"><li><p>添加组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupadd students # 添加 students 组<br></code></pre></td></tr></tbody></table></figure></li><li><p>修改组成员</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -g students jack # 将jack移动到students组<br></code></pre></td></tr></tbody></table></figure></li><li><p>删除组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupdel students <br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="用户组管理权限管理">用户组管理——权限管理</h3><p>在 linux 中的每个用户必须属于一个组，不能独立于组外。在 linux中每个文件有<code>所有者、所在组、其它组</code>的概念。一般而言，用户创建了文件，这个文件的所有者就是该用户，同时用户所在的组就是文件在的所在组，而剩下的组就是该文件的其他组。所有者以及不同组，对文件的权限（读、写、可执行）一般不同。</p><ol type="1"><li><p>修改文件的所有者</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chown jack apple.txt # 将apple.txt文件的所有者修改成jack<br>chown -R jack /home/test # 将/home/test目录下所有的文件和目录的所有者都修改成 jack<br></code></pre></td></tr></tbody></table></figure></li><li><p>修改文件/目录所在的组</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">chgrp fruit orange.txt # 将orange.txt文件的所在组更改为fruit<br>chgrp -R fruit /home/test # 将/home/test目录下所有的文件和目录的所在组都修改成 fruit<br></code></pre></td></tr></tbody></table></figure></li><li><p>修改用户的初始登录文件夹</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">usermod -d tom2 tom # 将tom用户的文件夹由tom变为tom2<br></code></pre></td></tr></tbody></table></figure><blockquote><p>注：用户需要有进入新目录的权限。</p></blockquote></li><li><p>赋予用户root权限</p><p>用<code>root</code>账户登录，然后使用<code>vim /etc/sudoers</code>打开，在<code>root</code>下面添加一行一样的语句，即可赋予其他用户root权限。</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">## Allow root <span class="hljs-keyword">to</span> run <span class="hljs-keyword">any</span> commands anywhere<br>root    <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>)     <span class="hljs-keyword">ALL</span><br>tom   <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>)     <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></tbody></table></figure></li></ol><h4 id="文件目录权限介绍">文件/目录权限介绍</h4><p>键入<code>ls -l</code>查看目录内所含文件、子目录的详细信息</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220616094134969.png" alt="image-20220616094134969" style="zoom:80%;"></p><p>第0位，确定文件类型：<code>d、-、l、c、b</code></p><ul><li><code>d</code>——表示是一个目录</li><li><code>-</code>——表示就是一个普通文件</li><li><code>l</code>——表示是一个软连接（快捷方式）</li><li><code>c</code>——字符串设备，鼠标、键盘等</li><li><code>b</code>——块设备，硬盘等</li></ul><p>第1-3位，确定文件所有者对该文件的权限</p><ul><li><code>r</code>——可读，可查看</li><li><code>w</code>——可写，可修改</li><li><code>x</code>——可执行</li></ul><p>第4-6位，确定文件所在组成员对该文件的权限，同样是<code>rwx</code>，如果没有相应权限则用<code>-</code>代替</p><p>第7-9位，确定其他组成员对该文件的权限。</p><p>举例：<code>drwxrwxr-x  4 hjy hjy 4096 6月   9 14:26 apps</code>，表示这是一个目录，然后目录所有者<code>hjy</code>对该目录有<code>rwx</code>权限，目录所在组<code>hjy</code>也有<code>rwx</code>权限，最后其他组对该目录有<code>rx</code>权限，目录中有<code>4</code>个子文件或文件，最后修改时间是<code>6月9日14：26</code>，此目录名为<code>apps</code>。</p><h4 id="rwx权限作用到目录和作用到文件">rwx权限：作用到目录和作用到文件</h4><ol type="1"><li>作用到文件<ol type="1"><li><code>r</code>，读取，查看</li><li><code>w</code>，可以修改，但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。</li><li><code>x</code>，可以被执行</li></ol></li><li>作用到目录<ol type="1"><li><code>r</code>，可以读取，ls 查看目录内容</li><li><code>w</code>，可以修改, 对目录内创建+删除+重命名目录</li><li><code>x</code>，可以进入到该目录</li></ol></li></ol><h4 id="chmod-修改文件权限">chmod 修改文件权限</h4><ol type="1"><li><p>通过<code>+ - =</code>变更权限</p><p><code>u</code>，所有者；<code>g</code>,所在组，<code>o</code>，表示其他组，<code>a</code>，表示所有</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u=rwx,g=rx,o=x my_task # 赋予所有者对my_task目录rwx的权限，赋予其它组成员对my_task可执行的权限。<br>chmod o+r my_task # 给其他组成员赋予可读的权限<br>chmod a-r my_task # 对所有成员都赋予可读权限<br></code></pre></td></tr></tbody></table></figure></li><li><p>通过数字变更权限</p><p><code>r=4,w=2,x=1</code>，可读权限用4表示，可执行权限用2表示，因此下述两条语句等价</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs shell">   chmod u=rwx,g=rx,o=x my_task<br>   chmod 751 my_task<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## 用户管理相关的文件</span></span><br><br>1. 用户配置文件——`/etc/passwd`<br><br>   `cat /etc/passwd `部分显示如下：<br><br>   &lt;img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220615173659819.png" alt="image-20220615173659819" style="zoom:100%;" /&gt;<br><br>   每列含义：`用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell`<br><br>2. 口令配置文件——`/etc/shadow`<br><br>   都是一些加密的信息，感觉没啥用。<br><br>   每列含义：`登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志`<br><br>3.  组配置文件——`/etc/group`<br><br>   `cat /etc/group `部分显示如下：<br><br>   &lt;img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220615174208846.png" alt="image-20220615174208846" style="zoom:100%;" /&gt;<br><br>   每列含义：`组名:口令:组标识号:组内用户列表`<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 设置、查看Linux运行级别</span></span><br><br>1. 运行级别：<br><br>   1. `0`- 关机<br>   2. `1`- 单用户（用于找回root密码）<br>   3. `2`- 多用户状态没有网络服务<br>   4. `3`- 多用户状态有网络服务<br>   5. `4` - 系统未使用，保留给用户<br>   6. `5`- 图形界面<br>   7. `6`- 系统重启<br><br>2. 查看运行级别<br><br>   ```shell<br>   systemctl get-default <br></code></pre></td></tr></tbody></table></figure><p>一般返回是<code>graphical.target</code>，代表上述的级别<code>5</code>-图形界面。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 对应关系</span><br>multi-user.target: analogous to runlevel 3 <br>graphical.target: analogous to runlevel 5<br></code></pre></td></tr></tbody></table></figure><p>设置为多用户有网络的级别：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl set-default multi-user.target<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="linux文件目录类指令">Linux文件目录类指令</h2><ol type="1"><li><p>pwd 指令</p><p>显示当前工作目录的绝对路径。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd<br></code></pre></td></tr></tbody></table></figure></li><li><p>ls 和 ll 指令</p><p>显示当前的路径中下的文件和目录。<code>ls</code>一般只显示可见的文件，且文件显示的信息较少；<code>ll</code>能够较全的显示文件、目录信息（包括修改时间、大小、权限等等。）</p><p><code>ls</code>选项参数：</p><ul><li><code>-a</code>——显示所有文件包括<code>.xxx</code>开头的隐藏文件；</li><li><code>-h</code>——<code>human</code>表示显示信息以便于人类阅读的方式显示，主要为了将文件大小自动转换为<code>KB,MB,GB</code>的形式；</li><li><code>-l</code>——用在<code>ls</code>命令后，以显示更全的信息。</li></ul><blockquote><p><code>ll</code>直接就是全信息显示，也会显示隐藏文件，只有一个<code>-h</code>参数。</p></blockquote><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -ahl  # 带参数使用<br>ll -h<br></code></pre></td></tr></tbody></table></figure></li><li><p>cd 指令</p><p>切换到指定目录</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~ # 切换到home目录<br>cd .. # 切换到上一级目录<br>cd ../.. # 切换到上上级目录<br>cd / # 切换到根目录<br>cd /home/tom/downloads # 切换到tom的downloads目录<br></code></pre></td></tr></tbody></table></figure></li><li><p>mkdir 指令</p><p>创建文件夹（目录）</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir my_task # 创建文件夹<br>mkdir -p my_task/task1 # 创建多级目录 <br></code></pre></td></tr></tbody></table></figure></li><li><p>rm 指令</p><p>删除文件或者文件夹</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm task.zip # 删除文件<br>rm -rf my_task # 递归删除文件夹（目录）<br></code></pre></td></tr></tbody></table></figure><p><code>-r</code>，表示递归删除</p><p><code>-f</code>，表示直接删除不报告，不用确认删除过程。</p></li><li><p>touch 指令</p><p>生成普通文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch hello.txt<br></code></pre></td></tr></tbody></table></figure></li><li><p>cp 指令</p></li></ol><p>拷贝文件</p><p></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp hello.txt /home/my_task # 拷贝hello.txt文件到my_task目录下<br>cp -r /home/my_task /home/my_test/  # 拷贝my_task目录至my_test目录下<br><span class="hljs-meta">#</span><span class="bash"> 进入my_test目录，可以看到有my_task子目录</span><br></code></pre></td></tr></tbody></table></figure><p></p><p><code>-f</code>，覆盖已经存在的目标文件而不给出提示。</p><ol start="8" type="1"><li><p>mv 指令</p><p>移动文件或者目录，或者为其重命名</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /home/task1 /home/task # 将task1目录移动到task目录下<br>mv hello_copy.txt hello.txt # 相同目录下移动就是重命名，将hello_copy改为hello<br>mv hello.txt /home/task # 将hello.txt移动到task目录下<br></code></pre></td></tr></tbody></table></figure></li><li><p>cat 指令</p><p>查看文件内容，不能修改文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/profile # 查看profile文件，打印在终端<br>cat -n /etc/profile # 查看profile文件并显示行号<br>cat -n /etc/profile | more # 查看profile文件并交给more指令交互展示<br></code></pre></td></tr></tbody></table></figure></li><li><p>more 指令</p><p>交互式显示文件内容</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">more /etc/profile # 交互式查看profile文件<br></code></pre></td></tr></tbody></table></figure><p>more 交互键说明：</p><p><code>空格</code>——下翻一页；</p><p><code>Enter</code>——向下翻一行；</p><p><code>q</code>——不再查看立即退出交互；</p><p><code>=</code>——显示当前行号；</p><p><code>:f</code>——输出文件名和当前行行号。</p><blockquote><p>注：<code>q,=,:f</code>这些指令在敲出来的时候都不会在终端上有显示，直接敲就行。</p></blockquote></li><li><p>less 指令</p><p>less 和 more 类似都可以用来交互式查看文件，不过less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">less /etc/profile<br></code></pre></td></tr></tbody></table></figure><p>less 交互键说明：</p><p><code>空格</code>——下翻一页；</p><p><code>/abc</code>——+回车，向下搜索<code>abc</code>字符，键入<code>n</code>查询下一个，键入<code>N</code>查询上一个；</p><p><code>?abc</code>——+回车，向上搜索<code>abc</code>字符，键入<code>n</code>查询下一个，键入<code>N</code>查询上一个；</p><p><code>q</code>——退出查看。</p></li><li><p>echo 指令</p><p>相当于Python里面的<code>print()</code>，打印输出内容；主要还是在<code>.sh</code>文件内使用。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo "hello world!"<br></code></pre></td></tr></tbody></table></figure></li><li><p>head 指令</p></li></ol><pre><code>查看文件前面几行的内容<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">head /etc/profile # 查看profile前10行的内容<br>head -n 20 /etc/profile # 查看profile前20行的内容<br></code></pre></td></tr></tbody></table></figure></code></pre><ol start="14" type="1"><li><p>tail 指令</p><p>查看文件最后几行的内容</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail /etc/profile # 查看profile末尾10行的内容<br>tail -n 20 /etc/profile # 查看profile末尾20行的内容<br>tail -f /etc/profile # 实时监控profile文件的改动<br></code></pre></td></tr></tbody></table></figure><p><code>-f</code>，参数指定后tail进程为一直占据终端窗口，可使用<code>ctrl + c</code>终止进程。</p></li><li><p><code>&gt;</code> 指令和 <code>&gt;&gt;</code>指令</p><p><code>&gt;</code>表示输出重定向，<code>&gt;&gt;</code>表示重定向追加</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l &gt; log.txt # 将当前目录下的文件和子目录以文本形式写入log.txt中<br>ls -al &gt;&gt; log.txt # 将目录信息追加（补充）到log.txt中<br>cat /etc/profile &gt; my_profile # 将/etc/profile中的内容重定向到my_profile文件中<br>echo "hello world!" &gt;&gt; my_log.txt<br></code></pre></td></tr></tbody></table></figure></li><li><p>ln 指令</p><p>软连接，相当于Windows里面的快捷方式</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /root /home/myroot # 在/home目录下创建一个软连接myroot，连接到/root目录<br>rm /home/myroot # 删除软链接<br></code></pre></td></tr></tbody></table></figure></li><li><p>history 指令</p><p>查看已经执行过历史命令,也可以执行历史指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">history # 查看之前已执行的历史命令<br>history 10 # 查看前10条已执行的历史命令<br>!476 # 执行之前id为476的历史命令<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="linux时间日期类指令">Linux时间日期类指令</h2><ol type="1"><li><p>date 显示与设置日期</p><p>显示相关</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">date # 显示当前时间<br>date +%Y # 显示当前年份<br>date +%m # 显示当前月份<br>date +%d # 显示当前天数<br>date "+%Y-%m-%d %H:%M:%S" # 显示年月日时分秒<br></code></pre></td></tr></tbody></table></figure><p>设置相关</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">date -s "2020-11-03 20:02:10" # 设置时间 -s代表set<br></code></pre></td></tr></tbody></table></figure></li><li><p>cal 日历指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cal # 显示当前日历<br>cal 2022 # 显示2022年日历<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="linux搜索查找类指令">Linux搜索查找类指令</h2><ol type="1"><li><p>find 指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">find /home/tom -name hello.txt # 在/home/tom下通过文件名查找hello.txt<br>find /home/tom -user tom # 在/home/tom下查找属于用户tom的文件<br>find /home/tom -size +200M # 在/home/tom下查找大于200M的文件<br>find /home/tom -size -200M # 在/home/tom下查找小于200M的文件<br></code></pre></td></tr></tbody></table></figure></li><li><p>locate 指令</p><p>locate 指令利用事先建立的系统中所有文件名称及路径的 locate数据库实现快速 定位给定的文件。Locate指令无需遍历整个文件系统，查询速度较快。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">updatedb # 先创建更新locate数据库<br>locate hello.txt # 全局查找hello.txt文件，并返回文件路径<br></code></pre></td></tr></tbody></table></figure></li><li><p>grep 指令</p><p>查找过滤文件，得到想看的字符内容</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat -n /home/hello.txt | grep "yes" # 在hello.txt文件中，查找"yes"所在行，并且显示行号<br>grep -n 'yes' /home/hello.txt # 在hello.txt文件中，查找"yes"所在行，并且显示行号<br></code></pre></td></tr></tbody></table></figure><p><code>-i</code>，表示筛选时忽略大小写。</p></li></ol><h2 id="linux压缩和解压指令">Linux压缩和解压指令</h2><ol type="1"><li><p>gzip 和 gunzip 指令</p><p>压缩和解压<code>.gz</code>后缀的文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gzip /home/my_task/hello.txt # 压缩hello.txt文件并存入my_task目录下<br>gunzip /home/my_task/hello.txt.gz # 解压文件<br></code></pre></td></tr></tbody></table></figure></li><li><p>zip 和 unzip 指令</p><p>压缩和解压<code>.zip</code>后缀的文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">zip -r myhome.zip /home/ # 将home目录及其包含的文件和子文件夹都压缩<br>unzip -d /opt/tmp /home/myhome.zip # 将myhome.zip解压到/opt/tmp目录下<br></code></pre></td></tr></tbody></table></figure><p><code>-d</code>，指定解压目录</p></li><li><p>tar 指令</p><p>打包指令，用于处理<code>.tar.gz</code>后缀的文件</p><p><code>-c</code>，产生<code>.tar</code>打包文件</p><p><code>-v</code>，显示处理过程信息</p><p><code>-f</code>，指定打包压缩后的文件名</p><p><code>-z</code>，打包同时压缩</p><p><code>-x</code>，解包<code>.tar</code>文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt # 打包压缩多个文件<br>tar -zcvf myhome.tar.gz /home/ # 将/home 的文件夹 压缩成 myhome.tar.gz<br>tar -zxvf pc.tar.gz # 解压到当前目录<br>tar -zxvf /home/myhome.tar.gz -C /opt/tmp # 解压到/opt/tmp目录<br></code></pre></td></tr></tbody></table></figure><p><code>-C</code>，指定解压目录</p></li></ol><h2 id="linux-磁盘挂载情况以及占用空间查看">Linux磁盘挂载情况以及占用空间查看</h2><ol type="1"><li><p>使用 lsblk 或 lsblk -f 查看当前主机的磁盘挂载情况</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsblk -f <br></code></pre></td></tr></tbody></table></figure></li><li><p>du -h 指令</p><p>查询指定目录下磁盘的占用情况，默认为当前目录</p><p><code>-h</code>——human格式显示</p><p><code>-a</code>——包含文件和目录</p><p><code>--max-depth=1</code>——查询占用情况时使用的子目录深度，一般设定1即可</p><p><code>-c</code>——列出各文件明细的同时，增加汇总情况</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -hac --max-depth=1 /my_task # 查看my_task目录中一级子目录的磁盘占用情况<br></code></pre></td></tr></tbody></table></figure></li><li><p>磁盘情况实用指令</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l /opt | grep "^-" | wc -l  # 统计/opt文件夹下文件的个数<br>ls -lR /opt | grep "^-" | wc -l # 统计/opt文件夹下文件的个数，包括子文件夹里的<br>ls -l /opt | grep "^d" | wc -l # 统计/opt文件夹下目录的个数<br>ls -lR /opt | grep "^d" | wc -l # 统计/opt文件夹下目录的个数，包括子目录里的<br>tree /home/my_task # 以树状图的形式显示my_task下的目录结构<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="linux-进程管理">Linux 进程管理</h2><h3 id="普通进程管理">普通进程管理</h3><ol type="1"><li><p>ps -aux 指令</p><p>显示当前运行进程的所有信息，其中<code>PID</code>表示进程号，<code>PPID</code>表示其父进程号</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -aux<br></code></pre></td></tr></tbody></table></figure><ul><li><p><code>-A</code> 列出所有的进程</p></li><li><p><code>-w</code>显示加宽可以显示较多的资讯</p></li><li><p><code>-au</code>显示较详细的资讯</p></li><li><p><code>-aux</code>显示所有包含其他使用者的行程</p></li></ul></li><li><p>ps -ef 指令</p><p>以全格式显示当前所有的进程的信息，包括其父进程；<code>-e</code>表示显示所有进程，<code>-f</code>表示全格式显示</p></li><li><p>top 指令</p><p>实时显示主机当前进程信息，默认以CPU使用率从高到低排序</p><p><code>-d</code>——动态更新间隔时间，默认是3秒</p><p><code>-i</code>——不显示闲置或者僵死进程</p><p><code>-p</code>——只监控指定pid的进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top -p 1079 -d 1 # 只监控1079进程的变化情况，每隔一秒更新<br></code></pre></td></tr></tbody></table></figure><p>top交互指令： <code>P</code>——以CPU使用率排名，默认此项</p><p><code>M</code>——以内存使用率排名</p><p><code>N</code>——以PID序号排序</p><p><code>u</code>——+ tom 只查询tom用户相关的进程</p><p><code>k</code>——+ 11421 终止pid为11421的进程</p><p><code>q</code>——退出top</p></li><li><p>kill 和 killall 指令</p><p>终止某个进程</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill 11421 # 终止pid号为11421的进程<br>kill -9 11421 # 强制终止pid号为11421的进程<br>killall gedit # 终止所有名字为gedit的进程<br></code></pre></td></tr></tbody></table></figure></li><li><p>pstree 指令</p><p>以树状图的结构显示进程信息</p><p><code>-p</code>，显示进程的pid；<code>-u</code>，指定查看属于某个用户的进程</p></li></ol><h3 id="服务进程管理">服务进程管理</h3><p>服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysqld，sshd 防火墙等)，因此又可称为守护进程。</p><ol type="1"><li><p>通过<code>service</code>管理服务</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">service 服务名 [start | stop | restart | reload | status]<br>service sshd start # 开启sshd服务<br></code></pre></td></tr></tbody></table></figure></li><li><p>通过<code>systemctl</code>管理服务</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl [start | stop | restart | status] 服务名<br>systemctl start sshd<br><br>systemctl list-unit-files # 查看服务是否开机自启<br>systemctl list-unit-files | grep sshd # 查看sshd服务<br>systemctl enable sshd # 设置服务开机启动<br>systemctl disable sshd <br>systemctl is-enabled sshd  # 查询某个服务是否是自启动<br></code></pre></td></tr></tbody></table></figure></li></ol><h2 id="shell-介绍">Shell 介绍</h2><p>Shell是一个命令行解释器，可以用 Shell来启动、挂起、停止甚至是编写一些程序。</p><p><strong>Shell 脚本格式要求：</strong></p><ol type="1"><li>脚本以<code>#!/bin/bash</code>开头</li><li>脚本需要有可执行权限</li></ol><p>如果脚本<code>.sh</code>文件没有可执行权限也可以通过<code>sh my_shell.sh</code>进行执行。</p><h3 id="shell-变量">Shell 变量</h3><p>命名规则和一般脚本语言的规则一致，变量由字母、数字、下划线组成，但是不能以数字开头；Shell中的变量有系统变量和自定义变量之分，其中系统变量包括<code>$HOME、$PWD、$SHELL、$USER</code>等等。</p><ol type="1"><li><p>定义普通变量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A=100 # 定义变量A<br>echo A=$A # 输出A变量的值<br>echo "A=$A" # 同上<br></code></pre></td></tr></tbody></table></figure></li><li><p>撤销普通变量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>A=100 # 定义变量A<br>unset A # 撤销变量A<br></code></pre></td></tr></tbody></table></figure></li><li><p>定义静态变量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>readonly B=10<br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">unset</span> B <span class="hljs-comment"># 静态变量不能被撤销</span></span><br></code></pre></td></tr></tbody></table></figure></li><li><p>使用环境变量</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo "local_path=$PWD"<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> shell 多行注释 :&lt;&lt;! 注释内容 !</span><br>:&lt;&lt;! <br>C=`date` <br>D=$(date) <br>echo "C=$C" <br>echo "D=$D" <br>!<br></code></pre></td></tr></tbody></table></figure></li><li><p>定义环境变量，供所有Shell脚本使用</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export A=100 # 定义A为环境变量（临时添加），在另一个.sh脚本中也能使用到A<br>unset A # 撤销环境变量<br></code></pre></td></tr></tbody></table></figure><p>进入<code>/etc/profile</code>文件或者<code>.bashrc</code>文件，在文件末尾加入<code>export A=100</code>，并执行<code>source /etc/profile</code>或者<code>source .bashrc</code>则环境变量立即生效，并永久存在。</p></li></ol><h2 id="shell-位置参数变量和预定义变量">Shell位置参数变量和预定义变量</h2><p>位置参数变量用于获取执行<code>.sh</code>脚本时，附加的一些额外参数信息，预定义变量用于一些查询描述。</p><ol type="1"><li><code>$n</code>，n可以为0-9是个数字，或者用<code>${12}</code>来表示两位数字。<code>$0</code>表示执行命令本身，<code>$1</code>表示<code>.sh</code>命令后接的第一个参数，<code>$2</code>表示命令后接的第二个参数，以此类推。</li><li><code>$*</code>，一次性获取命令后的所有参数，把所有参数看成一个整体</li><li><code>$@</code>，一次性获取命令后的所有参数，把每个参数区别对待</li><li><code>$#</code>，获取命令行后参数的个数</li><li><code>$$</code>，获取当前进程的PID号</li><li><code>$!</code>，后台运行的最后一个进程的PID号</li><li><code>$?</code>，判定上一条指令是否执行成功，如果成功，则返回0，返回非0则表示上条指令执行不成功。</li></ol><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>echo "pos 0 = $0, pos 1 = $1, pos 2 = $2"<br>echo "all augrements:$*"<br>echo "all : $@"<br>echo "count: $#"<br>echo "current pid : $$"<br>echo "$?"<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 输出</span><br><span class="hljs-meta">#</span><span class="bash"> 执行 sh test.sh  10 100 1000</span><br>:&lt;&lt;!<br>pos 0 = test.sh, pos 1 = 10, pos 2 = 100<br>all augrements:10 100 1000<br>all : 10 100 1000<br>count: 3<br>current pid : 89830<br>0<br>!<br></code></pre></td></tr></tbody></table></figure><h2 id="shell-运算符和条件语句">Shell 运算符和条件语句</h2><h3 id="运算符">运算符</h3><p>基本表达式：<code>$[运算式]</code>；运算符号：<code>+ - * / %</code>，加减乘除和取余</p><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>RES1=$[(2+3)*4]<br>echo "res1=$RES1"<br></code></pre></td></tr></tbody></table></figure><h3 id="条件语句">条件语句</h3><p>基本语法：<code>[ condition ]</code>，注condition前后有空格，如果非空则返回true</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>[ hjy ] # 返回 true <br>[ ]  # 返回 false<br>[ hjy ] &amp;&amp; echo OK || echo No  # 条件满足 输出 OK， 不满足 输出 No<br></code></pre></td></tr></tbody></table></figure><ol type="1"><li><p><code>if</code>判断</p><p>语法格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">if [ condition ]<br>then<br>coding<br>elif [ condition ]<br>then<br>coding<br>fi <br></code></pre></td></tr></tbody></table></figure></li><li><p>常用判断字符</p><ol type="1"><li>字符串比较：<code>=</code></li><li>两个整数比较：<code>-lt -le -eq -gt -ge -ne</code></li><li>按照文件权限判断：<code>-r -w -x</code></li><li>按照文件类型判断：<code>-f -e -d</code>，<code>-f</code>和<code>-d</code>，表示文件存在且是一个文件或者目录</li></ol><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>if [ "ok" = "ok" ]<br>then<br>        echo "equal"<br>fi<br>if [ 23 -ge 22 ]<br>then<br>        echo "大于"<br>fi<br>if [ -f ./hello.txt ]<br>then<br>        echo "存在"<br>fi<br>if [ -d ./hello.txt ]<br>then<br>        echo "存在"<br>else<br>        echo "不存在"<br>fi<br></code></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">equal</span><br>大于<br>存在<br>不存在<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>case</code>判断</p><p>语法格式：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">case $变量 in<br>"情况1")<br>coding<br>;;<br>"情况2")<br>coding<br>;;<br>*) # 其它情况<br>coding<br>;;<br>esac<br></code></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>case $1 in<br>"1")<br>echo "a"<br>;;<br>"2")<br>echo "b"<br>;;<br>"3")<br>echo "c"<br>;;<br>*)<br>echo "d"<br>;;<br>esac<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 执行 sh test.sh 1</span><br><span class="hljs-meta">#</span><span class="bash"> 输出 a</span><br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="循环">循环</h3><ol type="1"><li><p>for 循环</p><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>for i in "$*"<br>do<br>echo "num is $i"<br>done<br><br>for i in "$@"<br>do<br>echo "num is $i"<br>done<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 输入： sh test.sh 10 20 30</span><br><span class="hljs-meta">#</span><span class="bash"> 输出：</span> <br><span class="hljs-meta">#</span><span class="bash"> num is 10 20 30</span><br><span class="hljs-meta">#</span><span class="bash"> num is 10</span><br><span class="hljs-meta">#</span><span class="bash"> num is 20</span><br><span class="hljs-meta">#</span><span class="bash"> num is 30</span><br><br>SUM=0<br>for(( i=1; i&lt;=$1; i++))<br>do<br>SUM=$[$SUM+$i]<br>done<br>echo "sum is $SUM"<br></code></pre></td></tr></tbody></table></figure></li><li><p>while 循环</p><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>SUM=0<br>i=0<br>while [ $i -le $1]<br>do<br>SUM=$[$SUM+$i]<br>i=$[$i+1]<br>done<br>echo "sum is $SUM"<br></code></pre></td></tr></tbody></table></figure></li></ol><h3 id="控制台交互式输入">控制台交互式输入</h3><p>指令<code>read</code>,参数<code>-p</code>，提示语句，<code>-t</code>，读取参数时的等待时间（秒）。<code>-t</code>参数在Ubuntu里面貌似会报错。</p><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>read -p "plase input num1=" num1<br>echo "num1=$num1"<br><br>read -p "plase input num2=" num2<br>echo "num2=$num2"<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 执行：sh test.sh</span> <br><span class="hljs-meta">#</span><span class="bash"> 输入： 10 20</span><br><span class="hljs-meta">#</span><span class="bash"> 输出：</span> <br><span class="hljs-meta">#</span><span class="bash"> plase input num1=10</span><br><span class="hljs-meta">#</span><span class="bash"> num1=10</span><br><span class="hljs-meta">#</span><span class="bash"> plase input num2=20</span><br><span class="hljs-meta">#</span><span class="bash"> num2=20</span><br></code></pre></td></tr></tbody></table></figure><h3 id="函数相关">函数相关</h3><ol type="1"><li><p>系统函数</p><ol type="1"><li><p><code>basename</code>——返回文件名；</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">basename /home/hello.txt # 打印hello.txt<br></code></pre></td></tr></tbody></table></figure></li><li><p><code>dirname</code>——返回除去文件名后剩下的绝对路径</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dirnaem /home/hello.txt # 打印/home<br></code></pre></td></tr></tbody></table></figure></li></ol></li><li><p>自定义函数</p><p>示例：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><br>funWithReturn(){<br>    echo "这个函数会对输入的两个数字进行相加运算..."<br>    echo "输入第一个数字: "<br>    read aNum<br>    echo "输入第二个数字: "<br>    read anotherNum<br>    echo "两个数字分别为 $aNum 和 $anotherNum !"<br>    return $(($aNum+$anotherNum))<br>}<br>funWithReturn<br>echo "输入的两个数字之和为 $? !"<br><br>:&lt;&lt;!<br>输出：<br>这个函数会对输入的两个数字进行相加运算...<br>输入第一个数字: <br>1<br>输入第二个数字: <br>2<br>两个数字分别为 1 和 2 !<br>输入的两个数字之和为 3 !<br>!<br></code></pre></td></tr></tbody></table></figure><h2 id="apt相关指令">apt相关指令</h2><p><code>sudo apt-get update</code> ** 更新源**</p><p><code>sudo apt-get install package</code> <strong>安装包</strong></p><p><code>sudo apt-get remove package</code> <strong>删除包</strong></p><p><code>sudo apt-cache search package</code><strong>搜索软件包</strong></p><p><code>sudo apt-cache show package</code><strong>获取包的相关信息：大小、说明、版本</strong></p><p><code>sudo apt-get install package --reinstall</code><strong>重新安装包</strong></p><p><code>sudo apt-get -f install</code> 修复安装</p><p><code>sudo apt-get remove package --purge</code><strong>删除包，包括配置文件等</strong></p><p><code>sudo apt-get build-dep package</code> 安装相关的编译环境</p><p><code>sudo apt-get upgrade</code> <strong>更新已安装的包</strong></p><p><code>sudo apt-get source package</code> 下载该包的源代码</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux SSH配置方案</title>
    <link href="/jasonyang.github.io/2022/06/07/Linux%20SSH%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/"/>
    <url>/jasonyang.github.io/2022/06/07/Linux%20SSH%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="linux-ssh配置方案">Linux SSH配置方案</h1><p>[TOC]</p><h2 id="安装sshd服务">安装sshd服务</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install sshd<br></code></pre></td></tr></tbody></table></figure><h2 id="启动和停止ssh服务">启动和停止ssh服务</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service sshd start<br></code></pre></td></tr></tbody></table></figure><p>这里也可以终止服务</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service sshd stop<br></code></pre></td></tr></tbody></table></figure><h2 id="配置ssh开放端口并允许远程访问">配置ssh，开放端口，并允许远程访问</h2><p>键入以下指令打开ssh配置文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gedit /etc/ssh/sshd_config<br></code></pre></td></tr></tbody></table></figure><p>打开后修改文件如下：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/hjy/image-20220612100551512.png" alt="image-20220612100551512"><figcaption aria-hidden="true">image-20220612100551512</figcaption></figure><h2 id="查看ssh服务启动状态">查看ssh服务启动状态</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service ssh status<br></code></pre></td></tr></tbody></table></figure><p>如果其<code>Active:</code>显示为<code>active(running)</code>则为开启状态；反之如果显示为<code>inactive (dead)</code>则此时处于未运行状态。</p><h2 id="查看linux服务器端的ip地址">查看linux服务器端的ip地址</h2><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ip address<br></code></pre></td></tr></tbody></table></figure><h2 id="ssh远程连接与免密登录">ssh远程连接与免密登录</h2><h3 id="用户名密码登录">用户名+密码登录</h3><p>在客户端（mac或者Windows），（刚才配置的linux暂且称为服务器端）的终端输入：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh username@198.98.198.222 -p 22<br></code></pre></td></tr></tbody></table></figure><p>然后根据提示输入用户的密码即可登录。</p><h3 id="免密登录">免密登录</h3><p>在客户端（mac或者Windows）的终端中输入：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh-keygen -t my_rsa<br></code></pre></td></tr></tbody></table></figure><p>然后一路回车，上述语句将在客户端的<code>.ssh</code>文件夹下生成两个文件<code>my_rsa</code>和<code>my_rsa.pub</code>，第一文件存储在客户端上，第二个文件通过<code>scp</code>指令或者其它任意的方式传到配置的linux服务器端的<code>.ssh</code>文件夹下。</p><p>最后输入下述指令将密钥授权追加写入<code>authorized_keys</code>文件</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat my_rsa.pub &gt;&gt; authorized_keys<br></code></pre></td></tr></tbody></table></figure><p>最最后一步，在客户端（mac或者Windows）打开<code>.ssh/config</code>补充以下内容：</p><figure class="highlight crmsh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Host my_server<br>    HostName <span class="hljs-number">198.98</span>.<span class="hljs-number">198.222</span> <span class="hljs-comment"># 刚才的linux的ip地址</span><br>    <span class="hljs-keyword">User</span> <span class="hljs-title">username</span> <span class="hljs-comment"># 需要登录的用户名</span><br>    Port <span class="hljs-number">22</span> <br>    IdentityFile <span class="hljs-string">"~/.ssh/my_rsa"</span><br><br></code></pre></td></tr></tbody></table></figure><p>之后就可以直接在终端输入<code>ssh my_server</code>连接自己的linux服务器了。</p><h2 id="参考博文">参考博文</h2><p>【CSDN】Linux配置SSH服务实现远程远程访问：https://blog.csdn.net/liguangxianbin/article/details/79759498</p><p>【CSDN】linux开启ssh服务，实现ssh远程登录：<a href="https://blog.csdn.net/Shiny0815/article/details/95336929?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=Linux%E9%85%8D%E7%BD%AESSH%E6%9C%8D%E5%8A%A1%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-3-95336929.142%5Ev13%5Epc_search_result_control_group,157%5Ev14%5Enew_3&amp;spm=1018.2226.3001.4187">链接</a></p><p>【网页】如何解决SSH连接 “ConnectionRefused”报错：https://www.wbolt.com/how-to-fix-ssh-connection-refused.html</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Towards Discriminative Representation:Multi-view Trajectory Contrastive Learning for Online Multi-object Tracking (MTtrack)</title>
    <link href="/jasonyang.github.io/2022/05/27/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-MTtrack/"/>
    <url>/jasonyang.github.io/2022/05/27/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-MTtrack/</url>
    
    <content type="html"><![CDATA[<h1 id="towards-discriminative-representation-multi-view-trajectory-contrastive-learning-for-online-multi-object-tracking">TowardsDiscriminative Representation: Multi-view Trajectory ContrastiveLearning for Online Multi-object Tracking</h1><p>原文链接：https://arxiv.org/pdf/2203.14208.pdf</p><h2 id="阅读疑惑">阅读疑惑</h2><ol type="1"><li>“在推理阶段，开发了一种相似性引导的特征融合策略，以进一步提高轨迹表示的质量。”<ol type="1"><li>计算当前捕获的特征与之前轨迹buffer中的特征的余弦相似度，然后基于此相似度进行加权特征融合。</li></ol></li><li>在回归采样点坐标的时候，中心点特征的维度是<span class="math inline">\(256\times1\)</span>，无论如进行线性变化，最后得到维度都是<span class="math inline">\(N_k \times 1\)</span>，如何确定<span class="math inline">\(x,y\)</span>方向的偏移？<ol type="1"><li>应该是用中心点特征（256）去变换得到<span class="math inline">\(N_k\)</span>个坐标偏移点坐标，即<span class="math inline">\(1 \times 256-&gt;1 \times (N_k \times2)\)</span></li></ol></li></ol><h2 id="行文结构">行文结构</h2><h3 id="提出问题">提出问题</h3><p>最近的工作主要利用单个或相邻帧中的特征来构建度量损失并授权网络来提取目标的表示。尽管这种策略是有效的，但它未能充分利用整个轨迹中包含的信息。许多具有不同身份的对象由于被遮挡或模糊而与相同的轨迹相关联，从而导致学习的表示无法区分。因此，需要提取更有意义和有区别的表示来提高关联的准确性。</p><h3 id="介绍">介绍</h3><ol type="1"><li>将目标外观向量视为查询，并设计对比损失以使它们更靠近相应的轨迹中心，同时远离其他轨迹中心</li><li>LVS （可学习视图采样）用多个自适应选择的关键点而不是锚点或其 2D中心来表示每个目标。</li></ol><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220520090626497.png" alt="image-20220520090626497" style="zoom:60%;"></p><p>使用LVS方法能够让算法自动地去提取目标未遮挡部分的外观信息。</p><p><em>目标的锚点或 2D 中心被其他对象遮挡，而 LVS仍然可以自适应地关注可见区域。</em></p><ol start="3" type="1"><li>在推理阶段，我们注意到某些帧的目标特征不清楚，不适合表示轨迹。相应地，我们设计了一种相似度引导的特征融合（SGFF）策略，该策略基于历史特征相似度自适应地聚合特征，以减轻这些不良特征对轨迹表示的影响</li></ol><h3 id="可学习视图采样">可学习视图采样</h3><p><strong>基于中心点特征向量表示的缺点：</strong></p><ol type="1"><li>目标中心点可能被其他物体遮挡，此时生成的外观向量无法反应目标的特征</li><li>仅用一个向量表示每个目标无法为对比学习算法提供足够的样本。</li></ol><p>提取方法：首先提取目标中心点的特征向量<span class="math inline">\(v_{c}\)</span>表示目标的外观特征，然后使用一个线性变换层去回归<span class="math inline">\(N_k=9\)</span>个采样点相对于中心点的偏置offset，最后限制所有的采样点均在以<span class="math inline">\(c\)</span>为中心点的目标bbox框内。</p><p>对于采样点坐标提取其对应的特征向量<span class="math inline">\(v_i^{k}\)</span>,经过4层FC之后得到增强后的特征表示<span class="math inline">\(\widetilde{v}_i^k\)</span>。</p><blockquote><p>注：在推理阶段，$N_k$个外观向量被合并为一个单独的向量来表示它们对应的目标。</p></blockquote><h3 id="轨迹中心向量记忆库">轨迹中心(向量)记忆库</h3><p>bank存储的是从开始到目前帧所有轨迹的中心特征向量,如果有<span class="math inline">\(N\)</span>个轨迹,则bank的向量维度为<span class="math inline">\(N\times256\)</span>,(假设一个id-embedding的特征向量是256维)</p><ol type="1"><li><p>开发了一种基于动量的更新策略，在每次迭代中动态更新轨迹中心，而不需要历史梯度信息。</p></li><li><p>收集从具有相同轨迹 ID的实例中提取的所有外观向量，以更新它们对应的轨迹中心</p></li><li><p>利用所有外观特征向量中与中心特征向量余弦相似度最小的(最难学习)来更新中心特征.<span class="math display">\[c_{l} \leftarrow \alpha c_{l}+(1-\alpha) p_{m}^{l}\]</span> <span class="math inline">\(c_l\)</span>表示中心向量,<span class="math inline">\(\alpha=0.2\)</span>表示更新阈值,$ p_{m}^{l}<span class="math inline">\(表示轨迹\)</span>l$中最难学习的一条外观特征.</p></li><li><p>在训练阶段，使用难样本更新轨迹中心有助于提高网络训练的效率。我们的实验结果已经证实了这个问题。</p></li></ol><p>使用InfoNCE loss来监督,使得帧内第<span class="math inline">\(k\)</span>个外观特征<span class="math inline">\(\widetilde{v}_l^k\)</span>,与中心特征<span class="math inline">\(c_l\)</span>更加接近,而与其他轨迹的中心特征<span class="math inline">\(c_{other}\)</span>距离更远. <span class="math display">\[L_{N C E}^{k}=-\log \frac{\exp \left(\tilde{v}_{l}^{k} \cdotc_{l}\right) / \tau}{\sum_{i=0}^{N_{t}} \exp \left(\tilde{v}_{l}^{k}\cdot c_{i}\right) / \tau}\]</span></p><p><span class="math display">\[L_{t c l}=\frac{1}{N_{a}} \sum_{k=1}^{N_{a}} L_{N C E}^{k}\]</span></p><blockquote><p><span class="math inline">\(\tau=0.05\)</span>是一个[0-1]的超参数;<span class="math inline">\(N_t\)</span>表示中心数;<span class="math inline">\(N_a\)</span>表示有LVS确定的外观特征采样点数.</p></blockquote><h3 id="外观特征相似度指导的轨迹融合">外观特征相似度指导的轨迹融合</h3><p>保留轨迹前<span class="math inline">\(Q\)</span>帧的外观特征,然后分别计算当前外观特征与之前外观特征的余弦相似度,得到一个加权值,最后将当前帧的特征融合进去.<span class="math display">\[\beta^{t}=\max \left\{0, \frac{1}{Q} \sum_{i=1}^{Q}\Psi_{d}\left(z_{l}^{t}, z_{l}^{t-i}\right)\right\}\]</span></p><blockquote><p><span class="math inline">\(\Psi_{d}\)</span>表示余弦相似度的计算.,<span class="math inline">\(Q=30\)</span></p></blockquote><p>这种以相似度来更新的有BUG，就是如果之前外观特征学得不好，后面学好了但是却一直无法更新,最后的结果就是越学越差。</p><h2 id="总结">总结</h2><p>  LVS从多个目标位置提取外观特征的做法值得借鉴,但是这样提取的特征不足以鲁棒性的表示目标,文章还使用了额外的4个FC来提取更具判别性的特征,这无疑增加了计算成本,同时提出的相似度指导的特征融合能够使用自适应权重,但是其权重却是通过与之前特征的相似度高低的得来的,这样会造成如果之前特征就学习不好的话,后面学好的特征仍无法更新目标外观模型的情况,个人感觉还不如使用可见度或者采样节点的可见度(或者目标的遮挡度)对外观模型进行加权融合.</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220520110352302.png" alt="image-20220520110352302" style="zoom:50%;"></p>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Multiple People Tracking by Lifted Multicut and Person Re-identiﬁcation</title>
    <link href="/jasonyang.github.io/2022/05/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-LMP/"/>
    <url>/jasonyang.github.io/2022/05/21/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-LMP/</url>
    
    <content type="html"><![CDATA[<h1 id="multiple-people-tracking-by-lifted-multicut-and-person-re-identiﬁcation">MultiplePeople Tracking by Lifted Multicut and Person Re-identiﬁcation</h1><p>原文链接：https://openaccess.thecvf.com/content_cvpr_2017/papers/Tang_Multiple_People_Tracking_CVPR_2017_paper.pdf</p><h2 id="主要工作">主要工作</h2><ol type="1"><li><p>将MCLMP融入到多目标跟踪领域</p><p>  MCLMP（Minimum Cost Lifted MulticutProblem）——最小花费改进多边切割问题，之前这类方法主要用在经典的图像分割领域，以像素点或者像素块作为图节点，为节点之间的每条边分配去切断惩罚（边权重，有正有负），在一定的约束条件下对节点间多余的边进行切割（切断图像块与图像块之间的联系，剩余聚合的图像块便可以看作一个具有相同语义的区域）以最小化惩罚，然后得到聚类结果。这类方法最重要的是通过一些合理的节点连接权重的度量函数，衡量节点之间的关系，然后便是利用一些启发式的算法对图进行切割优化。</p><p>  应用到多目标跟踪领域，作者将图的每个节点等效成视频帧中的每个检测到的目标，同一帧中的目标之间可以彼此相连（这里相连的原因是作者对检测得到的bbox没有进行NMS会有一些重复的框），然后对前后相差<span class="math inline">\(\delta_t\)</span>帧的目标也进行连接（通过中心点距离或者bbox或者外观相似的阈值条件确定），此时的连接都是regularedges，另外还有一点就是通过additionaledges去连接部分外观度量特别相似，然后帧间隔大于<span class="math inline">\(\delta_t\)</span>的目标。边的连接权重或者切断惩罚通过下面的向量计算式得到:<span class="math display">\[\begin{array}{c}c_e=\log \frac{1-p_e}{pe}=-&lt;\theta_{\gamma}, f^{(e)}&gt; \\f^{(e)} \leftarrow \left( f_{st}, f_{dm}, f_{reID}, f_{st}^2,f_{st} \dot\ f_{dm} \dots, \xi_{min}^2\right), \ f^{(e)} \in \cal{R}^{14}\end{array}\]</span> 其中：</p><ul><li><span class="math inline">\(\theta_{\gamma}\)</span>为可学习的映射参数（文中在训练跟踪视频的时候使用了一个LogisticRegression来预测这个参数）</li><li><span class="math inline">\(f_{st}\)</span>代表检测框中心点和高相似度：<span class="math inline">\(f_{st}=\frac{\sqrt{\left(x_{v}-x_{w}\right)^{2}+\left(y_{v}-y_{w}\right)^{2}}}{\bar{h}}\)</span></li><li><span class="math inline">\(f_{dm}\)</span>代表两个目标的关键点集合匹配度（感觉有点儿像交并比），但又不完全是（图1是第一篇用这种DeepMatching的论文：Multipersontracking by multicuts and deep matching）</li><li><span class="math inline">\(f_{reID}\)</span>代表融合目标关键点特征的目标相似度（byStackNetPose），具体怎么融合看主要工作2</li><li><span class="math inline">\(\xi_{min}\)</span>表示两个目标检测置信度中，较小的那个置信度。</li></ul><center><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220516211227565.png" alt="image-20220516211227565" style="zoom:50%;"><br></p><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">图1 Deep Matching 示意图</div></center></li></ol><p>​</p><ol start="2" type="1"><li><p>提出融合人体外观和人体姿态的深度评估网络</p><p>  作者提出了融合深度外观和人体关键点的评估网络名为：StackNetPose。具体做法为，先通过单独的人体关键点检测网络，得到各个关键点（每个行人图像14个points）的响应图（宽高与原图一致），然后融合成7张单通道的heatmap，两张行人图像得到14个heatmap（如下图中绿色部分），之后将这些heatmap与两张行人图像的RGB通道堆叠得到一个拥有20个通道输入的特征图，最后通过一个分类网络评估行人图像之间的相似度。</p></li></ol><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517091655746.png" alt="image-20220517091655746" style="zoom:50%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;         display: inline-block;         color: #999;         padding: 2px;">图2 深度提取网络示意图</div></center><h2 id="mclmp问题建模及约束解释">MCLMP问题建模及约束解释</h2><p>最小花费改进多边切割问题的定义或者用法如第一节所述，下面以一个简单得了例子来表述如何构建一个MCLMP模型。这是一个简单的双向图模型，每条边旁边的数字代表切掉这条表对应的花费或者收益，实线连接的边表示连接（joint），虚线连接的边表示剪掉（cut）。</p><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517092532052.png" alt="image-20220517092532052" style="zoom:30%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;         display: inline-block;         color: #999;         padding: 2px;">图3 连接关系图</div></center><h3 id="问题建模">问题建模</h3><p>MCLMP的规划模型如下：</p><ol type="1"><li><p>目标函数 <span class="math display">\[\min _{x \in\{0,1\} E^{\prime}} \sum_{e \in E^{\prime}} c_{e} x_{e}\]</span></p><blockquote><p>其中<span class="math inline">\(E'\)</span>表示图中所有的边（包括剪掉和连接的，包括regularedges 和 additional edges，additional edges是自己设置的），<span class="math inline">\(c_e\)</span>表示<span class="math inline">\(e\)</span>这条边剪掉所带来的花费，比如上图中<span class="math inline">\(V_1，V_6\)</span>两个节点的弧形连接边，如果将这个边cut，那么将会花费5。<span class="math inline">\(x_e\)</span>表示边的连接状态，<span class="math inline">\(x_e=1\)</span>表示这条边被cut，<span class="math inline">\(x_e=0\)</span>表示这条边是joint。因此对于一个都是joint关系的图，总体的花费都为0，需要cut掉一些产生收益的负权边（如上图的-1，-0.5的这些边）来进一步减少花费。</p></blockquote></li><li><p>约束条件</p><p>约束1： <span class="math display">\[\forall Y \in \operatorname{cycles}(G), \ \  \forall e \in Y: x_{e} \leq\sum_{e^{\prime} \in Y \backslash\{e\}} x_{e^{\prime}}\]</span></p><blockquote><p>直观表述：对任意一个循环连接（cut的虚线边也算作连接，也存在循环连接），循环圈中的每条边的连接状态值，小于等于剩余边连接状态值的之和。通俗解释，一个循环连接，要么就全都是joint的，此时所有的<span class="math inline">\(x_e=0\)</span>，有<span class="math inline">\(0\le0\)</span>，约束成立；要么就要有两条及以上的边是cut的，此时对被cut的边有<span class="math inline">\(1 \le 1+k\)</span>，<span class="math inline">\(k\)</span>为循环连接中cut边数量-2， <span class="math inline">\(k \ge 0\)</span>。</p></blockquote><p>约束2： <span class="math display">\[\forall v w \in E^{\prime} \backslash E , \ \ \forall P \in v w \text{-paths(G) }: x_{v w} \leq \sum_{e \in P} x_{e}\]</span></p><blockquote><p>直观表述：对任意一条additional edges,其任意一条可行的regularedges组成的path（状态为0才能称之为path），path中所有连接边的状态值之和应该大于additionaledges直接连接的状态值。通俗解释：任意一条additionaledges（比如图3中的V1——V6边）状态为joint的前提是存在一个同样为joint的连接通路，这个通路可以是：V1——V2——V3——V6，也可以是：V1——V2——V5——V6，也可以两个都存在。</p></blockquote><p>约束3： <span class="math display">\[\forall v w \in E^{\prime} \backslash E , \ \ \forall C \in vw-\operatorname{cuts}(G): 1-x_{v w} \leq \sum_{e \inC}\left(1-x_{e}\right)\]</span></p><blockquote><p>通俗表述：对任意一条additionaledges（比如图3中的V1——V6边）状态为cut的前提是所有V1——V6的连接通路均不存在一些状态为cut的边，这些通路包括：V1——V2——V3——V6，也可以是：V1——V2——V5——V6，V1——V4——V5——V6，都要有cut边。</p></blockquote></li></ol><p>图例解释：</p><ol type="1"><li>不满足约束（1）</li></ol><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517102134624.png" alt="image-20220517102134624" style="zoom:45%;"></p><p>假设优化剪边后的图连接关系如上，此时对于V1——V2——V5——V4——V1循环，边<span class="math inline">\(x_{12}=1\)</span>，而其余的边<span class="math inline">\(x_{e^{'}}=0\)</span>，因此对于约束（1）<span class="math inline">\(x_{12}=1 \nleq0\)</span>不满足，不是问题的可行解。</p><ol start="2" type="1"><li>不满足约束（2）</li></ol><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517102844176.png" alt="image-20220517102844176" style="zoom:45%;"></p><p>假设优化剪边后的图连接关系如上，此时因为存在V1——V4——V5——V6的path,所以additional edges <span class="math inline">\(x_{16}\)</span>应该为joint状态。</p><ol start="3" type="1"><li><p>不满足约束（3）</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517103152519.png" alt="image-20220517103152519" style="zoom:45%;"></p></li></ol><p>假设优化剪边后的图连接关系如上，此时因为任何一条从V1——V6的通路都带有cut状态的边，因此additionaledges <span class="math inline">\(x_{16}\)</span>应该为cut状态。</p><p>最后放上正确优化后的图结构：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220517103817848.png" alt="image-20220517103817848" style="zoom:40%;"></p><p>此时的多边切割划分为为（-1 + -1 + -1 + -1 =-4），相比原来的花费0，确实更小了。</p><p><strong>相关文献：</strong></p><p>Multi-Person Tracking by Multicut and Deep Matching</p><ul><li><a href="https://arxiv.org/pdf/1608.05404.pdf">Paper</a>;</li></ul><p>Multiple People Tracking by Lifted Multicut and PersonRe-identiﬁcation</p><ul><li><a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Tang_Multiple_People_Tracking_CVPR_2017_paper.pdf">Paper</a></li></ul><p>An Efficient Fusion Move Algorithm for the Minimum Cost LiftedMulticut Problem</p><ul><li><a href="https://hci.iwr.uni-heidelberg.de/sites/default/files/publications/files/1939997197/beier_16_efficient.pdf">Paper</a></li><li><a href="http://www.eccv2016.org/files/posters/O-2A-01.pdf">Poster</a></li><li><a href="http://videolectures.net/site/normal_dl/tag=1078753/eccv2016_beier_efficient_fusion_01.pdf">Lectures&amp;Slides</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>Minimum Cost Lifted Multicut Problem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gaussian Processes for Regression</title>
    <link href="/jasonyang.github.io/2022/05/18/%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B%E5%9B%9E%E5%BD%92%EF%BC%88Gaussian%20Processes%20for%20Regression%EF%BC%89/"/>
    <url>/jasonyang.github.io/2022/05/18/%E9%AB%98%E6%96%AF%E8%BF%87%E7%A8%8B%E5%9B%9E%E5%BD%92%EF%BC%88Gaussian%20Processes%20for%20Regression%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="高斯过程回归gaussian-processes-for-regression">高斯过程回归（GaussianProcesses for Regression）</h1><hr><h2 id="实际问题">实际问题</h2><p>如下图所示，我们已知<span class="math inline">\(x\)</span>在<span class="math inline">\(\left[\begin{array}{llllll} -1.50 &amp; -1.00&amp; -0.75 &amp; -0.40 &amp; -0.25 &amp; 0.00\end{array}\right]\)</span>处的观测值以及他们在这些点处的观测标准差<span class="math inline">\(\sigma_n=0.3\)</span>，如何根据这些已知信息去求得<span class="math inline">\(x_*=0.2\)</span>时，<span class="math inline">\(y_*=?\)</span>。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513113623452.png" alt="image-20220513113623452" style="zoom:35%;"></p><h2 id="问题建模">问题建模</h2><h3 id="确定衡量观测点影响重要程度的协方差函数">确定衡量观测点影响重要程度的协方差函数</h3><p>​ 一般选用径向基函数（RBF）来衡量两个观测点之间的协方差（影响程度）：<span class="math display">\[k\left(x, x^{\prime}\right)=\sigma_{f}^{2} \exp\left[\frac{-\left(x-x^{\prime}\right)^{2}}{2 l^{2}}\right]\]</span></p><blockquote><p><span class="math inline">\(k(x,x')\)</span>表示<span class="math inline">\(x\)</span>与<span class="math inline">\(x'\)</span>之间的协方差，<span class="math inline">\(\sigma_f\)</span>控制影响强度，<span class="math inline">\(l\)</span>控制影响周期。</p></blockquote><h3 id="不同时刻或者位置的观测值">不同时刻或者位置的观测值</h3><p>一个系统或者运动物体在时刻<span class="math inline">\(t\)</span>或者位置<span class="math inline">\(x\)</span>的观测值<span class="math inline">\(y\)</span>有如下计算公式： <span class="math display">\[y=f(x)+\mathcal{N}(0, \sigma_{n}^{2})\]</span></p><blockquote><p><span class="math inline">\(f(.)\)</span>表示依赖或者映射函数，<span class="math inline">\(\mathcal{N}(0,\sigma_{n}^{2})\)</span>表示测量值噪声服从均值为0，方差为<span class="math inline">\(\sigma_{n}^2\)</span>的高斯分布。</p></blockquote><h3 id="融合观测噪声的协方差函数">融合观测噪声的协方差函数</h3><p><span class="math display">\[k\left(x, x^{\prime}\right)=\sigma_{f}^{2} \exp\left[\frac{-\left(x-x^{\prime}\right)^{2}}{2l^{2}}\right]+\sigma_{n}^{2} \delta\left(x, x^{\prime}\right)\]</span></p><blockquote><p><span class="math inline">\(\delta(.)\)</span>表示Kronecker三角函数，当<span class="math inline">\(x=x'\)</span>时，<span class="math inline">\(\delta(x, x')=1\)</span>,其余时候等于0.</p></blockquote><h3 id="根据任意两个观测点计算得到协方差矩阵">根据任意两个观测点计算得到协方差矩阵</h3><p>根据2.3中的协方差函数以及已知观测点的位置<span class="math inline">\(x\)</span>和未知待预测点的位置<span class="math inline">\(x_*\)</span>计算得到以下协方差阵： <span class="math display">\[K=\left[\begin{array}{cccc}k\left(x_{1}, x_{1}\right) &amp; k\left(x_{1}, x_{2}\right) &amp; \cdots&amp; k\left(x_{1}, x_{n}\right) \\k\left(x_{2}, x_{1}\right) &amp; k\left(x_{2}, x_{2}\right) &amp; \cdots&amp; k\left(x_{2}, x_{n}\right) \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\k\left(x_{n}, x_{1}\right) &amp; k\left(x_{n}, x_{2}\right) &amp; \cdots&amp; k\left(x_{n}, x_{n}\right)\end{array}\right]\]</span></p><p><span class="math display">\[K_{*}=\left[\begin{array}{llll}k\left(x_{*}, x_{1}\right) &amp; k\left(x_{*}, x_{2}\right) &amp; \cdots&amp; k\left(x_{*}, x_{n}\right)\end{array}\right] \quad K_{* *}=k\left(x_{*}, x_{*}\right)\]</span></p><blockquote><p><span class="math inline">\(x_1, ...,x_n\)</span>表示已知观测点，<span class="math inline">\(x_*\)</span>表示待预测的点。可以确定的是依据2.3中的公式，矩阵<span class="math inline">\(K\)</span>的对角线元素为<span class="math inline">\(\sigma_f^2 + \sigma_n^2\)</span>。</p></blockquote><h3 id="基于高斯过程和最大后延概率求解待预测值">基于高斯过程和最大后延概率求解待预测值</h3><p>基于之前的关键假设：观测系统是一个高斯过程。所以目前的观测值和待预测值服从一个多元高斯分布：<span class="math display">\[\left[\begin{array}{c}\mathbf{y} \\y_{*}\end{array}\right] \sim\mathcal{N}\left(\mathbf{0},\left[\begin{array}{ll}K &amp; K_{*}^{\mathrm{T}} \\K_{*} &amp; K_{* *}\end{array}\right]\right)\]</span> 现在需要做的是，求得一个待预测的观测值<span class="math inline">\(y_*\)</span>，使得<span class="math inline">\(p(y_*|\mathbf{y})\)</span>的概率最大，换句话说使得<span class="math inline">\(p(y_*|\mathbf{y})\)</span>概率最大的<span class="math inline">\(y_*\)</span>即为所求的最佳高斯过程回归值。</p><p><span class="math inline">\(y_*|\mathbf{y}\)</span>的条件概率服从：<span class="math display">\[y_{*} \mid \mathbf{y} \sim \mathcal{N}\left(K_{*} K^{-1} \mathbf{y},K_{* *}-K_{*} K^{-1} K_{*}^{\mathrm{T}}\right)\]</span> 综上，<span class="math inline">\(y_*\)</span>的最佳估计和估计的方差为： <span class="math display">\[\bar{y}_{*}=K_{*} K^{-1} \mathbf{y}\]</span></p><p><span class="math display">\[\operatorname{var}\left(y_{*}\right)=K_{* *}-K_{*} K^{-1}K_{*}^{\mathrm{T}}\]</span></p><h2 id="例题">例题</h2><p>依据上述第一节的例题，有6个观测点值<span class="math inline">\(x=\left[\begin{array}{llllll}-1.50 &amp; -1.00 &amp; -0.75 &amp; -0.40&amp; -0.25 &amp; 0.00\end{array}\right]\)</span>，同时可以假定<span class="math inline">\(\sigma_n=0.3\)</span>，设定<span class="math inline">\(\sigma_f=1.27,l=1\)</span>，则依据公式（3）（4）（5）得： <span class="math display">\[K=\left[\begin{array}{llllll}1.70 &amp; 1.42 &amp; 1.21 &amp; 0.87 &amp; 0.72 &amp; 0.51 \\1.42 &amp; 1.70 &amp; 1.56 &amp; 1.34 &amp; 1.21 &amp; 0.97 \\1.21 &amp; 1.56 &amp; 1.70 &amp; 1.51 &amp; 1.42 &amp; 1.21 \\0.87 &amp; 1.34 &amp; 1.51 &amp; 1.70 &amp; 1.59 &amp; 1.48 \\0.72 &amp; 1.21 &amp; 1.42 &amp; 1.59 &amp; 1.70 &amp; 1.56 \\0.51 &amp; 0.97 &amp; 1.21 &amp; 1.48 &amp; 1.56 &amp; 1.70\end{array}\right]\\K_{*}=\left[\begin{array}{llllll}0.38 &amp; 0.79 &amp; 1.03 &amp; 1.35 &amp; 1.46 &amp; 1.58\end{array}\right] ,\ \  \    K_{**}=1.70\]</span> 之后依据公式（8）（9）得到： <span class="math display">\[\bar{y}_{*}=0.95 ，\ \  \operatorname{var}\left(y_{*}\right)=0.21\]</span><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513150426202.png" alt="image-20220513150426202" style="zoom:35%;"></p><blockquote><p>图中黑色实线表示GPR预测值，黑色原点表示实际观测值，蓝色点表示在<span class="math inline">\(x=0.2\)</span>处的观测值，红色区域表示95%的置信度区间（<span class="math inline">\(\bar{y}_{*} \pm 1.96\sqrt{\operatorname{var}\left(y_{*}\right)}\)</span>）。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gaussian Processes for Regression</tag>
      
      <tag>回归预测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-YOLO_Pose:Enhancing YOLO for Multi Person Pose Estimation Using Object Keypoint Similarity Loss</title>
    <link href="/jasonyang.github.io/2022/05/17/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-YOLOPose/"/>
    <url>/jasonyang.github.io/2022/05/17/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-YOLOPose/</url>
    
    <content type="html"><![CDATA[<h1 id="yolo-pose-enhancing-yolo-for-multi-person-pose-estimation-using-object-keypoint-similarity-loss">YOLO-Pose:Enhancing YOLO for Multi Person Pose Estimation Using Object KeypointSimilarity Loss</h1><p>原文链接：https://arxiv.org/pdf/2204.06806.pdf</p><h2 id="行文结构">行文结构</h2><h3 id="摘要">摘要</h3><p><strong>目前算法的问题：</strong></p><ol type="1"><li>不是端到端训练，同时无法直接依据姿态检测的指标OKS进行训练，而是使用L1Loss进行替代。</li></ol><p>所提算法允许进行端到端地训练模型并优化 OKS指标本身。所提出的模型学习在单次前向传递中联合检测多人的边界框及其相应的2D 姿势。</p><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525201239786.png" alt="image-20220525201239786" style="zoom:23%;"><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525201313195.png" alt="image-20220525201313195" style="zoom:25%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">算法可视化对比 ：YOLO-pose(左)， HigherHRNetW32（右）</div></center><blockquote><p>上图中HRNet需要先运行一次目标检测网络然后才能对框定的bbox进行姿态估计。</p></blockquote><h3 id="介绍">介绍</h3><p><strong>2D人体姿态估计：</strong>多人 2D姿势估计是理解图像中的人类的任务。给定输入图像，目标是检测每个人并定位他们的身体关节。由于图像中的人数可变、比例变化、身体部位的遮挡、人体的非刚性以及各种其他原因，推断图像中多人的姿势可能具有挑战性。</p><p>提出的姿态估计技术可以很容易地集成到任何运行目标检测的计算机视觉系统中，计算量几乎为零。</p><h3 id="yolo-pose整体结构">YOLO-Pose整体结构</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525204036320.png" alt="image-20220525204036320" style="zoom:50%;"></p><p>就是相当于YOLOv5在之前的bbox分支基础上重新增加了一个Head去回归目标的姿态。整体的预测向量如下：<span class="math display">\[\begin{array}{l}P_{v}=\left\{C_{x}, C_{y}, W, H, \text { box }_{\text {conf }}, \text {class }_{\text {conf }}, K_{x}^{1}, K_{y}^{1}, K_{\text {conf }}^{1},\ldots\right., K_{x}^{n}, K_{y}^{n}, K_{\text {conf }\}}^{n}\end{array}\]</span></p><blockquote><p>其中<span class="math inline">\(n=17\)</span>代表需要预测17个人体关键点，每个关键点由位置<span class="math inline">\(x,y\)</span>和关键点置信度<span class="math inline">\(K_{conf}\)</span>衡量。在推理时保留置信度高于0.5的关键点。</p></blockquote><h4 id="oks损失计算">OKS损失计算</h4><p><span class="math display">\[\begin{aligned}\mathcal{L}_{k p t s}(s, i, j, k) &amp;=1-\sum_{n=1}^{N_{k p t s}} O K S\\&amp;=1-\frac{\sum_{n=1}^{N_{k p t s}} \exp \left(\frac{d_{n}^{2}}{2s^{2} k_{n}^{2}}\right) \delta\left(v_{n}&gt;0\right)}{\sum_{n=1}^{N_{kp t s}} \delta\left(v_{n}&gt;0\right)}\end{aligned}\]</span></p><blockquote><p><span class="math inline">\(d_n\)</span>表示第<span class="math inline">\(n\)</span>个关键点GT与Pred之间的欧氏距离；</p><p><span class="math inline">\(s\)</span>表示目标的尺度（也即anchorbbox的尺度），其他描述又说是目标关键点轮廓的面积；</p><p><span class="math inline">\(k_n\)</span>表示第<span class="math inline">\(n\)</span>个关键点的权重；</p><p><span class="math inline">\(\delta(v_n)\)</span>表示关键点可见度符号函数，当真实可见度<span class="math inline">\(v_n &gt; 0\)</span>时，<span class="math inline">\(\delta(v_n)\)</span>等于1。</p></blockquote><h3 id="sota结果对比">SOTA结果对比</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220526093441077.png" alt="image-20220526093441077" style="zoom:67%;"></p><h3 id="l1-loss和oks-loss的对比分析">L1 Loss和OKS Loss的对比分析</h3><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220526093646961.png" alt="image-20220526093646961" style="zoom: 33%;"></p><h3 id="macs与flops的比较">MACs与FLOPs的比较</h3><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/v2-ec81621db83d2e9216d320410d5a8771_b.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>姿态估计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>YOLO</tag>
      
      <tag>Pose Estimation</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Improving Multiple Object Tracking with Single Object Tracking（SOTMOT）</title>
    <link href="/jasonyang.github.io/2022/05/14/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SOTMOT/"/>
    <url>/jasonyang.github.io/2022/05/14/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SOTMOT/</url>
    
    <content type="html"><![CDATA[<h1 id="improving-multiple-object-tracking-with-single-object-tracking">ImprovingMultiple Object Tracking with Single Object Tracking</h1><p>论文链接：https://openaccess.thecvf.com/content/CVPR2021/papers/Zheng_Improving_Multiple_Object_Tracking_With_Single_Object_Tracking_CVPR_2021_paper.pdf</p><h2 id="摘要">摘要</h2><h3 id="原文">原文</h3><p>​ Despite considerable similarities between multiple object tracking(MOT) and single object tracking (SOT) tasks, modern MOT methods havenot beneﬁted from the development of SOT ones to achieve satisfactoryperformance. The major reason for this situation is that it isinappropriate and inefﬁcient to apply multiple SOT models directly tothe MOT task, although advanced SOT methods are of the strongdiscriminative power and can run at fast speeds.</p><p>​ In this paper, we propose a novel and end-to-end trainable MOTarchitecture that extends CenterNet by adding an SOT branch for trackingobjects in parallel with the existing branch for object detection,allowing the MOT task to beneﬁt from the strong discriminative power ofSOT methods in an effective and efﬁcient way. Unlike most existing SOTmethods which learn to distinguish the target object from its localbackgrounds, the added SOT branch trains a separate SOT model per targetonline to distinguish the target from its surrounding targets, assigningSOT models the novel discrimination. Moreover, similar to the detectionbranch, the SOT branch treats objects as points, making its onlinelearning efﬁcient even if multiple targets are processed simultaneously.Without tricks, the proposed tracker achieves MOTAs of 0.710 and 0.686,IDF1s of 0.719 and 0.714, on MOT17 and MOT20 benchmarks, respectively,while running at 16 FPS on MOT17.</p><h3 id="翻译">翻译</h3><p>  尽管多目标跟踪（MOT）和单目标跟踪（SOT）任务之间有相当大的相似性，但现代MOT方法并没有从SOT任务的发展中获益，从而获得令人满意的性能。出现这种情况的主要原因是，尽管先进的SOT方法具有很强的识别能力，并且可以以很快的速度运行，但直接将多个SOT模型应用于MOT任务是不合适的，也是不充分的。</p><p>  在本文中，我们提出了一种新颖的端到端可培训MOT体系结构，通过添加用于跟踪对象的SOT分支与用于对象检测的现有分支并行，扩展了CenterNet，使MOT任务能够以有效的方式受益于SOT方法的强鉴别能力。与大多数现有的SOT方法不同，SOT方法学习将目标对象与其局部背景区分开来，添加的SOT分支在线为每个目标训练一个单独的SOT模型，以将目标与其周围目标区分开来，从而为SOT模型分配新的区分。此外，与检测分支类似，SOT分支将对象视为点，即使同时处理多个目标，其在线学习也非常有效。在没有技巧的情况下，建议的跟踪器在MOT17和MOT20基准上分别实现了0.710和0.686的MOTA，0.719和0.714的IDF1，同时在MOT17上以16FPS的速度运行。</p><h2 id="总体思路和结构">总体思路和结构</h2><h3 id="总体思路">总体思路</h3><p>  在CenterNet的基础上增加了一个SOTbranch，轨迹（先用卡尔曼滤波预测轨迹在当前帧的虚拟位置）和当前帧的检测利用SOT分支的岭回归权重进行相似度计算，然后利用匈牙利算法进行匹配，同时对于这一轮未匹配上的轨迹<span class="math inline">\(\mathcal{T}_{unmatched}\)</span>，再次利用IoU度量矩阵和匈牙利算法进行二次匹配，仍未匹配的轨迹丢入轨迹暂存池<span class="math inline">\(\mathcal{T}_{pool}\)</span>，仍未匹配的高分检测初始化为新的轨迹。</p><h3 id="网络结构">网络结构</h3><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513210421725.png" alt="image-20220513210421725" style="zoom:33%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">SOTMOT总体结构图</div></center><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220513210835865.png" alt="image-20220513210835865" style="zoom:33%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">单独的SOT Branch示意图</div></center><blockquote><p>注：两帧图像同时输入一个共享权重的网络（其实就是一个网络，进行两次前向传播后再计算损失）仅在Offlinetraining阶段使用，在推理阶段仅需要输入当前帧图像。<span class="math inline">\(EFAC\)</span>就是提取特征图目标中点所有通道的特征；<span class="math inline">\(F\)</span>表示经过3个卷积层再一次提取特征之后的特征图<span class="math inline">\(F \in R^{C_{sot} \times \frac{H}{4} \times\frac{W}{4}}\)</span>。</p></blockquote><h2 id="sot-branch离线训练和在线推理">SOT Branch离线训练和在线推理</h2><h3 id="预备工作">预备工作</h3><ol type="1"><li>根据检测目标彼此之间中心点的位置得到邻接矩阵<span class="math inline">\(A \in R^{N \times N}\)</span>（假设当前检测到<span class="math inline">\(N\)</span>个目标）</li></ol><p><span class="math display">\[\mathbf{A}_{i, j}=\left\{\begin{array}{cc}1 &amp; \text { if } \min\left(\left|x_{i}^{c}-x_{j}^{c}\right|,\left|y_{i}^{c}-y_{j}^{c}\right|\right)\leqslant r \\0 &amp; \text { otherwise }\end{array}\right.\]</span></p><blockquote><p>其中，<span class="math inline">\(x_i^c和y_i^c\)</span>表示第<span class="math inline">\(i\)</span>个目标中心点的坐标，<span class="math inline">\(r\)</span>为距离阈值，文章中取值为75。</p></blockquote><ol start="2" type="1"><li><p>依据邻接矩阵<span class="math inline">\(A\)</span>和第2节中的特征图<span class="math inline">\(F \in R^{C_{sot} \times \frac{H}{4} \times\frac{W}{4}}\)</span>建立每个目标<span class="math inline">\(i\)</span>的邻居特征集合<span class="math inline">\(X_i， i \in [1, ..,N]\)</span>和对应的邻居标签向量<span class="math inline">\(\mathbf{y_i}\)</span> <span class="math display">\[X_i = \text{concat}[\mathbf{x}_j], \ \ \mathbf{x}_{j} =\left\{\mathbf{x}_{j} \mid \forall j: \mathbf{A}_{i, j}=1\right\} \ \X_i \in R^{n_i \times C_{sot}}\\\mathbf{y_i} =[1, 0,0, ..., 0]^{\top}， \mathbf{y_i} \in  R^{n_i \times1}\]</span></p><blockquote><p>其中<span class="math inline">\(\mathbf{x}_j\)</span>表示第<span class="math inline">\(j\)</span>个目标中心点在<span class="math inline">\(F\)</span>中所对应的嵌入特征，<span class="math inline">\(\mathbf{x}_j \in R^{1 \timesC_{sot}}\)</span>;<span class="math inline">\(n_i\)</span>表示第<span class="math inline">\(i\)</span>个目标周围的邻居目标数量，这个邻居包括自己，因此在对应的标签向量<span class="math inline">\(\mathbf{y_i}\)</span>中有且仅有一个位置的值为1.</p></blockquote></li><li><p>建立并求解岭回归（系统辨识）模型</p><p>这里的岭回归感觉就是一个系统辨识，输入是不同目标的特征向量，输出是判定为特定目标的概率。具体建立和求解公式如下：</p><ol type="1"><li><p>建立带正则化的最小化预测误差模型 <span class="math display">\[\min _{\mathbf{w}_{i}}\left\|\mathbf{X}_{i}\mathbf{w}_{i}-\mathbf{y}_{i}\right\|_{2}^{2}+\lambda\left\|\mathbf{w}_{i}\right\|_{2}^{2}\]</span></p><blockquote><p><span class="math inline">\(\mathbf{w}_i\)</span>表示待求解的系统参数，<span class="math inline">\(\lambda\)</span>为正则化参数，文中取值为0.1.</p></blockquote></li><li><p>利用岭回归求解公式解出最优系统参数<span class="math inline">\(\mathbf{w}_i^*\)</span> <span class="math display">\[\mathbf{w}_{i}^{*}=\left(\mathbf{X}_{i}^{\top} \mathbf{X}_{i}+\lambda\mathbf{I}\right)^{-1} \mathbf{X}_{i}^{\top} \mathbf{y}_{i}, \\mathbf{w}_{i}^{*} \in R^{C_{sot} \times 1}\]</span></p></li></ol></li></ol><p>​ 以上便完成了对目标<span class="math inline">\(i\)</span>一致性的度量函数的求解，即有了<span class="math inline">\(\mathbf{w}_i^*\)</span>之后，可以通过<span class="math inline">\(\mathbf{w}_i^*\mathbf{x}_j\)</span>值的大小，判定目标<span class="math inline">\(i,j\)</span>是否为同一目标。</p><h3 id="离线训练sot-branch">离线训练SOT Branch</h3><p>经过上面的推导可以知道，在同一帧中构建目标的邻居节点集合，之后可以给定邻居的标签通过岭回归求解得到映射矩阵<span class="math inline">\(\mathbf{w}_i^*\)</span>，但如何将同一帧计算的结果扩展到不同帧，同时利用网络反向传播，根据预测与真实值的误差增强SOT分支目标中心点特征的提取能力，这就需要利用成对的（前后帧）图像输入，对网络进行离线训练。具体训练流程如下：</p><ol type="1"><li><p>针对<span class="math inline">\(t1\)</span>帧的图像（假设<span class="math inline">\(t1 &lt;t2\)</span>），图像经过带SOT分支的CenterNet网络，得到<span class="math inline">\(N\)</span>个高置信度检测目标（以目标中心点<span class="math inline">\((x_i^c,y_i^c)\)</span>及中心点对应的目标嵌入特征表示<span class="math inline">\(\mathbf{x}_i\)</span>）。</p></li><li><p>依据第3.1节的岭回归模型构建流程，得到<span class="math inline">\(N\)</span>个目标各自的一致性映射矩阵<span class="math inline">\(\left \{ \mathbf{w}_i^* \right\}_{i=1}^{N}\)</span>。</p></li><li><p>针对<span class="math inline">\(t2\)</span>帧的图像，图像同样经过带SOT分支的CenterNet网络，得到<span class="math inline">\(M\)</span>个高置信度检测目标（以目标中心点<span class="math inline">\((x_j^c,y_j^c)\)</span>及中心点对应的目标嵌入特征表示<span class="math inline">\(\mathbf{x}_j\)</span>）。</p></li><li><p>依据公式（1）（2），生成<span class="math inline">\(t2\)</span>帧中每个目标<span class="math inline">\(j\)</span>的邻居中心特征向量集合<span class="math inline">\(X_j^{t2}\)</span>。</p></li><li><p>假设在<span class="math inline">\(t1\)</span>帧中出现的目标有<span class="math inline">\(K\)</span>个同时出现在<span class="math inline">\(t2\)</span>帧中，此时针对这<span class="math inline">\(K\)</span>个相同的目标，在<span class="math inline">\(t1\)</span>帧生成的映射矩阵按理来说同样对<span class="math inline">\(t2\)</span>帧中相同的目标的邻居集作出准确的判断。所以有如下预测公式：<span class="math display">\[\hat{\mathbf{v}}_k=X_k^{t2}\mathbf{w}_k^*, \ k \in K\]</span></p></li><li><p>根据预测和标签值计算SOT预测损失（只针对两帧中同时出现的<span class="math inline">\(K\)</span>个目标）。 <span class="math display">\[\mathcal{L}_{\mathrm{sot}}=\sum_{k=1}^{K}\mathcal{L}_{\mathrm{reg}}\left(\mathbf{v}_{k},\hat{\mathbf{v}}_{k}\right)\\\mathcal{L}_{\mathrm{reg}}(\mathbf{v},\hat{\mathbf{v}})=\left\|\frac{\exp (\mathbf{v})\odot(\mathbf{v}-\hat{\mathbf{v}})}{1+\exp (a\cdot(c-|\mathbf{v}-\hat{\mathbf{v}}|))}\right\|_{2}^{2}\]</span></p><blockquote><p>其中<span class="math inline">\(\odot\)</span>表示同或运算，<span class="math inline">\(a,c\)</span>文章取值为10和0.2.</p></blockquote></li><li><p>根据SOT损失，以及其他检测分支的损失端到端训练SOTMOT网络。</p></li></ol><blockquote><p>这里为什么没有类似于推理的跨帧配对计算损失，是因为跨帧预测标签的指定非常麻烦，不能直接通过距离阈值构建，前一帧每个目标的预测标签都需要两帧之间的身份id来构建，但是理论上可行的。同时还有一个可能的原因是，推理是前后紧密相连的两帧，同时前帧的位置还利用卡尔曼滤波进行了跨帧传播，前后帧目标差距不大，而离线训练的两帧时间间隔比较大，目标的空间位置比较远，无法进行有效衡量。</p></blockquote><h3 id="在线推理">在线推理</h3><p>网络训练完成之后，在线推理阶段只需要输入当前帧的视频图像，然后依据之前的轨迹<span class="math inline">\(i\)</span>为中心，确定半径阈值为<span class="math inline">\(r\)</span>的邻居检测目标集合<span class="math inline">\(Z_i^{det}\)</span>，然后利用轨迹<span class="math inline">\(i\)</span>的映射矩阵$_i^*$，判断当前帧的邻居检测目标与之前轨迹的相似性，以完成跨帧的轨迹传播。</p><h4 id="预测轨迹和检测的相似性">预测轨迹和检测的相似性</h4><ol type="1"><li><p>计算轨迹<span class="math inline">\(k\)</span>的映射矩阵$_k^*$</p><p>这里的计算方法与之前单独每一帧的计算方法有些许不同，因为每个轨迹会保存其从轨迹开始到当前帧的所有结果（<span class="math inline">\(\mathcal{X}_{k}=\left\{\left(\mathbf{X}_{k}^{p},\mathbf{y}_{k}^{p}\right)\right\}_{p=s}^{t-1}\)</span>），所以求解映射矩阵时是最小化轨迹所有观测检测的预测误差得到。假设轨迹<span class="math inline">\(k\)</span>在第<span class="math inline">\(s\)</span>帧初始化，在第<span class="math inline">\(t-1\)</span>帧仍能被观察到，则此时轨迹的映射矩阵应该通过最小化下面这个公式得到：<span class="math display">\[\min _{\mathbf{w}_{k}} \sum_{p=s}^{t-1}\beta^{p}\left\|\mathbf{X}_{k}^{p}\mathbf{w}_{k}-\mathbf{y}_{k}^{p}\right\|_{2}^{2}+\lambda\left\|\mathbf{w}_{k}\right\|_{2}^{2}\]</span></p><blockquote><p><span class="math inline">\(\beta^p\)</span>是轨迹平滑系数，$<sup>{s}=(1-)</sup>{t-s},_{p=s}^{t-1} ^{p}=1， &nbsp;^{p-1} / ^{p}=1-<span class="math inline">\(，其中\)</span>$，该式表示对最新的轨迹观测的预测损失我们应该更加看重。</p></blockquote><p>轨迹<span class="math inline">\(k\)</span>的映射矩阵$_k^* $: <span class="math display">\[\mathbf{w}_{k}^{*}=\left[\sum_{p=s}^{t}\beta^{p}\left(\mathbf{X}_{k}^{p}\right)^{\top}\mathbf{X}_{k}^{p}+\lambda \mathbf{I}\right]^{-1}\left[\sum_{p=s}^{t}\beta^{p}\left(\mathbf{X}_{k}^{p}\right)^{\top}\mathbf{y}_{k}^{p}\right]\]</span></p></li><li><p>利用卡尔曼滤波更新轨迹<span class="math inline">\(k\)</span>在当前帧的位置（<span class="math inline">\(\hat{x}_k^c, \hat{y}_k^c\)</span>）</p></li><li><p>根据轨迹在当前的预测位置（<span class="math inline">\(\hat{x}_k^c,\hat{y}_k^c\)</span>）确定轨迹哪些检测目标是轨迹的邻居（周围目标）</p></li><li><p>提取轨迹周围目标的中心点嵌入特征<span class="math inline">\(\mathbf{x}_j^{det}\)</span>，并根据轨迹的映射矩阵进行相似度预测。</p></li></ol><h4 id="匹配流程">匹配流程</h4><ol type="1"><li>利用预测的轨迹和目标的相似性进行第一轮匹配</li><li>根据轨迹的虚拟位置和检测框的IoU进行第二轮匹配</li><li>将仍未匹配上的轨迹加入缓存池；将仍未匹配上的检测初始化为新轨迹</li></ol><p>通过以上步骤便完成了多个目标的跨帧跟踪。</p><h2 id="总结">总结</h2><p>SOTMOT与FairMOT都有一个专门提取提升的嵌入特征的embeddingHead，但他们的的不同点在于：</p><ol type="1"><li>SOTMOT学习的是如何将目标与周围其他目标区分，FairMOT需要学习将目标与整幅图像中的所有其他目标区分，SOTMOT的学习更具针对性，也更容易收敛。</li><li>SOTMOT每次的映射度量是有一个最优参数估计（岭回归）在里面的，而FairMOT只是单纯运用余弦相似度进行映射。</li></ol><p>最后附上性能对比图：</p><center><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220514111832808.png" alt="image-20220514111832808" style="zoom:50%;"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">private detection</div></center>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>SOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-Detection Recovery in Online Multi-Object Tracking with Sparse Graph Tracker（SGT）</title>
    <link href="/jasonyang.github.io/2022/05/13/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SGT/"/>
    <url>/jasonyang.github.io/2022/05/13/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-SGT/</url>
    
    <content type="html"><![CDATA[<h1 id="detection-recovery-in-online-multi-object-tracking-with-sparse-graph-tracker">DetectionRecovery in Online Multi-Object Tracking with Sparse Graph Tracker</h1><p>论文链接：https://arxiv.org/pdf/2205.00968v1.pdf</p><h2 id="总体结构">总体结构</h2><h3 id="网络总体流程图">网络总体流程图</h3><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220511100109328.png" alt="image-20220511100109328"><figcaption aria-hidden="true">image-20220511100109328</figcaption></figure><h3 id="推理流程">推理流程</h3><ol type="1"><li><p>连续两帧的图片输入到检测网络，提取得到<span class="math inline">\(bboxs^{t1}, embeddings^{t1}\)</span>以及<span class="math inline">\(bboxs^{t2}, embeddings^{t2}\)</span>；</p></li><li><p>根据检测框的前景置信度分数排序，从<span class="math inline">\(t1,t2\)</span>帧中各选取<span class="math inline">\(K\)</span>个候选框（in MOT17，<span class="math inline">\(K=100\)</span>, in MOT 20 , <span class="math inline">\(K=300\)</span>）;</p></li><li><p>添加之前missed tracklets的轨迹信息到<span class="math inline">\(t1\)</span>帧，总共的节点数为：<span class="math inline">\(2K +N_{missed}\)</span>，然后结合节点所处的帧阶段，对这些节点进行连接初始化，具体规则如下：</p><ol type="1"><li>前后帧节点（检测到的候选目标）中心点距离较近——两节点连接</li><li>前后帧节点的外观特征余弦距离较小——连接</li><li>前后帧节点的边框IoU较高——连接</li></ol><p>至此得到一个带链接关系的二向图。</p></li><li><p>初始化节点（node）特征、边（edge）特征。其中节点特征可选用外观特征代替，边特征有两个，分别是<span class="math inline">\(t1 \rightarrow t2\)</span>的边特征和<span class="math inline">\(t2 \rightarrowt1\)</span>的边特征，它们的定义如下: <span class="math display">\[e_{i, j}^{0}=f_{e n c}\left(\left[x_{i}-x_{j}, y_{i}-y_{j}, \log\left(\frac{w_{i}}{w_{j}}\right), \log \left(\frac{h_{i}}{h_{j}}\right),\operatorname{IoU}_{i, j}, \operatorname{Sim}_{i, j}\right]\right)\]</span></p><blockquote><p>其中<span class="math inline">\(f_{enc}\)</span>表示两层FC block，<span class="math inline">\(Sim_{i,j}\)</span>表示两个节点的外观相似度。因为<span class="math inline">\(x_i - x_j\)</span>不等于<span class="math inline">\(x_j -x_i\)</span>所以即使两条边使用相同的（共享权重的）<span class="math inline">\(f_{enc}\)</span>，但是<span class="math inline">\(e_{i,j}^0\)</span>和<span class="math inline">\(e_{j,i}^0\)</span>也不相同。</p></blockquote></li><li><p>节点和边特征更新，更新共有3次即<span class="math inline">\(N_{iter}=3\)</span>，每次更新的公式如下：</p><ol type="1"><li><p>边更新 <span class="math display">\[e_{i, j}^{l}=f_{e}\left(\left[v_{i}^{l-1}, v_{j}^{l-1}, e_{i, j}^{0},e_{i, j}^{l-1}\right]\right)\]</span> 为防止过拟合，每次边更新都有最初的边特征<span class="math inline">\(e_{i,j}^0\)</span>加入；<span class="math inline">\(f_e\)</span>同样表示两层FC block.</p></li><li><p>节点更新 <span class="math display">\[v_{j}^{l}=f_{v_{\text {out }}}\left(\frac{1}{\left|E_{:, j}^{l}\right|}\sum_{i} f_{v_{e n c}}\left(\left[v_{i}^{l-1}, e_{i,j}^{l}\right]\right)\right)\]</span> <span class="math inline">\(|E_{:,j}^{l}|\)</span>表示与节点<span class="math inline">\(j\)</span>所连接的另一帧的节点数量。（帧内节点不连接，帧间节点通过第3点中的3个条件来连接）</p></li></ol></li><li><p>轨迹链接预测和目标可见性预测</p><ol type="1"><li><p>轨迹链接预测</p><p>通过融合两个更新后的边特征（<span class="math inline">\(e_{i,j}^3\)</span>和<span class="math inline">\(e_{j,i}^3\)</span>），文章中说是取平均，然后特征通过一个分类器，得到节点<span class="math inline">\(i,j\)</span>之间的连接度<span class="math inline">\(SE\)</span>，然后依据连接度分数利用匈牙利算法对二分图的连接关系进行指定，保证<span class="math inline">\(t1\)</span>帧的每个节点至多只有一条传播到<span class="math inline">\(t2\)</span>帧的边，然后对于高于阈值<span class="math inline">\(\mathcal{T}_E\)</span>的边，则认为前后帧<span class="math inline">\(i,j\)</span>节点（目标）具有同一ID，以此完成轨迹的向前传播。</p></li><li><p>目标可见性预测</p><p>针对<span class="math inline">\(t2\)</span>帧的节点（目标），利用节点特征通过一个分类器，得到节点的可恢复度<span class="math inline">\(SN\)</span>,当可恢复度低于阈值<span class="math inline">\(\mathcal{T}_N\)</span>时，认为该目标不可恢复，如果该节点已被<span class="math inline">\(t1\)</span>帧的节点连接，则此时将他们的连接删除，该节点对应的目标在<span class="math inline">\(t2\)</span>帧也不会出现。</p></li></ol></li><li><p>旧轨迹终止和新轨迹初始化</p><ol type="1"><li><p>旧轨迹终止</p><p>当一个轨迹(这个轨迹在之前至少被连续跟踪了<span class="math inline">\(min_{age}=10\)</span>帧)暂时未通过连接预测进行帧间传播时，轨迹被加入<span class="math inline">\(\mathcal{T}_{missed}\)</span>,并持续跟踪<span class="math inline">\(max_{age}=30\)</span>帧，以保证长时期long-term的数据关联。但如果超过30帧轨迹仍未能从每次的<span class="math inline">\(t2\)</span>帧中找到匹配的检测框，则将这段轨迹移出轨迹暂存池<span class="math inline">\(\mathcal{T}_{pool} = \mathcal{T}_{active} +\mathcal{T}_{missed}\)</span></p></li><li><p>新轨迹初始化</p><p>对于第一帧和第二帧的前向传播情况，如果前后两帧有节点保持了连接则为他们分配唯一的ID，然后对于第二帧和第三帧的前向传播，因为第二帧的一些节点已经分配了ID，若这些节点能够与第三帧的节点相连接，则与其连接的第三帧的节点共享其ID，如果第二帧中未分配ID的节点与第三帧的节点相连接，则重新为它们分配一个额外的唯一的ID。</p><blockquote><p>注：具体是不是两帧连接就初始化轨迹，文章里面貌似也没说，上面的流程只代表一种可行的新轨迹初始化方案。</p></blockquote></li></ol></li><li><p>（轨迹外观模型更新的小trick）</p><p>文章中使用轨迹当前的检测置信度分数对轨迹的外观特征进行自适应加权更新，更新公式如下：<span class="math display">\[e m b_{t 2}^{t r k}=e m b_{t 1}^{t r k} \times \frac{S_{t 1}}{S_{t1}+S_{t 2}}+e m b_{t 2}^{d e t} \times \frac{S_{t 2}}{S_{t 1}+S_{t 2}}\]</span></p><blockquote><p>上述公式表明，对于已分配ID的轨迹的节点特征，是融合了上一次前后两帧关联后<span class="math inline">\(t2\)</span>帧对应节点的外观特征的结果。</p></blockquote></li></ol><h3 id="损失设计">损失设计</h3><h4 id="检测损失">检测损失</h4><p>依据CenterNet的损失设计，不过作者将CenterNet中预测<span class="math inline">\(w,h\)</span>的回归Head，改为预测从中心点到<span class="math inline">\(left,right,top,bottem\)</span>四条边的距离的回归head。</p><h4 id="关联损失">关联损失</h4><p><span class="math display">\[\mathcal{L}_{A}=w_{e d g e} \mathcal{L}_{e d g e}+w_{n o d e}\mathcal{L}_{n o d e}\]</span></p><ol type="1"><li><p>边连接预测损失 <span class="math display">\[\mathcal{L}_{\text {edge }}=\frac{1}{N_{E}+} \sum_{e_{i, j} \inE}\left\{\begin{array}{ll}\operatorname{FL}\left(E S_{i, j}, e y_{i, j}\right), &amp; \text { if }n y_{i}=1 \text { or } n y_{j}=1 \\0 &amp; \text { otherwise }\end{array}\right.\]</span> <span class="math inline">\(N_E+\)</span>表示GT边的数量，GT边表示至少有一个节点是GT节点的边；<span class="math inline">\(FL(.)\)</span>表示Focal Loss; <span class="math inline">\(ny_j=1\)</span>表示节点<span class="math inline">\(j\)</span>对应的目标是真实目标。</p></li><li><p>节点可恢复度预测损失 <span class="math display">\[\mathcal{L}_{n o d e}=\frac{1}{N_{N_{t 2}^{+}}} \sum_{n_{j} \in N_{t 2}}\operatorname{FL}\left(N S_{j}, n y_{j}\right)\]</span> <span class="math inline">\(N_{N_{t2}^+}\)</span>表示<span class="math inline">\(t2\)</span>帧中是真实目标的节点（nodes matching GTin T2 frame ）的数量。</p></li></ol><h4 id="gt框的指定">GT框的指定</h4><p>类似于DETR，利用匈牙利算法基于预测框与GT框的IoU分数来为预测框分配GT。</p><h2 id="总结">总结</h2><p>总的来说这篇文章就是通过前后两帧的检测结果，通过构建一个二向连接图，并衡量前后帧检测结果之间的连接关系来完成轨迹的前后帧传播，好处就是可以将轨迹关联的训练损失可以直接设计为分类预测损失，还有一个点就是使用了前<span class="math inline">\(K\)</span>个固定的检测框，以求恢复一些轨迹。之前的算法中恢复轨迹的做法有两种：</p><ol type="1"><li>OMC：使用之前轨迹的特征嵌入在当前帧特征embedding上做互相关，得到轨迹响应极点，并结合当前帧目标框检测结果，恢复轨迹；</li><li>ByteTrack：直接对低分检测框和未匹配上的轨迹利用IoU进行二次匹配，恢复轨迹。</li></ol><p>最后，看似整个网络没有使用额外的数据关联或者匹配，实则在每两帧之间生成鲁棒性的节点预测时同样使用了匈牙利算法进行最大化连接度匹配，且最后的效果也没有特别好。</p><p><strong>最后放上Paper with Code上面的MOT17，MOT20的排名：</strong></p><ul><li><p>MOT 17</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220511144541094.png"></p></li><li><p>MOT 20</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220511144634459.png" alt="image-20220511144634459"><figcaption aria-hidden="true">image-20220511144634459</figcaption></figure></li></ul><p>​</p><p>​</p>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>GNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阅读笔记-DanceTrack:Multi-Object Tracking in Uniform Appearance and Diverse Motion</title>
    <link href="/jasonyang.github.io/2022/05/12/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-DanceTrack/"/>
    <url>/jasonyang.github.io/2022/05/12/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-DanceTrack/</url>
    
    <content type="html"><![CDATA[<h1 id="dancetrack-multi-object-tracking-in-uniform-appearance-and-diverse-motion">DanceTrack:Multi-Object Tracking in Uniform Appearance and Diverse Motion</h1><p>原文链接：https://arxiv.org/pdf/2111.14690.pdf</p><h2 id="行文结构">行文结构</h2><p><strong>DanceTrack数据集的特点：</strong></p><ol type="1"><li><p>统一外观：人类具有高度相似且几乎没有区别的外观。</p></li><li><p>多样的运动：它们具有复杂的运动模式和相互作用。</p><blockquote><p>具有频繁的相对位置切换和遮挡。</p></blockquote></li></ol><h3 id="摘要">摘要</h3><p>现有跟踪数据集中的偏差，其中大多数对象往往具有可区分的外观，因此使用re-ID模型足以建立关联，但是当对象外观没有足够的辨别力时，多目标跟踪方法也应该起作用。期待后来的一些算法能够<strong>更少依赖于视觉辨别，更多地依赖于运动分析。</strong></p><h3 id="介绍">介绍</h3><p>现有多目标跟踪数据集的局限性，并观察到许多目标具有不同的外观，并且目标的运动模式非常规则甚至是线性的。最近开发的多目标跟踪算法高度依赖外观匹配来关联检测到的对象，同时几乎不考虑其他线索。</p><p>DanceTrack数据集：</p><ol type="1"><li>该数据集包含超过 100K 的图像帧（几乎是 MOT17 数据集的 10 倍）；</li><li>外观一致：视频中的人穿着非常相似甚至相同的衣服，使得他们的视觉特征很难被re-ID 模型区分；</li><li>多样化运动：人们通常有非常大范围的运动和复杂的身体姿态变化，对运动建模提出了更高的要求。第二个属性也带来了遮挡和交叉作为副作用，即人体彼此重叠的比例很大，并且它们的相对位置经常交换。</li></ol><p>一些对更好的实现DanceTrack上的关联结果有益的结论：</p><ol type="1"><li>目标的细粒度表示，例如分割和姿势，表现出比粗边界框更好的能力；<ol type="1"><li>是否可以融合姿势度量相似度，文末尝试了融合OKS相似度确实带来了很大的提升。</li></ol></li><li>尽管我们正在解决二维跟踪任务，但深度信息显示出对关联对象的积极影响；</li><li>时间动力学的运动建模很重要。</li></ol><h3 id="dancetrack数据集">DanceTrack数据集</h3><p>DanceTrack数据集与MOT17、MOT20的比较：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525145804749.png" alt="image-20220525145804749" style="zoom:50%;"></p><h4 id="数据集构建">数据集构建</h4><p>通过简单地增加感兴趣对象的密度来关注“人群”并不是我们所期望的，MOT20包含行人非常拥挤的视频。但由于行人的运动非常规律，相对位置和遮挡区域保持一致，这样的“人群”并没有为外观匹配设置障碍。</p><p>对于部分被遮挡的对象，标注了一个全身框。<strong>对于完全被遮挡的物体，我们不标注</strong>；当它在未来的帧中重新出现时，它的标识符id在可见时与前一帧保持相同。</p><p>厉害呀，啥工具。标注工具可以自动将注释框从前一帧传播到当前帧，而注释器只需要对当前帧中的框进行细化。</p><h4 id="数据集统计">数据集统计</h4><p>训练集40个，验证集25个，测试集35个。并且在数据集拆分过程中，我们在平均长度、平均边界框数、包含场景和运动多样性方面保持子集的分布接近。</p><p>一些具有挑战性的场景：</p><ol type="1"><li>低光照和远距离相机</li><li>Group Dance，最多40人</li><li>体操比赛视频：极其多样化的身体姿势、频繁的姿势变化和复杂的运动模式。</li></ol><p>目标之间的外观相似度、相邻帧的重叠IoU、目标中心的相对位置切换在不用数据集上的比较：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525151644078.png" alt="image-20220525151644078" style="zoom:67%;"></p><h4 id="数据集的性能评价指标">数据集的性能评价指标</h4><p>HOTA：综合指标</p><p>AssA、IDF1：衡量关联性能</p><p>DetA、MOTA：衡量检测性能</p><h4 id="当前工作的局限">当前工作的局限</h4><ol type="1"><li>考虑到上述动机和建议的数据集，我们没有提供一种高度优于以前的多目标跟踪算法的算法，但将其作为未来研究的一个悬而未决的问题。</li><li>我们在这项工作中强调的情况，人体姿势或分割掩码的注释对于更细粒度的研究应该很重要。但受限于时间和资源，我们在这个版本中只提供了边界框的标注。</li></ol><h3 id="对比实验分析">对比实验分析</h3><p>CenterTrack论文中提供了一种MOT17训练集拆分为训练集和验证集的方法。</p><h4 id="oracle-analysisgt关联分析">Oracle Analysis（GT关联分析）</h4><p>用具有不同关联算法的GT边界框来实现预期的算法上限性能。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525152911459.png" alt="image-20220525152911459" style="zoom:67%;"></p><blockquote><p>从结果来看，就 MOT17 上的所有指标而言，跟踪输出接近完美。而且，有趣的是，仅使用 IoU 匹配可以获得最佳性能，这证明 MOT17包含具有简单和规则运动模式的对象，并且在大多数情况下瓶颈不在于关联。在DanceTrack上同样最佳性能仅在于IoU匹配，即使结合线性运动模型或附加外观信息也无济于事。当使用外观相似性时，所有指标都比不使用任何外观提示要差。</p></blockquote><p>MOT17和DanceTrack数据集目标外观特征Tt-SNE聚类可视化</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525153305733.png" alt="image-20220525153305733" style="zoom:33%;"></p><p><strong>GT分析结论：现有数据集存在严重偏差，更多地关注检测质量，并且所涉及的简单轨迹模式限制了该领域的研究。相反，DanceTrack对开发具有提高关联能力的多对象跟踪器提出了更高的要求。</strong></p><h4 id="目前先进算法在dancetrack上的表现">目前先进算法在DanceTrack上的表现</h4><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525153730867.png" alt="image-20220525153730867" style="zoom:67%;"></p><blockquote><p>检测不是在 DanceTrack上具有良好跟踪性能的瓶颈，如何针对目标的统一外观和多样化运动建立稳健的关联才是。</p></blockquote><h4 id="不同关联算法在dancetrack数据集上的性能比较">不同关联算法在DanceTrack数据集上的性能比较</h4><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525154132253.png" alt="image-20220525154132253" style="zoom: 40%;"></p><blockquote><p>以上关联方法均是基于YOLOX的检测结果。</p></blockquote><h4 id="多任务融合学习分析">多任务融合学习分析</h4><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525154922769.png" alt="image-20220525154922769" style="zoom:67%;"></p><ol type="1"><li><p>融合COCO目标mask监督</p><p>训练数据是 DanceTrack 训练集和 COCO Mask的组合。 如果输入图像来自DanceTrack，我们将其 mask loss 设置为 0。在推理过程中，匹配度量是bounding box IoU 和 mask IoU的加权和。<em>但是从图中看联合训练之后只用bbox匹配就可以达到很好的效果了呀</em></p></li><li><p>融合COCO目标pose监督</p><p>训练数据是 DanceTrack 训练集和 COCO 人体姿势 [24] 的组合。如果输入图像来自 DanceTrack，我们将其位姿损失设置为0。在推理过程中，匹配度量是边界框 IoU 和对象关键点相似度 (OKS)的加权和。</p><blockquote><p>当人体的大部分区域已经被遮挡时，分割模型通常不能提供可靠的输出，而专注于某些人体关键点的姿态估计模型通常表现出更高的鲁棒性。</p></blockquote></li><li><p>融合深度信息</p><p>和KITII数据集中的车辆数据一起训练，有较大的域Gap，因此造成了性能下降；感觉深度信息和姿态信息都是能用的。</p></li><li><p>融合运动模型的作用</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220525160839057.png" alt="image-20220525160839057" style="zoom:40%;"></p><blockquote><p>使用弱监督学习来估计其他模式（深度、遮罩掩膜、姿态估计）</p></blockquote></li></ol><h2 id="储备知识">储备知识</h2><ol type="1"><li>有度量关键点相似度的算法：Object Keypoint Similarity(OKS)（COCO数据集里面提供的）</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文总结</category>
      
      <category>多目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT 数据集</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日积月累：02.移除元素</title>
    <link href="/jasonyang.github.io/2022/04/07/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A02.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/"/>
    <url>/jasonyang.github.io/2022/04/07/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A02.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="leetcode日积月累02.移除元素">LeetCode日积月累：02.移除元素</h2><p>根据<strong>代码随想录</strong>的讲解顺序开始打卡学习，闲时更新。</p><blockquote><p>代码随想录：https://www.programmercarl.com/0027.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0.html#_27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0</p><p>LeetCode练习题目：https://leetcode-cn.com/problems/remove-element/</p></blockquote><h3 id="题目描述">题目描述</h3><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 原地移除所有数值等于 <code>val</code> 的元素，并返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须仅使用 <code>O(1)</code> 额外空间并<strong>原地修改输入数组</strong>。</p><p>元素的<strong>顺序可以改变</strong>。你不需要考虑数组中超出新长度后面的元素。</p><p><strong>示例</strong></p><figure class="highlight nix"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">nums</span> = [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], <span class="hljs-attr">val</span> = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">2</span>, <span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">2</span>, 并且 nums 中的前两个元素均为 <span class="hljs-number">2</span>。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 <span class="hljs-number">2</span> ，而 <span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>] 或 <span class="hljs-attr">nums</span> = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]，也会被视作正确答案。<br></code></pre></td></tr></tbody></table></figure><figure class="highlight dns"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">0,1,2,2</span>,<span class="hljs-number">3,0,4,2</span>], val = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span>, nums = [<span class="hljs-number">0,1,4,0</span>,<span class="hljs-number">3</span>]<br>解释：函数应该返回新的长度 <span class="hljs-number">5</span>, 并且 nums 中的前五个元素为 <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。<br><br></code></pre></td></tr></tbody></table></figure><h3 id="解决方案own">解决方案（own）</h3><p>借本想法是建立前、后两个指针，前指针从前往后判断元素是否是移除，在发现需要移除的值后，后指针从后往前遍历寻找不等于val的元素，然后交换这两个指针对应的元素值。整个程序在前指针大于后指针时停止。算法总共只需遍历一次数组元素，时间复杂度为O(n)。</p><blockquote><p>每次前后指针找到待移除元素时，数组总长度-1；该方法会改变删除后输出数组元素的相对位置。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeElement</span>(<span class="hljs-params">self, nums, val</span>):</span><br>        <span class="hljs-string">"""</span><br><span class="hljs-string">        :type nums: List[int]</span><br><span class="hljs-string">        :type val: int</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        """</span><br><br>        <span class="hljs-comment">## own solution</span><br>        l = <span class="hljs-built_in">len</span>(nums)<br>        left_idx, right_idx = <span class="hljs-number">0</span>, l-<span class="hljs-number">1</span><br>        temp = <span class="hljs-literal">None</span><br>        <span class="hljs-keyword">while</span> left_idx &lt;= right_idx:<br>            <span class="hljs-keyword">if</span> nums[left_idx] == val:<br>                l -= <span class="hljs-number">1</span><br>                <span class="hljs-keyword">while</span> nums[right_idx] == val <span class="hljs-keyword">and</span> left_idx &lt; right_idx :<br>                    right_idx -= <span class="hljs-number">1</span><br>                    l -= <span class="hljs-number">1</span><br>                temp = nums[left_idx]<br>                nums[left_idx] = nums[right_idx]<br>                nums[right_idx] = temp<br>                right_idx -= <span class="hljs-number">1</span><br>            left_idx += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> l<br></code></pre></td></tr></tbody></table></figure><h3 id="解决方案others">解决方案（others）</h3><p>双指针法（快慢指针法）：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/008eGmZEly1gntrds6r59g30du09mnpd.gif" alt="27.移除元素-双指针法"><figcaption aria-hidden="true">27.移除元素-双指针法</figcaption></figure><p>快慢指针均从前往后遍历，当快指针遇到待删除元素时，慢指针暂停移动，快指针继续遍历，直到遇到非删除元素，然后将快指针对应的值赋值到慢指针所在位置，赋值后慢指针和快指针继续移动，最终到快指针遍历结束，此时慢指针的位置则为移除val后的数组长度。</p><blockquote><p>因为是顺序遍历，最后输出的数组元素之间的相对位置与删除前一致。</p></blockquote><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-string">"""双指针法</span><br><span class="hljs-string">    时间复杂度：O(n)</span><br><span class="hljs-string">    空间复杂度：O(1)</span><br><span class="hljs-string">    """</span><br><br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">removeElement</span>(<span class="hljs-params">cls, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], val: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        fast = slow = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">while</span> fast &lt; <span class="hljs-built_in">len</span>(nums):<br><br>            <span class="hljs-keyword">if</span> nums[fast] != val:<br>                nums[slow] = nums[fast]<br>                slow += <span class="hljs-number">1</span><br><br>            <span class="hljs-comment"># 当 fast 指针遇到要删除的元素时停止赋值</span><br>            <span class="hljs-comment"># slow 指针停止移动, fast 指针继续前进</span><br>            fast += <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">return</span> slow<br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Inverted residuals block、Shufflenet block的Pytorch实现</title>
    <link href="/jasonyang.github.io/2022/04/03/Inverted%20residuals%20block%E3%80%81Shufflenet%20block%E7%9A%84Pytorch%E5%AE%9E%E7%8E%B0/"/>
    <url>/jasonyang.github.io/2022/04/03/Inverted%20residuals%20block%E3%80%81Shufflenet%20block%E7%9A%84Pytorch%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="inverted-residuals-blockshufflenet-block的pytorch实现">Invertedresiduals block、Shufflenet block的Pytorch实现</h2><hr><h3 id="目前卷积的三种实现方式">0. 目前卷积的三种实现方式：</h3><hr><blockquote><p>图源：https://blog.csdn.net/tintinetmilou/article/details/81607721</p></blockquote><p><strong>Basic Convolution</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403121056332.png" alt="image-20220403121056332"><figcaption aria-hidden="true">image-20220403121056332</figcaption></figure><p><strong>Depthwise Convolution</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403121110773.png" alt="image-20220403121110773"><figcaption aria-hidden="true">image-20220403121110773</figcaption></figure><p><strong>Pointwise Convolution</strong></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403121125095.png" alt="image-20220403121125095"><figcaption aria-hidden="true">image-20220403121125095</figcaption></figure><h3 id="mobilenet-v2">1. MobileNet v2</h3><hr><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403112515368.png" alt="image-20220403112515368"><figcaption aria-hidden="true">image-20220403112515368</figcaption></figure><p>MobileNetv2采用先升维度再降维度的方法，先将通道维度上升到原来的<code>t</code>倍，然后进行<code>depthwise conv</code>，最后再通过<code>1x1 conv</code>将通道数为恢复到原来维度。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/201911131056046.png" alt="在这里插入图片描述"><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220402161527672.png" alt="image-20220402161527672" style="zoom:50%;"></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mobilev2_block</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, out_channels, ratio=<span class="hljs-number">6</span>, stride=<span class="hljs-number">1</span></span>):</span><br><span class="hljs-built_in">super</span>(mobilev2_block, self).__init__()<br>self.in_channels = in_channels<br>self.out_channels = out_channels<br>self.stride = stride<br>self.ratio = ratio<br><br><span class="hljs-keyword">if</span> stride == <span class="hljs-number">1</span>:<br><span class="hljs-keyword">assert</span> out_channels == in_channels, <span class="hljs-string">"Under the stride=1 input and output channel number should be equal."</span><br>mid_channels = in_channels*ratio<br>self.branch = nn.Sequential(<br>nn.Conv2d(in_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(mid_channels),<br>nn.ReLU6(inplace=<span class="hljs-literal">True</span>),<br><br>nn.Conv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">3</span>, stride=stride, padding=<span class="hljs-number">1</span>, groups=mid_channels, bias=<span class="hljs-literal">False</span>),<br><br>nn.Conv2d(mid_channels, out_channels, kernel_size=<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(out_channels),<br>nn.ReLU6(inplace=<span class="hljs-literal">True</span>),<br><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br><span class="hljs-keyword">if</span> self.stride == <span class="hljs-number">1</span>:<br>x = x + self.branch(x)<br><span class="hljs-keyword">elif</span> self.stride == <span class="hljs-number">2</span>:<br>x = self.branch(x)<br><span class="hljs-keyword">return</span> x<br><br>fake_data = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">32</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>)<br>net = mobilev2_block(in_channels=<span class="hljs-number">32</span>, out_channels=<span class="hljs-number">64</span>, stride=<span class="hljs-number">2</span>)<br><span class="hljs-built_in">print</span>(net(fake_data).size())<br></code></pre></td></tr></tbody></table></figure><h3 id="shufflenet-v2">2. ShuffleNet v2</h3><hr><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220403111217519.png" alt="image-20220403111217519"><figcaption aria-hidden="true">image-20220403111217519</figcaption></figure><p>上图右边两个结构是shufflenetv2的基础残差块，<code>图（c）</code>的输入和输出的特征图完全一致：<code>NxCxHxW-&gt;NxCxHxW</code>；<code>图（d）</code>输入和输出的特征图宽高变为原来的<code>1/2</code>，同时通道数可以为之前的<code>1,2,3</code>倍。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicConv2d</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, out_channels, **kwargs</span>):</span><br><span class="hljs-built_in">super</span>(BasicConv2d, self).__init__()<br>self.conv = nn.Conv2d(in_channels, out_channels, bias=<span class="hljs-literal">False</span>, **kwargs)<br>self.bn = nn.BatchNorm2d(out_channels, eps=<span class="hljs-number">0.001</span>)<br>self.relu = nn.ReLU(inplace=<span class="hljs-literal">True</span>) <span class="hljs-comment"># 不确定是ReLU还是relu6</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>x = self.conv(x)<br>x = self.bn(x)<br><br><span class="hljs-keyword">return</span> self.relu(x)<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Identity_layer</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-string">"""</span><br><span class="hljs-string">恒等映射</span><br><span class="hljs-string">"""</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br><span class="hljs-built_in">super</span>(Identity_layer, self).__init__()<br><span class="hljs-keyword">pass</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br><span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">shufflev2_block</span>(<span class="hljs-params">nn.Module</span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, in_channels, out_channels, mode=<span class="hljs-number">1</span>, group=<span class="hljs-number">2</span></span>):</span><br><span class="hljs-built_in">super</span>(shufflev2_block, self).__init__()<br>self.group = group<br>self.in_channels = in_channels<br>self.mode = mode<br>self.out_channels = out_channels<br><br><span class="hljs-comment"># HxW-&gt;HxW</span><br><span class="hljs-keyword">if</span> self.mode == <span class="hljs-number">1</span>: <br><span class="hljs-keyword">assert</span> in_channels == out_channels, <span class="hljs-string">"Under the MODE 1 input and output channel number should be equal."</span><br>mid_channels = self.in_channels // group<br>self.branch1 = Identity_layer()<br>self.branch2 = nn.Sequential(<br><span class="hljs-comment"># pw</span><br>BasicConv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>),<br><span class="hljs-comment"># dw</span><br>nn.Conv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">1</span>, padding=<span class="hljs-number">1</span>, groups=mid_channels, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(mid_channels),<br><span class="hljs-comment"># pw linner</span><br>BasicConv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>)<br>)<br><span class="hljs-comment"># HxW-&gt;H/2xW/2</span><br><span class="hljs-keyword">elif</span> mode == <span class="hljs-number">2</span>:<br>mid_channels = self.out_channels // group<br>self.branch1 = nn.Sequential(<br><span class="hljs-comment"># dw</span><br>nn.Conv2d(self.in_channels, self.in_channels, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>, groups=self.in_channels, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(self.in_channels),<br><span class="hljs-comment"># pw linner</span><br>BasicConv2d(self.in_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>)<br><br>)<br>self.branch2 = nn.Sequential(<br><span class="hljs-comment"># pw</span><br>BasicConv2d(self.in_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>),<br><span class="hljs-comment"># dw</span><br>nn.Conv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>, padding=<span class="hljs-number">1</span>, groups=mid_channels, bias=<span class="hljs-literal">False</span>),<br>nn.BatchNorm2d(mid_channels),<br><span class="hljs-comment"># pw linner</span><br>BasicConv2d(mid_channels, mid_channels, kernel_size=<span class="hljs-number">1</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br><span class="hljs-keyword">if</span> self.mode == <span class="hljs-number">1</span>:<br>channel_per_group = self.in_channels // self.group<br>x = torch.cat([self.branch1(x[:, :channel_per_group]), self.branch2(x[:, channel_per_group:])], dim=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">elif</span> self.mode == <span class="hljs-number">2</span>:<br>x = torch.cat([self.branch1(x), self.branch2(x)], dim=<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> self._shuffle(x)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_shuffle</span>(<span class="hljs-params">self, x</span>):</span><br>channel = x.size(<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 随机切换通道排序</span><br>shuffle_list = random.sample(<span class="hljs-built_in">range</span>(channel), channel)<br><span class="hljs-keyword">return</span> x[:, shuffle_list]<br><br><br>fake_data = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">512</span>, <span class="hljs-number">128</span>, <span class="hljs-number">128</span>)<br>net = shufflev2_block(in_channels=<span class="hljs-number">512</span>, out_channels=<span class="hljs-number">512</span>, mode=<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(net(fake_data).size())<br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>可以通过nn.conv2d()内部的<code>groups</code>参数轻松进行depthwiseconv操作。</p></blockquote><h3 id="参考">参考</h3><hr><p>【知乎】《轻量化神经网络综述》：https://zhuanlan.zhihu.com/p/45496826</p><p>【CSDN】Depthwise卷积与Pointwise卷积:https://blog.csdn.net/tintinetmilou/article/details/81607721</p><p>【GitHub】<a href="https://github.com/ericsun99/Shufflenet-v2-Pytorch">Shufflenet-v2-Pytorch</a></p><p>【Arxiv】<a href="https://arxiv.org/pdf/1807.11164.pdf">ShuffleNetV2: Practical Guidelines for Efficient CNN Architecture Design</a></p><p>【Arxiv】<a href="https://arxiv.org/pdf/1801.04381.pdf">MobileNetV2:Inverted Residuals and Linear Bottlenecks</a></p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>轻量化卷积神经网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python argparse 使用</title>
    <link href="/jasonyang.github.io/2022/04/01/Python%20argparse%20%E4%BD%BF%E7%94%A8/"/>
    <url>/jasonyang.github.io/2022/04/01/Python%20argparse%20%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="python-argparse-使用">Python argparse 使用</h2><hr><blockquote><p>搬运自：<a href="https://geek-docs.com/python/python-tutorial/python-argparse.html">极客教程——Pythonargparse 教程</a></p></blockquote><h3 id="基本使用">1. 基本使用</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse <span class="hljs-comment"># 导入模块</span><br> <br>parser = argparse.ArgumentParser() <span class="hljs-comment"># 初始化一个参数解析器</span><br><br><span class="hljs-comment"># 向参数解析器添加 track-buffer 参数 -buffer 和 --track-buffer分别表示参数的短名和长名</span><br><span class="hljs-comment"># track-buffer 参数可传入的数据的类型是int型，参数的默认值是30（如果没传入的话）</span><br><span class="hljs-comment"># help='tracking buffer'——阐述这个参数的含义</span><br>parser.add_argument(<span class="hljs-string">'-buffer'</span>,<span class="hljs-string">'--track-buffer'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">30</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'tracking buffer'</span>)<br>parser.add_argument(<span class="hljs-string">'--input-video'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">'test_video.flv'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'path to the input video'</span>)<br><br><span class="hljs-comment"># output-format参数只有['video', 'text']两个值可以选择，不传入时默认为video</span><br>parser.add_argument(<span class="hljs-string">'--output-format'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">'video'</span>, choices=[<span class="hljs-string">'video'</span>, <span class="hljs-string">'text'</span>], <span class="hljs-built_in">help</span>=<span class="hljs-string">'Expected output format. Video or text.'</span>)<br>parser.add_argument(<span class="hljs-string">'--output-root'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, default=<span class="hljs-string">'results'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">'expected output root path'</span>)<br><br>args = parser.parse_args() <span class="hljs-comment"># 获取解析器中的所有参数，</span><br><span class="hljs-built_in">print</span>(args)<br><br><span class="hljs-comment">## 运行示例1</span><br><span class="hljs-comment"># python argparse_use.py</span><br><span class="hljs-comment"># out:</span><br><span class="hljs-comment"># Namespace(input_video='test_video.flv', output_format='video', output_root='results', track_buffer=30)</span><br><br><span class="hljs-comment">## 运行示例2</span><br><span class="hljs-comment"># python argparse_use.py -buffer 50 --output-format text</span><br><span class="hljs-comment"># out:</span><br><span class="hljs-comment"># Namespace(input_video='test_video.flv', output_format='text', output_root='results', track_buffer=50)</span><br><br></code></pre></td></tr></tbody></table></figure><h3 id="add_argument中的其他功能函数方法">2.add_argument()中的其他功能函数（方法）</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># argparse_use.py</span><br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment"># required arg</span><br><br><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-comment"># help flag provides flag help</span><br><span class="hljs-comment"># store_true actions stores argument as True</span><br><br>parser = argparse.ArgumentParser() <span class="hljs-comment"># 初始化一个参数解析器</span><br><br><span class="hljs-comment"># 向参数解析器添加 output 参数 -o 和 --output分别表示参数的短名和长名</span><br><span class="hljs-comment"># action='store_true'——表示这个参数在终端不调用时默认为false；如果终端调用了output参数则为true</span><br><span class="hljs-comment"># help="shows output"——表示output参数的介绍信息（作用）</span><br>parser.add_argument(<span class="hljs-string">'-o'</span>, <span class="hljs-string">'--output'</span>, action=<span class="hljs-string">'store_true'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"shows output"</span>)<br><br><span class="hljs-comment"># 向参数解析器添加 name 参数</span><br><span class="hljs-comment"># required=True——表示在运行.py文件时需要显式的为参数name传入对应的值，例如：python argparse_use.py --name jason</span><br>parser.add_argument(<span class="hljs-string">'--name'</span>, required=<span class="hljs-literal">True</span>) <br><br><span class="hljs-comment"># 向参数解析器添加 n 参数</span><br><span class="hljs-comment"># dest='now'——为n参数起了一个别名叫做now，以后可以通过args.now来获取到args.n的值</span><br>parser.add_argument(<span class="hljs-string">'-n'</span>, dest=<span class="hljs-string">'now'</span>, action=<span class="hljs-string">'store_true'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"shows now"</span>)<br><br><span class="hljs-comment"># type=int——n参数能接收传入的值为的数据类型是 int, 其余解释同上</span><br>parser.add_argument(<span class="hljs-string">'-n'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, required=<span class="hljs-literal">True</span>, <br>    <span class="hljs-built_in">help</span>=<span class="hljs-string">"define the number of random integers"</span>)<br><br><span class="hljs-comment"># default=2——e参数在终端运行时如果没有传入对应值的话，默认值为2</span><br>parser.add_argument(<span class="hljs-string">'-e'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, default=<span class="hljs-number">2</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"defines the exponent value"</span>)<br><br><span class="hljs-comment"># metavar='value'——简要介绍v参数表示value并会在帮助的输出中显示，注意这个和dest起别名的区别</span><br>parser.add_argument(<span class="hljs-string">'-v'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, required=<span class="hljs-literal">True</span>, metavar=<span class="hljs-string">'value'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"computes cube for the given value"</span>)<br><br><span class="hljs-comment"># action='append'——表示name参数或者n参数可以通过终端多次传入，然后先后执行不同的传入</span><br><span class="hljs-comment"># exp:python argparse_use.py --name jason -n yang --name he</span><br><span class="hljs-comment"># 先执行python argparse_use.py --name jason；然后再执行python argparse_use.py --name yang</span><br>parser.add_argument(<span class="hljs-string">'-n'</span>, <span class="hljs-string">'--name'</span>, dest=<span class="hljs-string">'names'</span>, action=<span class="hljs-string">'append'</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">"provides names to greet"</span>)<br><br><span class="hljs-comment"># nargs=2——表示chars参数可以在一次传入中接收2个值，然后得到一个列表</span><br><span class="hljs-comment"># exp:python argparse_use.py --chars a b c</span><br><span class="hljs-comment"># 此时args.chars=['a', 'b' 'c']</span><br>parser.add_argument(<span class="hljs-string">'--chars'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">str</span>, nargs=<span class="hljs-number">2</span>, metavar=<span class="hljs-string">'c'</span>,<span class="hljs-built_in">help</span>=<span class="hljs-string">'starting and ending character'</span>)<br><br><span class="hljs-comment"># nargs='*'——表示num参数可以在一次传入中接收多个值，然后得到一个列表</span><br>parser.add_argument(<span class="hljs-string">'num'</span>, <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>, nargs=<span class="hljs-string">'*'</span>)<br><br><span class="hljs-comment"># choices=['std', 'iso', 'unix', 'tz']——表示now参数在传入相应值时只能选择['std', 'iso', 'unix', 'tz']之中的一个</span><br>parser.add_argument(<span class="hljs-string">'--now'</span>, dest=<span class="hljs-string">'format'</span>, choices=[<span class="hljs-string">'std'</span>, <span class="hljs-string">'iso'</span>, <span class="hljs-string">'unix'</span>, <span class="hljs-string">'tz'</span>],<br>                    <span class="hljs-built_in">help</span>=<span class="hljs-string">"shows datetime in given format"</span>)<br><br>args = parser.parse_args() <span class="hljs-comment"># 获取解析器中的所有参数，</span><br><br><span class="hljs-built_in">print</span>(args)<br></code></pre></td></tr></tbody></table></figure><blockquote><p>PS: 以上这些add_argument中的功能函数或者方法都可以叠加使用。</p><p>PS2:上面在创建参数时有些用了相同的参数名，这只是方便，实际使用中不能使用相同的参数名。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>04. Pytorch中WeightedRandomSampler()的使用</title>
    <link href="/jasonyang.github.io/2022/03/31/04.%20Pytorch%E4%B8%ADWeightedRandomSampler()%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/jasonyang.github.io/2022/03/31/04.%20Pytorch%E4%B8%ADWeightedRandomSampler()%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="pytorch中weightedrandomsampler的使用">04.Pytorch中WeightedRandomSampler()的使用</h2><hr><p>针对一些样本类别不均衡数据集，可使用加权的随机采样器平衡各类样本被采样（抽取）训练的概率，缓和偏向预测。### 1. 加权随机采样器简介</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220329232206466.png" alt="image-20220329232206466"><figcaption aria-hidden="true">image-20220329232206466</figcaption></figure><p>参数介绍：</p><ul><li><code>weights:</code>每个样本的采样权重（注意是每个样本），是一个长度为<code>N</code>的<code>list</code>，<code>N</code>为数据集中的样本总个数。</li><li><code>num_samples:</code>需要采样的样本个数。</li><li><code>replacement:</code>是否可以重采样，如果可以重采样则<code>num_samples</code>可以大于<code>N</code>；否则<code>num_samples &lt;= N</code>，且当<code>num_samples=N</code>时采样权重失效。</li><li><code>generator:</code>用于生成采样器的生成器，一般不指定。</li></ul><h3 id="使用示例">2. 使用示例</h3><p>为了阐述<code>WeightedRandomSampler()</code>的工作原理，首先简单创建一个<code>dataset</code>。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">'''</span><br><span class="hljs-string">创建简易数据集</span><br><span class="hljs-string">'''</span><br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">My_dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.data = torch.randn(<span class="hljs-number">10</span>, <span class="hljs-number">3</span>, <span class="hljs-number">256</span>, <span class="hljs-number">256</span>) <span class="hljs-comment"># 生成虚拟图像数据</span><br>        self.labels = torch.randint(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">10</span>]) <span class="hljs-comment"># 生层虚拟数据的label</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-keyword">return</span> self.data[idx], self.labels[idx], idx<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> self.data.size(<span class="hljs-number">0</span>)<br>  <br></code></pre></td></tr></tbody></table></figure><p>上面创建了一个简易的数据集，里面只有10个（虚假）的图像数据，接下来将结合这个数据集类展示<code>WeightedRandomSampler()</code>来的用法。</p><h4 id="生成采样索引">2.1 生成采样索引</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">import</span> torch<br><br>weights = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>] <span class="hljs-comment"># 10个样本各自的采样权重</span><br>sampler = data.WeightedRandomSampler(weights, num_samples=<span class="hljs-number">20</span>, replacement=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(sampler))<br><span class="hljs-comment">### out</span><br><span class="hljs-comment"># 因为最后一个样本的采样权重比较大，所以采样得到样本索引大多数都是最后一个样本</span><br><span class="hljs-comment"># [9, 9, 1, 9, 9, 9, 4, 9, 4, 3, 4, 9, 0, 9, 2, 9, 9, 9, 7, 9] </span><br><br>weights = [<span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] <span class="hljs-comment"># 10个样本各自的采样权重</span><br>sampler = data.WeightedRandomSampler(weights, num_samples=<span class="hljs-number">20</span>, replacement=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">list</span>(sampler))<br><span class="hljs-comment">### out</span><br><span class="hljs-comment"># 同理，因为第一个样本的采样权重比较大，所以采样得到样本索引大多数都是第一个样本</span><br><span class="hljs-comment"># [0, 0, 4, 7, 4, 0, 1, 0, 0, 4, 0, 0, 3, 6, 3, 0, 0, 8, 0, 0]</span><br><br></code></pre></td></tr></tbody></table></figure><blockquote><p>当<code>replacement=False</code>时，各个样本的索引只能被采样一次，且当<code>num_samples=N</code>时，输出的采样样本就是原始数据集。</p></blockquote><h4 id="结合dataset演示">2.2 结合<code>dataset</code>演示</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">import</span> torch<br><br>weights = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">9</span>] <span class="hljs-comment"># 10个样本各自的采样权重</span><br>sampler = data.WeightedRandomSampler(weights, num_samples=<span class="hljs-number">20</span>, replacement=<span class="hljs-literal">True</span>)<br>my_dataset = My_dataset()<br>my_dataloader = data.DataLoader(my_dataset, batch_size=<span class="hljs-number">10</span>, sampler=sampler)<br><span class="hljs-keyword">for</span> (data, label, index) <span class="hljs-keyword">in</span> my_dataloader:<br>    <span class="hljs-built_in">print</span>(index)<br><br><span class="hljs-comment">### out</span><br><span class="hljs-comment"># tensor([1, 9, 8, 8, 9, 3, 1, 9, 4, 9])</span><br><span class="hljs-comment"># tensor([9, 9, 0, 3, 9, 9, 5, 9, 7, 9])</span><br></code></pre></td></tr></tbody></table></figure><p>加入<code>sampler</code>之后，<code>dataloader</code>在每次加载的数据样本就会依据采样的样本索引去获取对应索引样本的数据，以达到平衡不同类别的样本数量。</p>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>dataset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>别人所理解的卡尔曼滤波</title>
    <link href="/jasonyang.github.io/2022/03/30/%E5%88%AB%E4%BA%BA%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    <url>/jasonyang.github.io/2022/03/30/%E5%88%AB%E4%BA%BA%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="别人所理解的卡尔曼滤波">别人所理解的卡尔曼滤波</h2><p>摘录一些其他博主所讲解的卡尔曼滤波器文章</p><hr><h3 id="how-a-kalman-filter-works-in-pictures">1. How a Kalman filterworks, in pictures</h3><p>【Bzarg】《How a Kalman filter works, inpictures》：http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/</p><hr><p>卡尔曼滤波更新公式：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330152427883.png" alt="image-20220330152427883"><figcaption aria-hidden="true">image-20220330152427883</figcaption></figure><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330152526716.png" alt="image-20220330152526716"><figcaption aria-hidden="true">image-20220330152526716</figcaption></figure><p>博主绘制的卡尔曼滤波更新过程：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330152621011.png" alt="image-20220330152621011"><figcaption aria-hidden="true">image-20220330152621011</figcaption></figure><h3 id="bilibili-dr_can博主更新的卡尔曼滤波系列教程">2. bilibiliDR_CAN博主更新的卡尔曼滤波系列教程</h3><p>【DR_CAN】《KalmanFilter_全网最详细数学推导》：https://space.bilibili.com/230105574/channel/collectiondetail?sid=6939</p><hr><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220330153127035.png" alt="image-20220330153127035"><figcaption aria-hidden="true">image-20220330153127035</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>目标跟踪</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
      <tag>Kalman filter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日积月累：01.二分查找</title>
    <link href="/jasonyang.github.io/2022/03/26/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/jasonyang.github.io/2022/03/26/LeetCode%E6%97%A5%E7%A7%AF%E6%9C%88%E7%B4%AF%EF%BC%9A01.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="leetcode日积月累01.二分查找">LeetCode日积月累：01.二分查找</h3><p>根据<strong>代码随想录</strong>的讲解顺序开始打卡学习，闲时更新。</p><blockquote><p>代码随想录：https://www.programmercarl.com/0704.二分查找.html#_704-二分查找</p><p>LeetCode练习题目：https://leetcode-cn.com/problems/binary-search/</p></blockquote><h4 id="题目描述">题目描述</h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回-1。</p><p><strong>示例</strong></p><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 9</span><br><span class="hljs-section">输出: 4</span><br><span class="hljs-section">解释: 9 出现在 nums 中并且下标为 4</span><br></code></pre></td></tr></tbody></table></figure><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">输入: nums = [-1,0,3,5,9,12], target = 2</span><br><span class="hljs-section">输出: -1</span><br><span class="hljs-section">解释: 2 不存在 nums 中因此返回 -1</span><br></code></pre></td></tr></tbody></table></figure><h4 id="解决方案">解决方案</h4><p>注意选取的指针列表是左闭右开区间（<code>[left, right)</code>）还是闭区间（<code>[left, right]</code>）。-<code>[left, right)</code>：则当<code>nums[middle] &gt; target</code>时，<code>right = middle</code>因为右端是开，middle是取不到的刚好也是开.-<code>[left, right]</code>：则当<code>nums[middle] &gt; target</code>时，<code>right = middle - 1</code>因为右端是闭区间，而<code>nums[middle]</code>已经大于<code>target</code>,<code>middle-1</code>才是可以取到.</p><ol type="1"><li>[left, right]版本</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, nums: <span class="hljs-type">List</span>[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:</span><br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">while</span> left &lt;= right:<br>            middle = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle - <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>[left, right)版本</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">search</span>(<span class="hljs-params">self, nums, target</span>):</span><br>        left, right = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) <span class="hljs-comment"># 半开区间</span><br><br>        <span class="hljs-keyword">while</span> left &lt; right: <span class="hljs-comment"># left不能取到right</span><br>            middle = (left + right) // <span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> nums[middle] &gt; target:<br>                right = middle<br>            <span class="hljs-keyword">elif</span> nums[middle] &lt; target:<br>                left = middle + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">return</span> middle<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></tbody></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Python 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>03. Pytorch中model eval和torch no grad()的区别</title>
    <link href="/jasonyang.github.io/2022/03/17/03.%20pytorch%E4%B8%ADmodel%20eval%E5%92%8Ctorch%20no%20grad()%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/jasonyang.github.io/2022/03/17/03.%20pytorch%E4%B8%ADmodel%20eval%E5%92%8Ctorch%20no%20grad()%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="pytorch中model-eval和torch-no-grad的区别">03. pytorch中modeleval和torch no grad()的区别</h2><p>原博文连接如下：<a href="https://blog.csdn.net/songyu0120/article/details/103884586?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164748615916780269889584%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164748615916780269889584&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-1-103884586.142%5Ev2%5Epc_search_result_cache,143%5Ev4%5Econtrol&amp;utm_term=model.eval%28%29%E5%92%8Ctorch.no_grad%28%29&amp;spm=1018.2226.3001.4187">CSDN:pytorch中model eval和torch no grad()的区别</a></p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220317110919631.png" alt="image-20220317110919631"><figcaption aria-hidden="true">image-20220317110919631</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>train and test model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何查找会议论文开会地和出版地</title>
    <link href="/jasonyang.github.io/2022/03/13/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87%E5%BC%80%E4%BC%9A%E5%9C%B0%E5%92%8C%E5%87%BA%E7%89%88%E5%9C%B0/"/>
    <url>/jasonyang.github.io/2022/03/13/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BE%E4%BC%9A%E8%AE%AE%E8%AE%BA%E6%96%87%E5%BC%80%E4%BC%9A%E5%9C%B0%E5%92%8C%E5%87%BA%E7%89%88%E5%9C%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="如何查找会议论文开会地和出版地">如何查找会议论文开会地和出版地</h2><hr><p>国内一些期刊要求会议论文的参考文献必须得明确论文的出版地（or开会地）和出版商，而直接用googlescholar搜索论文得到的引用格式由通常没有出版地信息，上网搜索了一波，整理了一下其他博主的方案归纳如下。</p><p>会议论文的一般引用格式：</p><figure class="highlight prolog"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prolog">［序号］作者．题名[<span class="hljs-symbol">A</span>]．论文集名[<span class="hljs-symbol">C</span>]．出版地：出版社,出版年：起-止页码.<br></code></pre></td></tr></tbody></table></figure><p>示例：</p><figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[19]</span> WANG Zhong-dao, ZHENG Liang, LIU Yi-xuan, et al. Towards real-<span class="hljs-selector-tag">time</span> multi-<span class="hljs-selector-tag">object</span> tracking<span class="hljs-selector-attr">[C]</span><span class="hljs-comment">// European Conference on Computer Vision. Cham: Springer, 2020: 107-122.</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>无论英文还是中文作者姓名一律<code>姓前名后</code>，有些期刊可能会要求完整的姓名拼音（如示例），根据具体期刊要求修改即可。</p></blockquote><h3 id="首先使用中文google-scholar镜像站搜索对应论文得到一个基本的国标引用格式">1.首先使用中文GoogleScholar镜像站搜索对应论文，得到一个基本的国标引用格式。</h3><hr><blockquote><p>注：如果直接用Google scholar搜索的话，在导出文献引用时会没有<code>GB/T 7714</code>格式。</p></blockquote><p><strong>Google Scholar镜像站:</strong> http://scholar.scqylaw.com/进入后随便点击一个访问链接，并搜索需要引用的论文，这里以<code>YOLO:You only look once</code>为例。复制<code>GB/T 7714</code>的引用文本。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326112911647.png" alt="image-20220326112911647"><figcaption aria-hidden="true">image-20220326112911647</figcaption></figure><p>这里得到引文通常是没有出版地和出版商的，需要进入我们的主线任务：<strong>如何查看会议论文的出版地和出版商。</strong></p><h3 id="查看会议论文的出版地和出版商">2.查看会议论文的出版地和出版商</h3><hr><blockquote><p>常用的几个出版商和出版地：</p></blockquote><table><thead><tr class="header"><th>出版商</th><th>出版地</th></tr></thead><tbody><tr class="odd"><td>IEEE</td><td>Piscataway, NJ</td></tr><tr class="even"><td>IEEE Computer Society</td><td>Los Alamitos, CA</td></tr><tr class="odd"><td>IEEE Communications Society</td><td>New York, NY</td></tr><tr class="even"><td>AAAI Press</td><td>Palo Alto, CA</td></tr><tr class="odd"><td>Springer</td><td>Berlin, German</td></tr></tbody></table><p>查询的网址主要有两个：</p><p><strong>Web of science 检索:</strong>https://www.webofscience.com/wos/woscc/basic-search</p><p><strong>EI检索：</strong>https://www.engineeringvillage.com/search/quick.url</p><blockquote><p>记得一定断掉代理，否则网站无法通过ip地址识别你是校园机构用户。</p></blockquote><h4 id="web-of-science-检索">2.1 Web of science 检索</h4><blockquote><p><strong>Web of science 检索:</strong>https://www.webofscience.com/wos/woscc/basic-search</p></blockquote><p>还是同样的以<code>YOLO:You only look once</code>为例，输入文章名点击检索，找到对应文章并点击进入（红框）。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326140131358.png" alt="image-20220326140131358"><figcaption aria-hidden="true">image-20220326140131358</figcaption></figure><p>然后就可以看到以下信息：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326140643347.png" alt="image-20220326140643347"><figcaption aria-hidden="true">image-20220326140643347</figcaption></figure><p>继续往下翻阅可以看到出版商和出版地：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326140820268.png" alt="image-20220326140820268"><figcaption aria-hidden="true">image-20220326140820268</figcaption></figure><p>最后综合GoogleScholar镜像中导出的<code>GB\T</code>引文和<code>web of science</code>查到的出版地，<code>YOLO</code>会议论文的参考文献格式如下：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Redmon J, Divvala S, Girshick R, et al. You <span class="hljs-keyword">only</span> look once: Unified, <span class="hljs-type">real</span>-<span class="hljs-type">time</span> <span class="hljs-keyword">object</span> detection[C]//Proceedings <span class="hljs-keyword">of</span> the IEEE conference <span class="hljs-keyword">on</span> computer vision <span class="hljs-keyword">and</span> pattern recognition. <span class="hljs-built_in">New</span> York:IEEE,<span class="hljs-number">2016</span>: <span class="hljs-number">779</span><span class="hljs-number">-788.</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>不确定最后的归属州<code>NY</code>需不需要添加，按理说只需要填写到具体城市就可以了，酌情参考。</p></blockquote><h4 id="ei检索">2.2 EI检索</h4><blockquote><p><strong>EI检索：</strong>https://www.engineeringvillage.com/search/quick.url</p></blockquote><p>用在检索页面的最上方输入文章名，找到对应文章，进入后点击<code>Detailed</code>。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326141705520.png" alt="image-20220326141705520"><figcaption aria-hidden="true">image-20220326141705520</figcaption></figure><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326141846669.png" alt="image-20220326141846669"><figcaption aria-hidden="true">image-20220326141846669</figcaption></figure><p>进入后就可以到该会议论文的<code>出版时间，论文集，出版商，出版地，页码</code>等详细信息。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220326142338284.png" alt="image-20220326142338284"><figcaption aria-hidden="true">image-20220326142338284</figcaption></figure><blockquote><p>一般EI检索和Web ofscience检索出来的出版商会不一样，感觉EI检索的更规范一些，建议先用EI检索查找出版商，如果没找到对应论文再用webof science。</p></blockquote><p>最后综合之前的引文得到最终<code>YOLO</code>参考文献的格式为：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Redmon J, Divvala S, Girshick R, et al. You <span class="hljs-keyword">only</span> look once: Unified, <span class="hljs-type">real</span>-<span class="hljs-type">time</span> <span class="hljs-keyword">object</span> detection[C]//Proceedings <span class="hljs-keyword">of</span> the IEEE conference <span class="hljs-keyword">on</span> computer vision <span class="hljs-keyword">and</span> pattern recognition. Los Alamitos:IEEE Computer Society, <span class="hljs-number">2016</span>: <span class="hljs-number">779</span><span class="hljs-number">-788.</span><br></code></pre></td></tr></tbody></table></figure><h3 id="主要参考">主要参考：</h3><p>【知乎】：<a href="https://zhuanlan.zhihu.com/p/96910701">《参考文献[出版地: 出版社] 检索方法》</a></p><p>【CSDN】：<a href="https://blog.csdn.net/JaysonRen/article/details/121794249">《深度学习顶会：CVPR、ICCV、ECCV历年举办地点[2015~2021]》</a></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>参考文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里云+frp实现内网穿透</title>
    <link href="/jasonyang.github.io/2022/03/10/%E9%98%BF%E9%87%8C%E4%BA%91+frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/jasonyang.github.io/2022/03/10/%E9%98%BF%E9%87%8C%E4%BA%91+frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云frp实现内网穿透">阿里云+frp实现内网穿透</h2><blockquote><p>最近更新：2022年10月10日10:39:12</p></blockquote><h3 id="云服务器购买">1. 云服务器购买</h3><hr><p>随便买一个就行，主要是需要服务的一个公网ip。（点击<code>立即购买</code>默认创建即可，操作系统可选<code>CentOS</code>）</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104116564.png" alt="image-20220310104116564" style="zoom:50%;"></p><h3 id="查看实例并开启远程连接">2. 查看实例并开启远程连接</h3><hr><p>点击<code>云服务器ECS-&gt;实例</code>进入实例管理界面，大概长这样：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104745377.png" alt="image-20220310104745377"><figcaption aria-hidden="true">image-20220310104745377</figcaption></figure><p>然后点击实例右边的<code>远程连接</code>打开服务器的控制终端。</p><blockquote><p>建议开启免密登陆，监控调试很方便。</p></blockquote><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104926368.png" alt="image-20220310104926368" style="zoom: 67%;"></p><p>点击打开后能够看到如下界面：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310105510245.png" alt="image-20220310105510245"><figcaption aria-hidden="true">image-20220310105510245</figcaption></figure><h3 id="在阿里云服务器下载frp相关文件">3.在阿里云服务器下载frp相关文件</h3><hr><p><strong>frp 是一个专注于内网穿透的高性能的反向代理应用，支持TCP、UDP、HTTP、HTTPS等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP节点的中转暴露到公网。</strong></p><blockquote><p>frp下载页面地址：https://github.com/fatedier/frp/releases</p><p>frp官方示例文档：https://gofrp.org/docs</p></blockquote><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310105731938.png" alt="image-20220310105731938" style="zoom:67%;"></p><p>选择这里的<code>linux_amd64</code>版本，然后鼠标放上面右键选择<code>复制链接地址</code>，之后切换回之前阿里云的终端控制台，使用<code>wget</code>指令下载frp文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/fatedier/frp/releases/download/v0.39.1/frp_0.39.1_linux_amd64.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>解压文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf  frp_0.39.1_linux_amd64.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>然后<code>cd</code>进入<code>frp_0.39.1_linux_amd64</code>目录，输入<code>ls</code>可以看到以下文件：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310110547047.png" alt="image-20220310110547047"><figcaption aria-hidden="true">image-20220310110547047</figcaption></figure><p><strong>文件解释：</strong></p><ul><li><code>frpc</code>——frp在客户端运行的文件，也就是需要穿透的内网环境下的主机需要运行的文件，与阿里云服务器这边无关可以删除。</li><li><code>frpc.ini</code>——frp客户端的配置文件，用于定义一些监听和转发端口啥的。</li><li><code>frps</code>——frp在服务器端运行的文件，这需要在阿里云服务器上运行。</li><li><code>frps.ini</code>——frp服务器端的配置文件。</li><li><code>systemd</code>——用于配置让frp服务一直在后台运行的文件，后面会讲。</li></ul><h3 id="开放阿里云服务器端口并设置frp后台运行">4.开放阿里云服务器端口，并设置frp后台运行。</h3><hr><h4 id="回到阿里云云服务器ecs-实例界面然后点击右侧的安全组点击默认的安全组进行配置管理">4.1回到阿里云“云服务器ECS-&gt;实例”界面，然后点击右侧的<code>安全组</code>，点击默认的安全组进行配置管理。</h4><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310112455190.png" alt="image-20220310112455190"><figcaption aria-hidden="true">image-20220310112455190</figcaption></figure><p>手动添加入端口，比如我添加了这几个，一般添加两个端口就行</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310112545443.png" alt="image-20220310112545443" style="zoom:67%;"></p><h4 id="回到云服务器的控制台查看修改并运行frps程序">4.2回到云服务器的控制台，查看、修改并运行<code>frps</code>程序。</h4><p><code>frps.ini</code>里面的内容如下：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span> <br></code></pre></td></tr></tbody></table></figure><blockquote><p>注意：7000是默认绑定的端口，这个端口与你自己开放的入端口的其中一个得对应，不然一会儿客户无法访问。</p></blockquote><p>然后执行下面的语句服务器端程序就运行了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前台启动</span><br>./frps -c ./frps.ini   <br> <br><span class="hljs-comment"># 后台启动（正常使用后推荐后台启动）</span><br>nohup ./frps -c ./frps.ini &amp;<br></code></pre></td></tr></tbody></table></figure><p>一般情况下后台启动已经能够满足正常要求，只要你的云服务器没有关机，程序就一直在运行，但是如果关机之后就得需要打开云服务器的控制终端重新运行一下<code>frps</code>程序。能不能让<code>frps</code>程序开机自启动，不用每次关机后手动打开呢？<code>systemd</code>文件就是用来干这件事儿的。</p><h4 id="使用-systemd-管理-frp-服务">4.3 使用 systemd 管理 frp 服务</h4><blockquote><p>下面部分基本<code>ctrl + C V</code>知乎<code>linux 技术栈</code>的文章，原文链接如下：</p><p>《使用 systemd 管理 frp 服务》:https://zhuanlan.zhihu.com/p/382950791</p></blockquote><ol type="1"><li><strong>systemd 服务单元</strong></li></ol><p>systemd 拥有 11个单元类型，分别是：服务(service)、套接字(socket)、设备(device)、挂载点(mount)、自动挂载点(automount)、启动目标(target)、交换分区或交换文件(swap)、被监视的路径(path)、任务计划(timer)、资源控制组(slice)、一组外部创建的进程(scope)。</p><p>其中，服务单元是以 <code>.service</code>为后缀的单元文件，封装了一个被 <code>systemd</code>监视与控制的进程。</p><p>服务的单元文件包括三个部分：<code>[Service]</code>、<code>[Unit]</code>和 <code>[Install]</code>。</p><p>在 GitHub 上下载的 frp 压缩包中已经包含了对应 frpc 和 frps 的服务的<strong>单元文件</strong>和<strong>单元模板文件</strong>。下面我们将分别讲解基于单元文件和基于单元模板文件进行管理frps 服务（frpc 服务类似）。</p><ol start="2" type="1"><li><strong>基于单元文件管理 frps 服务</strong></li></ol><p>我们先使用 frps 的单元文件（<code>frps.service</code>）进行管理 frps服务。我们先看一下 <code>frps.service</code> 的文件内容：</p><blockquote><p>进入阿里云服务器控制终端界面<code>cd systemd</code>，然后<code>cat frps.service</code>可以看到如下内容。</p></blockquote><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310141256842.png" alt="image-20220310141256842"><figcaption aria-hidden="true">image-20220310141256842</figcaption></figure><p>下面是参数解释：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Frp Server Service <span class="hljs-comment"># 服务描述</span><br><span class="hljs-attr">After</span>=network.target <span class="hljs-comment"># frps 将会在 network.service 启动完毕之后再启动</span><br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple <span class="hljs-comment"># 不论进程是否启动成功，systemctl start 都执行成功</span><br><span class="hljs-attr">User</span>=nobody <span class="hljs-comment"># 设置进程在执行时使用的用户</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure <span class="hljs-comment"># on-failure 表示仅在服务进程异常退出时重启</span><br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s <span class="hljs-comment"># 设置在重启服务前暂停多长时间</span><br><span class="hljs-attr">ExecStart</span>=/usr/bin/frps -c /etc/frp/frps.ini <span class="hljs-comment"># 在启动该服务时需要执行的命令行</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target <span class="hljs-comment"># 用于 systemctl enable 时创建软连接</span><br></code></pre></td></tr></tbody></table></figure><p>重点只需要关注<code>ExecStart</code>，这里面是该服务的执行命令，其实也就是我们之前手动启动的命令行语句。接下来有两种更改方式：</p><ul><li>更改<code>ExecStart</code>中命令语句的执行路径，因为<code>bin</code>文件内是没有<code>frps</code>程序的</li><li>将<code>frps</code>和<code>frps.ini</code>移入到指定<code>bin</code>和<code>etc/frp</code>目录。</li></ul><p>选择第二种方式部署<code>frp</code>服务，执行步骤：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在etc目录下创建frp文件夹</span><br><span class="hljs-built_in">cd</span> /etc<br>mkdir frp<br><br><span class="hljs-comment"># 返回刚才的systemd目录，复制文件</span><br><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">cd</span> frp_0.39.1_linux_amd64/systemd/<br><br><span class="hljs-comment"># 先拷贝.service文件， 需要在系统的目录下才能自启运行</span><br>sudo cp frps.service /usr/lib/systemd/system/<br><br><span class="hljs-comment"># 回到上一级，拷贝frp和.ini文件</span><br><span class="hljs-built_in">cd</span> ..<br>sudo cp frps /usr/bin/<br>sudo cp frps.ini /etc/frp/<br><br><span class="hljs-comment"># 启动frps服务</span><br>sudo systemctl start frps<br><br><span class="hljs-comment"># 停止frps服务</span><br>sudo systemctl stop frps<br><br><span class="hljs-comment"># 开启 frps 服务开机自启动</span><br>sudo systemctl <span class="hljs-built_in">enable</span> frps<br><br><span class="hljs-comment"># 禁用 frps 服务开机自启动</span><br>sudo systemctl <span class="hljs-built_in">disable</span> frps<br></code></pre></td></tr></tbody></table></figure><p>至此阿里云<code>frps</code>程序的配置部署完整结束，接下来是内网主机的客户端设置。</p><blockquote><p>2022年10月10日更新：</p><p>查看服务启动状态：<code>systemctl status frps</code></p></blockquote><h3 id="内网主机的frp客户端配置">5. 内网主机的frp客户端配置</h3><hr><blockquote><p>frp下载页面地址：https://github.com/fatedier/frp/releases</p><p>frp官方示例文档：https://gofrp.org/docs</p></blockquote><p>同样去到frp的下载页面，下载对应版本的frp，我的内网主机是windows，所以下载的windows版本。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310143938760.png" alt="image-20220310143938760" style="zoom: 67%;"></p><p>解压同样可以看到<code>frpc  frpc_full.ini  frpc.ini  frps  frps_full.ini  frps.ini  LICENSE  systemd</code>这些文件，在配置客户端时只需要<code>frpc</code>和<code>frpc.ini</code>两个文件，其余都可以删掉（如果你的内网主机仍是Linux可以保留<code>systemd</code>文件）。</p><p>打开<code>frpc.ini</code>进行如下配置：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">tls_enable</span>=<span class="hljs-literal">true</span>  <span class="hljs-comment"># 这一行是我后面自己加的，原因是之前有段时间frps服务一直连不上，按照网上教程才添加的，最开始可以删除这一行。</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">120.77</span>.<span class="hljs-number">61.888</span> <span class="hljs-comment"># 这是你的阿里云服务器公网ip地址，在"云服务器ECS-&gt;实例"进入实例管理界面可以看到</span><br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span> <span class="hljs-comment"># 这是和frps服务器端绑定的端口，这是阿里云服务器安全组中开放的入端口</span><br><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp <span class="hljs-comment"># 默认</span><br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-comment"># 默认内网主机的本地回环地址</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span> <span class="hljs-comment"># 内网主机的端口，用于SSH连接</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span> <span class="hljs-comment"># 这是阿里云服务器安全组中开放的另一个入端口</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>2022年10月10日更新：</p><p>可以添加多个内网主机（服务器）：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[ssh2]</span><br><span class="hljs-attr">type</span> = tcp <span class="hljs-comment"># 默认</span><br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.62</span>.<span class="hljs-number">113.61</span> <span class="hljs-comment"># 内网服务器地址</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span> <span class="hljs-comment"># 内网服务器的端口，用于SSH连接</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6001</span> <span class="hljs-comment"># 这是阿里云服务器安全组中开放的另一个入端口</span><br><br><br><br><span class="hljs-comment">### 6. 利用winsw将frpc客户端程序封装成windows服务</span><br><br>-------<br><br>完成`.ini`文件的修改配置之后，同样可以通过执行下面的命令行语句手动运行frpc客户端程序。<br><br>```bash<br><span class="hljs-comment"># 前台启动 （frp_windows文件夹下运行cmd）</span><br>frps -c frps.ini  <br></code></pre></td></tr></tbody></table></figure></blockquote><p>但是当你的cmd窗口关闭之后吧，程序就自动停止了，如果内网主机是Linux的话同样可以采用之前类似的方法将对应<code>frpc.xxx</code>的文件移入相应路径，windows主机的话则需要winsw来对程序进行封装。</p><blockquote><p>winsw下载地址：https://github.com/winsw/winsw/releases</p></blockquote><p>找到对应的x64版本，下载到frp文件夹的相同目录下。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310150256035.png" alt="image-20220310150256035"><figcaption aria-hidden="true">image-20220310150256035</figcaption></figure><p>然后新建一个<code>.xml</code>文件，里面填写一些windows服务参数</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> # windows服务id<br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> # windows服务名<br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>frp client<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span> # 服务描述，可有可没有<br>  <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span> # 服务执行的程序文件<br>  <span class="hljs-tag">&lt;<span class="hljs-name">arguments</span>&gt;</span>-c frpc.ini<span class="hljs-tag">&lt;/<span class="hljs-name">arguments</span>&gt;</span> # 服务程序文件的超参数，其实就相当与吧 frpc -c frpc.ini拆开<br>  <span class="hljs-tag">&lt;<span class="hljs-name">onfailure</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"restart"</span> <span class="hljs-attr">delay</span>=<span class="hljs-string">"10 sec"</span>/&gt;</span> # 重启延时<br>  <span class="hljs-tag">&lt;<span class="hljs-name">log</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"reset"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span> # 服务日志记录<br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>添加好后命名为<code>winsw.xml</code>同样放在<code>frp</code>文件夹的目录。</p><p>然后在当前<code>frp</code>路径下打开<code>cmd</code>窗口，输入<code>winsw install</code>就可以创建服务了，配置成功后可以看到如下输出：</p><blockquote><p>2022年10月10日更新：</p><p>如果要使用<code>winsw</code>进行服务部署，则需要把之前的下载的<code>WinSW-x64.exe</code>更改为<code>winsw.exe</code>如此才能找到指令。</p><p>服务卸载使用<code>winsw uninstall</code>指令，如果显示<code>已被标记删除</code>则重启一次电脑便会彻底删除。</p></blockquote><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310151324896.png" alt="image-20220310151324896"><figcaption aria-hidden="true">image-20220310151324896</figcaption></figure><p>之后便可在任务管理器服务一栏中看到<code>frpc</code>服务已启动并显示正在运行，（如果显示<code>已停止</code>右键点击，选择<code>启动</code>即可）</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310151447585.png" alt="image-20220310151447585"><figcaption aria-hidden="true">image-20220310151447585</figcaption></figure><p>然后便可通过在你的外网主机上配置<code>120.77.61.888:6000</code>端口连接访问你的内网主机了，windows用户，用户名和密码就是开机的时候的用户名和密码，提供一份我的配置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">Host my_pc<br>  HostName 120.77.61.888 # 自己的公网ip<br>  Port 6000 # 自己开放的安全组的入端口，需要与frpc.ini中的remote_port一直。<br>  User Administrator # windows一般是这个用户名<br></code></pre></td></tr></tbody></table></figure><p>终于，完结撒花，特别感谢教研室硕哥的帮助指导。</p><blockquote><p>2022年10月10日更新：</p><p>如果需要连接windows（内网主机）作为服务器，则需要在<code>windows -&gt;设置-&gt;应用-&gt;可选应用</code>里面搜索安装openssh服务端程序，安装完成后用管理员权限打开cmd，输入<code>net start sshd</code>开启ssh服务，输入<code>net stop sshd</code>关闭ssh服务。</p></blockquote><h3 id="参考文章">参考文章</h3><hr><p>【知乎】使用 systemd 管理 frp服务：https://zhuanlan.zhihu.com/p/382950791</p><p>【CSDN】阿里云服务器实现frp内网穿透（<a href="https://blog.csdn.net/hesongzefairy/article/details/105543161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164629271016780264082198%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164629271016780264082198&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-105543161.pc_search_result_cache&amp;utm_term=%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F&amp;spm=1018.2226.3001.4187">完整教程</a>）</p><p>【CSDN】阿里云服务器实现 frp 内网穿透：（<a href="https://blog.csdn.net/cao0507/article/details/82758288?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164629271016780264082198%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164629271016780264082198&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-82758288.pc_search_result_cache&amp;utm_term=%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F&amp;spm=1018.2226.3001.4187">完整教程</a>）</p><blockquote><p>文章名称一样，内容稍有不同。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
      <tag>frp</tag>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02. 深度学习网络结构可视化</title>
    <link href="/jasonyang.github.io/2022/02/26/02.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/jasonyang.github.io/2022/02/26/02.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="深度学习网络结构可视化">02. 深度学习网络结构可视化</h2><h3 id="torchsummary">1. torchsummary</h3><p>安装:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> torchsummary<br></code></pre></td></tr></tbody></table></figure><p>使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> models<br><span class="hljs-keyword">from</span> torchsummary <span class="hljs-keyword">import</span> summary<br><br>device = torch.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br>vgg = models.vgg16().to(device)<br><br><span class="hljs-string">'''</span><br><span class="hljs-string"># summary 函数完整形式</span><br><span class="hljs-string">summary(model, input_size, batch_size=-1, device=torch.device('cuda:0'),dtypes=None)</span><br><span class="hljs-string">'''</span><br>summary(vgg, (<span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br></code></pre></td></tr></tbody></table></figure><p>输出大概长这个样子：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220226155818058.png" alt="image-20220226155818058"><figcaption aria-hidden="true">image-20220226155818058</figcaption></figure><p>官方链接及使用指南：https://github.com/sksq96/pytorch-summary</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>模型可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web地球——网页书签仓库</title>
    <link href="/jasonyang.github.io/2022/02/24/Web%E5%9C%B0%E7%90%83%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E4%B9%A6%E7%AD%BE%E4%BF%9D%E5%AD%98/"/>
    <url>/jasonyang.github.io/2022/02/24/Web%E5%9C%B0%E7%90%83%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E4%B9%A6%E7%AD%BE%E4%BF%9D%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="web地球网页书签仓库">Web地球——网页书签仓库</h2><p>JasonYang的网页书签收藏仓库</p><h3 id="科研学习">1. 科研学习</h3><blockquote><p>论文查找</p></blockquote><p>SEMANTIC SCHOLAR：https://www.semanticscholar.org/比较全大多数论文都可以找到</p><p>Paper with Code：https://paperswithcode.com/sota深度学习方向论文的分类+code+paper 适合入门查找论文</p><p>Martin Danelljan 主页：https://martin-danelljan.github.io/一个目标跟踪大佬的已发表的论文的主页</p><p>Paper Comparision：https://github.com/JudasDie/Comparison超哥和张志鹏大佬一起构建的SOT、MOT顶会论文仓库</p><p>Aminer：https://www.aminer.cn/channel/143AI汇总挖掘科研情报，找找顶尖论文，看看顶尖大师</p><p><strong>arXiv Daily:</strong> https://www.arxivdaily.com/每日推荐arXiv上面计算机视觉、统计学、金融学等方向的最新论文。</p><blockquote><p>论文下载</p></blockquote><p>SCI-Hub: https://sci-hub.se/ 老毛子创建的论文共享下载网站</p><blockquote><p>机器学习</p></blockquote><p>特征工程学习：https://leoncuhk.gitbooks.io/feature-engineering/content/一个大佬写的笔记仓库，包括特征预处理、构建、提取、选择等典型步骤</p><blockquote><p>深度学习</p></blockquote><p>在线卷积池化公式计算器：http://www.sqflash.com/cal.html</p><p>Pytorch Image Model:https://rwightman.github.io/pytorch-image-models/results/各种backbone模型</p><p>ImgAug: https://github.com/aleju/imgaug 图像数据增强方法</p><p>边写边搜：https://app.fir.ai/ 在线做笔记查阅</p><p>readpaper：https://readpaper.com/同济子豪兄等人创建的论文阅读记录平台</p><p>MistGPU：https://mistgpu.com/login/ GPU服务器租用</p><p>Featurize: https://featurize.cn/ 同上 GPU服务器租用</p><blockquote><p>公式编辑</p></blockquote><p>Latex 公式在线编辑器：https://www.latexlive.com/#%23可以识别公式图片并转换为latex格式（可以用mathpix app替代）</p><p>在线公式编辑：https://math.edrawsoft.cn/图形化公式符号插入，可以导出为<code>latex、mml</code>或者图片格式</p><p>Latex公式手册：https://www.cnblogs.com/1024th/p/11623258.html公式总结</p><blockquote><p>LeetCode学习</p></blockquote><p>LeetCode按照怎样的顺序来刷题比较好？https://www.zhihu.com/question/36738189/answer/908664455知乎问题</p><p>企业常考的LeetCode题目：https://codetop.cc/home按照企业考试频率整理的LeetCode题目</p><p>ACM金牌选手整理的LeetCode刷题顺序：https://zhuanlan.zhihu.com/p/388470520</p><p><strong>代码随想录</strong>：https://www.programmercarl.com/</p><blockquote><p>在线课程</p></blockquote><p>国立台湾大学在线课程：http://ocw.aca.ntu.edu.tw/ntu-ocw/ocw/coupage/6数学、艺术、还有文学课程</p><h3 id="工具类">2. 工具类</h3><blockquote><p>常用</p></blockquote><p>LKs有趣网站分享：https://lks.helloxjn.com/各种各样杂七杂八的有趣网站推荐（闲时可以参观一波）</p><p>在线工具合集：https://www.67tool.com设计配色、视频格式转换、OCR识别、单位转换等等</p><p>Wallhaven：https://wallhaven.cc/ 高清电脑壁纸库</p><p>在线格式转换：https://www.alltoall.net/任意图像、视频、文档格式转换</p><p>I Love PDF：https://www.ilovepdf.com/zh-cn/merge_pdf超级好用的pdf文件在线合并以及压缩的网站</p><p>TempMail: https://temp-mail.org/en/临时邮箱用于注册一些不重要的网站</p><p>图贴士：https://www.tutieshi.com/compose/ 图片生成GIF</p><p>MarkDown emoji：https://www.webfx.com/tools/emoji-cheat-sheet/</p><p><strong>在线文件分享Airportal</strong>：https://airportal.cn/无须登陆注册，互联网分享文件</p><blockquote><p>图片处理</p></blockquote><p>皮卡智能抠图：https://www.picup.shop/apidoc-image-matting.html一个智能抠图网站，可以添加背景</p><p>BgRemover: https://www.aigei.com/bgremover/ 背景消除</p><blockquote><p>在线图表</p></blockquote><p>Apache ECharts：https://echarts.apache.org/zh/index.html 一个基于JavaScript 的开源可视化图表库</p><p>花火图表：https://hanabi.data-viz.cn/templates?lang=zh-CN在线动态图表制作</p><p>Processon：https://www.processon.com/ 在线流程图、思维导图制作</p><blockquote><p>颜色及编码工具</p></blockquote><p>RGB与16进制颜色编码对照表：https://www.sioe.cn/yingyong/yanse-rgb-16/可以任意指定RGB值</p><p>RGB颜色对照表：https://tool.oschina.net/commons?type=3 只有对照表</p><p>高质量论文配色参考：https://slandarer.blog.csdn.net/article/details/114157177?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2<sub>default</sub>CTRLIST<sub>default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2</sub>default<sub>CTRLIST</sub>default-1.no_search_link</p><blockquote><p>PPT素材 + icon图标</p></blockquote><p><strong>Shields.io</strong>: https://shields.io/GitHub仓库readme图标</p><p>Esayicon: https://www.easyicon.cc/ 简单易用</p><p>Iconfont阿里巴巴矢量图标库：https://www.iconfont.cn/ 图标丰富全面</p><p>Fotor 懒设计：https://www.fotor.com.cn/stickers 各式各样的PPT贴纸</p><p>稿定设计：https://www.gaoding.com/introduction平面、LOGO、PPT模板贴纸</p><p>BG-pattrens: http://bg-patterns.com/ PPT背景纹理素材</p><p>Pexels: https://www.pexels.com/zh-cn/ 高清图片素材</p><p>毛笔字体生成：http://www.akuziti.com/mb/可以生成多种毛笔字体保存为图像</p><p>字体转换：http://www.diyiziti.com/xingkai 功能同上</p><blockquote><p>PPT模板+简历模板</p></blockquote><p>KeyNote模板：http://www.ikeynote.cn/forum.php?mod=forumdisplay&amp;fid=42</p><p>创可贴：https://www.chuangkit.com/templatecenter 登陆获取模板</p><p>第一PPT：https://www.1ppt.com/ 免费、免登陆，就是样式有点儿丑</p><p>Slides Go: https://slidesgo.com/国外的PPT模板网站，免费用户每月限制下载10次</p><blockquote><p>软件下载</p></blockquote><p>MacWK：https://macwk.com/ 超全：Mac版本软件下载</p><p>MacBL：https://www.macbl.com/ 马可波罗 Mac版本软件下载</p><p>I tell You：https://msdn.itellyou.cn/ 正版本windows和office软件下载（不过学校提供正版软件！）</p><blockquote><p>语言表达&amp;文章纠错&amp;词频统计词云生成</p></blockquote><p>万词王-反向词典：https://wantwords.thunlp.org查找近义词或者查找与句子表述意思相近的词语</p><p>秘塔写作猫：https://xiezuocat.com/#/修改文章措辞表达，对“得、的、地”分不清真的很有用！</p><p>微词云：https://www.weiciyun.com/统计词频并可视化成词云，总结时可用</p><p>Highlight Code：https://highlightcode.com/ 代码高亮用于插入word文档</p><blockquote><p>计算机类书籍下载</p></blockquote><p>码农书籍网：https://www.manongbook.com/python/1944.html计算机编程类电子书，python java，linux基本都有</p><p>GitHub上的中文编程书目索引：https://github.com/justjavac/free-programming-books-zh_CN#%E7%9B%AE%E5%BD%95也比较全</p><p>GitHub上的经典编程书目索引：https://github.com/jobbole/awesome-programming-books经典书籍</p><blockquote><p>机场链接</p></blockquote><p>Duyaoss: https://www.duyaoss.com/ 超级多的机场介绍与测速</p><p>Ghelper: https://ghelper.net/ 目前在用，挺稳定的，也很便宜。</p><h3 id="人文类">3. 人文类</h3><blockquote><p>优秀图书推荐</p></blockquote><p>豆瓣旧版图书TOP250：https://www.douban.com/doulist/43621091/排除最近一些畅销书的冲击，回味经典</p><blockquote><p>电子书下载</p></blockquote><p>Zlibrary：https://zh.hk1lib.org Kindle电子书下载，9000w+电子图书</p><p>熊猫搜书：https://xmsoushu.com/#/ 电子书下载</p><p><strong>Wheremylife</strong>:http://wheremylife.cn/home#topKindle的RSS信息快捷推送</p><blockquote><p>历史</p></blockquote><p>全历史：https://www.allhistory.com/ 各个国家各个朝代历史文化学习</p><blockquote><p>杂</p></blockquote><p>Auto draw: https://www.autodraw.com/在线绘制简笔画，同时会有AI对目前的简笔画提供绘画建议</p><p>后续：https://houxu.app 热点事件、新闻后续报道</p><p>电影海报下载：http://www.impawards.com 各种电影海报下载</p><p>人人电影网：https://www.rrdynb.com/movie/经典、热门电影百度网盘保存</p><h3 id="其他">4. 其他</h3><blockquote><p>英语相关</p></blockquote><p>Anki共享单词卡片：https://ankiweb.net/shared/decks/english</p><p>BrainyQuote:https://www.brainyquote.com/?<strong>cf_chl_captcha_tk</strong>=pmd_FJEiJ.fORbZaza6gJ9H3lg6j6a4e1diHebA5NdIDVSQ-1630979858-0-gqNtZGzNA3ujcnBszQiR英文名言名句</p><blockquote><p>琐碎</p></blockquote><p>书签地球：https://www.bookmarkearth.com/分享个人书签的一个网站大概率找到宝藏网址</p><p>coffee BGM：https://bgmc-station.com/users/sign_incofee的常用BGM可以在放松或者学习的时候播放</p><p>在线打字游戏：https://play.typeracer.com随机打出一段英语语句，挺有趣的，可以没事打着玩。</p><p>mathor大佬：https://wmathor.com/index.php/about.html他的Transformer讲解很不错</p><p>国家自然基金查询：http://www.letpub.com.cn/index.php?page=grant可以查询心仪导师或者大牛在1997-2021年国家批准的自然基金项目</p><p>核爆范围：https://nuclearsecrecy.com/nukemap/查看当前原子弹或者氢弹爆炸的范围伤害</p><p>生成对称炫酷的图片：http://weavesilk.com/随便移动鼠标就是生成炫酷图片</p><p>矩阵计算器：http://www.yunsuan.info/cgi-bin/eigen_decomp.py矩阵理论学习利器，在线求特征值、SVD、QR分解之类的</p><p><strong>Typingclub</strong>：https://www.typingclub.com/在线标准打字练习网站， 超好玩，网站的动态效果做得太好了。</p><p><strong>Shields:</strong> https://shields.io/生成格式各样的数据图标</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>个人收藏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01. Pytorch 筛选部分网络层权重参数加载</title>
    <link href="/jasonyang.github.io/2022/02/20/Pytorch%20%E7%AD%9B%E9%80%89%E9%83%A8%E5%88%86%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9D%83%E9%87%8D%E5%8F%82%E6%95%B0%E5%8A%A0%E8%BD%BD/"/>
    <url>/jasonyang.github.io/2022/02/20/Pytorch%20%E7%AD%9B%E9%80%89%E9%83%A8%E5%88%86%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9D%83%E9%87%8D%E5%8F%82%E6%95%B0%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="pytorch-筛选部分网络层权重参数加载">01. Pytorch筛选部分网络层权重参数加载</h2><h3 id="从权重文件中筛选并加载">1. 从权重文件中筛选并加载</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pretrained_weight = torch.load(<span class="hljs-string">'weight.pth'</span>) <span class="hljs-comment"># 加载预训练的全部权重参数</span><br>new_net = My_Net() <span class="hljs-comment"># 定义自己的部分网络</span><br>new_net_dict = new_net.state_dict() <span class="hljs-comment"># 获取自己网络的权重参数</span><br>pretrained_dict = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> pretrained_weight.items() <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> net_dict} <span class="hljs-comment"># 筛选</span><br>new_net_dict.update(pretrained_dict) <span class="hljs-comment"># 更新自己网络的权重参数</span><br>new_net.load_state_dict(new_net_dict) <span class="hljs-comment"># 重新加载进自己的网络中</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>上面代码<code>筛选</code>步骤需要两个网络的网络层命名一样才能筛选成功，如果不一样参考下面网络层名映射的方法。</p></blockquote><h3 id="从pytorch官方模型中筛选部分层并加载">2.从Pytorch官方模型中筛选部分层并加载</h3><h4 id="加载预训练模型">1. 加载预训练模型</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision <span class="hljs-keyword">as</span> tv<br><br>pretrained_net = tv.models.alexnet(pretrained=<span class="hljs-literal">True</span>)<br>pretrained_weight = pretrained_net.state_dict()<br><br><span class="hljs-built_in">print</span>(pretrained_net)<br><span class="hljs-built_in">print</span>(pretrained_weight.keys())<br><br></code></pre></td></tr></tbody></table></figure><p>部分输出截取如下：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220163646781.png" alt="image-20220220163646781"><figcaption aria-hidden="true">image-20220220163646781</figcaption></figure><p>选取红框部分的网络参数加载</p><h4 id="自定义网络">2. 自定义网络</h4><p>根据已有模型的输入输出设计网络</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">My_net</span>(<span class="hljs-params">torch.nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(My_net, self).__init__()<br>        self.layer = torch.nn.Sequential(<br>            torch.nn.Linear(in_features=<span class="hljs-number">4096</span>, out_features=<span class="hljs-number">4096</span>, bias=<span class="hljs-literal">True</span>),<br>            torch.nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            torch.nn.Linear(in_features=<span class="hljs-number">4096</span>, out_features=<span class="hljs-number">1000</span>, bias=<span class="hljs-literal">True</span>)   <br>        )<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.layer(x)<br></code></pre></td></tr></tbody></table></figure><h4 id="实例化网络并确定映射关系">3. 实例化网络并确定映射关系</h4><p>因为权重参数是通过字典存储的，当你重新定义一样的网络（即时输入输出相同）但是每层的名称会不一样。导致无法加载。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">net = My_net()<br>net_dict = net.state_dict()<br>net_dict.keys()<br>need_weights = [<span class="hljs-string">'classifier.4.weight'</span>, <span class="hljs-string">'classifier.4.bias'</span>, <span class="hljs-string">'classifier.6.weight'</span>, <span class="hljs-string">'classifier.6.bias'</span>]<br>layer_name_map = { a: b <span class="hljs-keyword">for</span> a,b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(need_weights, net_dict.keys())} <span class="hljs-comment"># 网络层名称映射</span><br><span class="hljs-built_in">print</span>(layer_name_map)<br><span class="hljs-string">"""</span><br><span class="hljs-string">outs:</span><br><span class="hljs-string">{'classifier.4.weight': 'layer.0.weight',</span><br><span class="hljs-string"> 'classifier.4.bias': 'layer.0.bias',</span><br><span class="hljs-string"> 'classifier.6.weight': 'layer.2.weight',</span><br><span class="hljs-string"> 'classifier.6.bias': 'layer.2.bias'}</span><br><span class="hljs-string">"""</span><br></code></pre></td></tr></tbody></table></figure><h4 id="筛选并加载参数">4. 筛选并加载参数</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">pretrained_dict = {}<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> pretrained_weight.items():<br>    <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> need_weights:<br>        <span class="hljs-comment"># 通过映射获取自己网络的网络名</span><br>        pretrained_dict[layer_name_map[k]] = v<br><br>net.load_state_dict(pretrained_dict)<br></code></pre></td></tr></tbody></table></figure><p>END</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>Python</tag>
      
      <tag>权重加载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows更改默认Python版本</title>
    <link href="/jasonyang.github.io/2022/02/20/windows%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/"/>
    <url>/jasonyang.github.io/2022/02/20/windows%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="windows更改默认python版本">Windows更改默认Python版本</h2><p>之前想为特定版本的Python安装依赖包时遇到无法切换Python默认版本的问题，于是记录一下解决过程。</p><blockquote><p>适用于windows直接安装的python版本之间切换或者直接安装的python版本与anaconda中base环境python版本的切换。如果直接在anaconda中切换版本直接使用<code>source activate &lt;env name&gt;</code>或者<code>conda activate &lt;env name&gt;</code>。</p></blockquote><h4 id="查看当前默认python版本">1.查看当前默认Python版本</h4><p>在windows命令行窗口输入<code>python -V</code>查看当前Python版本。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220144944093.png" alt="image-20220220144944093"><figcaption aria-hidden="true">image-20220220144944093</figcaption></figure><h4 id="打开环境变量编辑界面">2.打开环境变量编辑界面</h4><p>windows中指令的调用顺序或者优先级是按照环境变量排列的先后顺序确定的，因此要改变默认python版本只需要调整<code>python.exe</code>路径在环境变量中的先后。依次点击<code>开始菜单&gt;设置&gt;系统&gt;关于&gt;高级系统设置&gt;环境变量</code>，打开后可以看到以下页面。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220150355935.png" alt="image-20220220150355935"><figcaption aria-hidden="true">image-20220220150355935</figcaption></figure><p>有两组变量<code>用户变量</code>和<code>系统变量</code>，<code>系统变量</code>的优先级比用户变量优先级更高，因此即使你是<code>用户变量path</code>中的第一个也比<code>系统变量path</code>中的最后一个优先级低。</p><h4 id="确定python各版本路径">3.确定python各版本路径</h4><p>先确定切换的python版本的路径，在命令行窗口输入<code>where python</code>查看已安装的python的路径。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220151037991.png" alt="image-20220220151037991"><figcaption aria-hidden="true">image-20220220151037991</figcaption></figure><p>主要就两个：一个在C盘，一个在G盘（C盘的是3.7,G盘的是python3.9）。</p><h4 id="更改环境变量顺序">4.更改环境变量顺序</h4><p>然后分别点击<code>用户变量</code>和<code>系统变量</code>中的<code>Path</code>组，然后点击<code>编辑</code>，查看对应python的顺序，确保想设置为默认python版本的路径在前面，我这里python3.7在anacondapython3.9上面所以默认是python 3.7。</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152025184.png" alt="image-20220220152025184"><figcaption aria-hidden="true">image-20220220152025184</figcaption></figure><p>如果我更改环境变量顺序为下图所示：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152226491.png" alt="image-20220220152226491"><figcaption aria-hidden="true">image-20220220152226491</figcaption></figure><p>此时重新打开命令行窗口，并输入<code>python -V</code>则会返回python3.9</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152410083.png" alt="image-20220220152410083"><figcaption aria-hidden="true">image-20220220152410083</figcaption></figure><p>至此python默认版本更改完毕。</p><blockquote><p>注意：有些时候你的不同版本python变量路径分别在<code>用户变量</code>和<code>系统变量</code>的path中，这时可以把其中一个路径删除，在同一个组（<code>用户变量</code>组或<code>系统变量</code>组）内添加，并确定优先顺序。</p></blockquote><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TMUX 简易使用方法</title>
    <link href="/jasonyang.github.io/2022/02/18/TMUX%20%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/jasonyang.github.io/2022/02/18/TMUX%20%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="tmux-简易使用方法">TMUX 简易使用方法</h2><blockquote><p><strong>主要参考：</strong></p><p>阮一峰 Tmux使用教程：https://www.ruanyifeng.com/blog/2019/10/tmux.html</p><p>Tmux使用手册：http://louiszhai.github.io/2017/09/30/tmux/#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E4%BC%9A%E8%AF%9D</p></blockquote><p><strong>基本概念：</strong>输入tmux命令就相当于开启了一个服务器，此时默认将新建一个会话，然后会话中默认新建一个窗口，窗口中默认新建一个面板。tmux会话、窗口、面板之间的联系如下：</p><ul><li><p>一个tmux<code>session</code>（会话）可以包含多个<code>window</code>（窗口），窗口默认充满会话界面，因此这些窗口中可以运行相关性不大的任务。</p></li><li><p>一个<code>window</code>又可以包含多个<code>pane</code>（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。</p></li></ul><h3 id="tmux-安装">0. tmux 安装</h3><hr><h4 id="root-用户安装">ROOT 用户安装：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ sudo apt-get install tmux<br><br><span class="hljs-comment"># CentOS 或 Fedora</span><br>$ sudo yum install tmux<br><br><span class="hljs-comment"># Mac</span><br>$ brew install tmux<br></code></pre></td></tr></tbody></table></figure><h4 id="非root-用户安装">非ROOT 用户安装：</h4><p>非root用户安装tmux参考以下链接：</p><p><a href="https://zhuanlan.zhihu.com/p/155662601">知乎：非root用户安装tmux</a></p><blockquote><p>如果使用<code>wget</code>产生类似<code>无法解析github.com</code>的错误信息可以利用链接进入GitHub仓库下载后传入安装位置。</p></blockquote><h3 id="基本用法">1. 基本用法</h3><hr><p>最简单也是最常用的tmux使用流程是：新建会话、在新建的会话中运行程序、分离会话、下次使用接入会话</p><h4 id="创建会话">创建会话</h4><ol type="1"><li>使用tmux快速创建会话</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>指定创建会话的名称</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s test-1<br></code></pre></td></tr></tbody></table></figure><p>上面表示创建一个名为<code>test</code>的会话。会话创建完后会在当前窗口的下方出现一个小绿条，类似这种：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220218101122309.png" alt="image-20220218101122309"><figcaption aria-hidden="true">image-20220218101122309</figcaption></figure><p>小绿条左边显示会话名称<code>test-1</code>、窗格(pane)序号<code>0</code>以及窗口名称<code>bash</code>（窗格和窗口的简单操作后面会提到）。小绿条右边则显示会话的创建时间及其他一些信息。</p><h4 id="运行程序">运行程序</h4><p>在刚才创建好的会话中键入自己想运行的程序指令，然后该指令便会一直在后台运行并不会随着SSH连接的断开而停止运行。例如在刚才的会话中运行<code>train.py</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python train.py<br></code></pre></td></tr></tbody></table></figure><p>就像正常的SSH连接一样程序开始运行。</p><h4 id="会话分离">会话分离</h4><p>经过上面的操作程序已经正常运行起来了，接下来我们可以用<code>detach</code>将这个会话与SSH窗口分离开，让它自己在后台运行。</p><p>具体操作如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux detach<br></code></pre></td></tr></tbody></table></figure><p>然后小绿条消失，会话窗口恢复到SSH连接窗口。</p><blockquote><p>可能在运行程序之后，你的程序会一直打印输出导致你无法输入上述指令这时可以利用先按一次<code>Ctrl+b</code>松开后再按<code>d</code>快捷键分离会话。</p></blockquote><h4 id="会话接入">会话接入</h4><p>一个小时之后我们想看看自己的程序跑得怎么样了，这时使用<code>attach</code>便能接入会话查看训练过程。具体指令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 接入之前 test 会话</span><br>$ tmux attach -t <span class="hljs-built_in">test</span><br></code></pre></td></tr></tbody></table></figure><h4 id="退出会话">退出会话</h4><p>会话分离操作只是将任务放置后台托管并没有断开连接，如果想在程序运行完之后断开连接退出会话则需要使用快捷键<code>Ctrl+d</code>或者键入<code>exit</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></tbody></table></figure><h3 id="其他操作">2. 其他操作</h3><h4 id="会话操作">会话操作</h4><ul><li>创建会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>查看会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ctrl+b + s 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux ls<br><span class="hljs-comment"># or</span><br>$ tmux list-session<br></code></pre></td></tr></tbody></table></figure><ul><li>分离会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ctrl+b + d 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux detach<br></code></pre></td></tr></tbody></table></figure><ul><li>接入会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>杀死（退出）会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ctrl+d</span><br><span class="hljs-comment"># or</span><br>$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>切换会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>重命名会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;<br></code></pre></td></tr></tbody></table></figure><h4 id="窗格操作">窗格操作</h4><ul><li>划分窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分为上下两个窗格</span><br><span class="hljs-comment"># ctrl+b + " 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux split-window<br><br><br><span class="hljs-comment"># 划分为左右两个窗格</span><br><span class="hljs-comment"># ctrl+b + % 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux split-window -h<br></code></pre></td></tr></tbody></table></figure><ul><li>移动光标</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></tbody></table></figure><blockquote><p>除了使用上面的显示指令外也可以通过<code>ctrl+b</code>和<code>键盘上下左右方向键来移动光标</code>。</p></blockquote><ul><li>交换窗格位置</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></tbody></table></figure><p>貌似无法支持窗格左右移动？</p><ul><li>查看窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux list-pane<br></code></pre></td></tr></tbody></table></figure><ul><li>移除窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除当前光标所在窗格</span><br><span class="hljs-comment"># ctrl+b + x 分开按</span><br><br><span class="hljs-comment"># 移除指定序号0的窗格</span><br>$ tmux kill-pane -t 0<br></code></pre></td></tr></tbody></table></figure><h4 id="窗口操作">窗口操作</h4><ul><li>创建窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>重命名窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给当前窗口重名命</span><br>$ tmux rename-window &lt;new-name&gt;<br><br>$ tmux rename-window -t  &lt;old-name&gt; &lt;new-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>查看窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux list-window<br></code></pre></td></tr></tbody></table></figure><ul><li>切换窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>关闭窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除指定的窗口</span><br>$ tmux kill-window -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>END</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tmux</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>风格迁移</title>
    <link href="/jasonyang.github.io/2021/11/30/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
    <url>/jasonyang.github.io/2021/11/30/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="风格迁移">风格迁移</h2><hr><h3 id="什么是风格迁移">1. 什么是风格迁移</h3><h4 id="风格迁移任务介绍">1.1 风格迁移任务介绍</h4><hr><p>简而言之，风格迁移即是将一种图像的画风（颜色、纹理等）融合到另一幅图像中，使得融合后的图像能够以风格图像的色彩风格呈现原始图像的内容（任务、景物等前景）。具体示例可见下方图示。</p><center class="half"><img src="style.png" style="zoom:50%;"><img src="content.png" style="zoom:50%;"></center><p><img src="fuse.png" style="zoom:50%;"></p><p>向风格迁移网络中输入风格图像<code>style</code>和内容图像<code>content</code>，网络便会输出融合<code>style</code>和<code>content</code>的新图像<code>style transfer</code>。</p><h4 id="风格迁移网络">1.2 风格迁移网络</h4><hr><p>基于深度学习的风格迁移任务的难点在于如何度量图片的风格，如若找到一种可以度量图像风格的数学模型，便可以基于反向传播训练风格迁移网络，以达到良好的风格迁移效果。</p><ol type="1"><li>Gram Matrix</li></ol><p>2015年Gatys利用GramMatrix实现了图像风格的定量计算方法，现在大多数图像风格迁移的风格度量均采用GramMatrix或者Gram Matrix的改进版本。因为本文所用风格度量方法也是基于GramMatrix的，于是先简单介绍一下什么是Gram Matrix。</p><p><img src="gram.png" alt="gram" style="zoom: 25%;"></p><p>当输入一幅图像（<code>2xWxH</code>）进入卷积神经网络时，图像经过卷积层会得到<code>CxWxH</code>的图像特征，在特征的每个通道特征<code>1xWxH</code>上保留了图像的高语义特征（包括内容和风格），但是不同通道之间的学习到的特征内容是不同。比如输入是一幅人脸图像，经过卷积网络之后可能通道1学习到了人脸鼻子特征，而通道2学习到了眼睛特征，它们的特征主体是不一样的，但同时他们来源于同一幅图像，他们的风格应该是一样的，由此Gatys通过计算不同通道特征向量<code>W*H</code>的的协方差矩阵（<code>CxC</code>）定量刻画图像的风格。具体做法是将卷积网络中特征图每个通道的特征reshape成一个向量（<code>1xWxH-&gt;1xWH</code>）然后计算不同通道特征的（偏心）协方差矩阵，这个就矩阵就是GramMatrix。操作示意图如上所示（图源<a href="https://blog.csdn.net/Hi_maxin/article/details/84979580?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BBgram&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-84979580.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">CSDN</a>）：</p><ol start="2" type="1"><li>风格转换网络结构</li></ol><p>使用的风格转换网络来源于Cui的《Multi-style Transfer: GeneralizingFast Style Transfer to Several Genres》，网络结构图如下所示。</p><p><img src="transnet.png" style="zoom: 50%;"></p><p>从图中可以看到风格转换网络由两个网络拼接而成，<code>Image Transform Net</code>用于向陌生的图像融合学习到的风格特征；<code>Loss Network</code>仅用在网络训练阶段，借用<code>Loss Network</code>以得到图像的内容损失和风格损失，以此更新模型参数。具体而言，输入陌生图片<span class="math inline">\(x\)</span>（一般情况下也是内容图像），经过<code>Image Transform Net</code>得到融合新风格的图像<span class="math inline">\(\hat{y}\)</span>，然后将风格迁移后图像<span class="math inline">\(\hat{y}\)</span>、风格图像<span class="math inline">\(y_{s}\)</span>和内容图像（也即原始图像）<span class="math inline">\(y_{c}\)</span>分别送入<code>Loss Network</code>，<code>Loss Network</code>是VGG-16的特征提取网络。分别保存三幅图像在前、后卷积层的输出响应（特征图），针对风格迁移后图像<span class="math inline">\(\hat{y}\)</span>和风格图像<span class="math inline">\(y_{s}\)</span>分别计算其GramMatrix，然后利用<code>MSELoss()</code>度量风格差异；针对风格迁移后图像<span class="math inline">\(\hat{y}\)</span>和内容图像<span class="math inline">\(y_{c}\)</span>直接使用<code>MSELoss()</code>度量图像之间特征主体的差异。</p><h3 id="基于pytorch的快速风格迁移实例">2.基于Pytorch的快速风格迁移实例</h3><hr><blockquote><p>环境：windows 10 + RTX3060 + CUDA 11.4</p></blockquote><blockquote><p>requirements：</p></blockquote><figure class="highlight tcl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tcl">matplotlib==<span class="hljs-number">3.4</span><span class="hljs-number">.3</span><br>numpy==<span class="hljs-number">1.21</span><span class="hljs-number">.4</span><br>Pillow==<span class="hljs-number">8.4</span><span class="hljs-number">.0</span><br>torch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span><br>torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.1</span><br>tqdm==<span class="hljs-number">4.62</span><span class="hljs-number">.3</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>代码主要参考:https://blog.csdn.net/weixin_48866452/article/details/109309245</p></blockquote><hr><h4 id="数据集构建">2.1 数据集构建</h4><hr><p>对于风格迁移任务来说训练样本不需要太多，最少两张图片便可完成风格转换的训练。本次选取了3张风格图片与6张内容图片构建风格迁移的数据集。风格和内容图片示例如下：</p><p><img src="datas.png"></p><p><img src="datac.png"></p><blockquote><p>样本图片来自于这个<a href="https://github.com/irasin/Pytorch_Style_Swap/tree/master">GitHub仓库</a>。</p></blockquote><p>具体的内容数据集加载方式如下方代码所示：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Content_Dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>(Content_Dataset, self).__init__()<br>        r_path = <span class="hljs-string">'dataset/content/'</span> <span class="hljs-comment"># 存放内容图片的路径</span><br>        c_img_name = os.listdir(r_path)<br>        self.c_img_path = [r_path+i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c_img_name]<br>        self.transforms = T.Compose([<br>            T.Resize((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)),<br>            T.ToTensor(),<br>        ])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index</span>):</span><br>        c_img = Image.<span class="hljs-built_in">open</span>(self.c_img_path[index])<br>        <br>        <span class="hljs-keyword">return</span> self.transforms(c_img)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.c_img_path)<br><br></code></pre></td></tr></tbody></table></figure><h4 id="风格迁移网络-1">2.2 风格迁移网络</h4><hr><p>迁移网络采用自编码结构，先用卷积将图像尺度缩小并学习高语义特征，再利用上采样将图像尺度放大，保证图像风格变换前后大小不变。迁移网络的Pytorch实现如下：</p><ol type="1"><li>TransNet</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResBlock</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channels</span>):</span><br>        <span class="hljs-built_in">super</span>(ResBlock, self).__init__()<br>        self.layer = nn.Sequential(<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(channels), <span class="hljs-comment"># 在图像像素上，对每个通道的HW做归一化。</span><br>            nn.ReLU(),<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(channels)<br>        )<br>        self.relu = nn.ReLU()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.relu(self.layer(x)+x)<br>    <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransNet</span>(<span class="hljs-params">nn.Module</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TransNet, self).__init__()<br>        self.layer = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">128</span>),<br>            nn.ReLU(),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            nn.Upsample(scale_factor=<span class="hljs-number">2</span>, mode=<span class="hljs-string">'nearest'</span>),<br>            nn.Conv2d(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.Upsample(scale_factor=<span class="hljs-number">2</span>, mode=<span class="hljs-string">'nearest'</span>),<br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>),<br>            nn.Sigmoid()<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.layer(x)<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>LossNet</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vgg16</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>(Vgg16, self).__init__()<br>        <span class="hljs-comment"># 直接加载预训练的VGG16网络提取图像特征</span><br>        loss_net = M.vgg16(pretrained=<span class="hljs-literal">True</span>)<br>        loss_net = loss_net.features<br>        self.feature1 = loss_net[:<span class="hljs-number">4</span>]<br>        self.feature2 = loss_net[<span class="hljs-number">4</span>:<span class="hljs-number">9</span>]<br>        self.feature3 = loss_net[<span class="hljs-number">9</span>:<span class="hljs-number">16</span>]<br>        self.feature4 = loss_net[<span class="hljs-number">16</span>:<span class="hljs-number">23</span>]<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        feature1 = self.feature1(x)<br>        feature2 = self.feature2(feature1)<br>        feature3 = self.feature3(feature2)<br>        feature4 = self.feature4(feature3)<br><br>        <span class="hljs-keyword">return</span> feature1, feature2, feature3, feature4<br>    <br></code></pre></td></tr></tbody></table></figure><h4 id="必要的工具函数">2.3 必要的工具函数</h4><hr><p>因为风格迁移没有定量评估迁移好坏的指标（一般都是通过人眼自行观察风格迁移结果去确定迁移性能），所以这里的工具函数目前包括Gram矩阵的计算函数和训练过程可视化函数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义gram矩阵</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_gram_matrix</span>(<span class="hljs-params">feature_map</span>):</span><br>    n, c, h, w = feature_map.shape<br>    feature_map = feature_map.reshape(n*c, h*w)<br>    gram_matrix = t.mm(feature_map, feature_map.t())<br>    <span class="hljs-keyword">return</span> gram_matrix.div(n*c*h*w)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练过程损失可视化</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">training_process_visualization</span>(<span class="hljs-params">data</span>):</span><br>    style_loss = data[<span class="hljs-string">'style_loss'</span>]<br>    content_loss = data[<span class="hljs-string">'content_loss'</span>]<br>    total_loss = data[<span class="hljs-string">'total_loss'</span>]<br><br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(content_loss)), content_loss)<br>    plt.title(<span class="hljs-string">'content_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'content_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'content_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">2</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(style_loss)), style_loss)<br>    plt.title(<span class="hljs-string">'style_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'style_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'style_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">3</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(total_loss)), total_loss)<br>    plt.title(<span class="hljs-string">'total_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'total_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'total_loss.png'</span>)<br>    plt.show()<br></code></pre></td></tr></tbody></table></figure><hr><p>通常在工具函数中还包括了存储网络超参数的<code>config.py</code>文件，本次风格迁移使用的超参数文件如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>():</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/hosi.jpg'</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/la_muse.jpg'</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/trial.jpg'</span><br>    style_img = <span class="hljs-string">'dataset/style/sketch.png'</span><br>    nw = <span class="hljs-number">0</span> <span class="hljs-comment"># 多线程加载数据集（windows多线程加载有问题，所以改成了0）</span><br>    bs = <span class="hljs-number">3</span> <span class="hljs-comment"># batchsize</span><br>    epochs = <span class="hljs-number">150</span> <br>    lr = <span class="hljs-number">0.001</span><br>    wc = <span class="hljs-number">1</span> <span class="hljs-comment"># 内容损失的权重</span><br>    ws = <span class="hljs-number">100000</span> <span class="hljs-comment"># 风格损失的权重</span><br>    result_path = <span class="hljs-string">'checkpoints'</span> <span class="hljs-comment"># 训练结果保存文件夹</span><br>    save_frequency = <span class="hljs-number">30</span> <span class="hljs-comment"># 每30个epoch保存一次</span><br>    trans = T.ToTensor()<br></code></pre></td></tr></tbody></table></figure><h4 id="网络训练及测试">2.4 网络训练及测试</h4><hr><p><strong>网络训练：</strong>通过更改<code>config.py</code>文件中的<code>style_img</code>路径更改训练的风格图片，然后完成2.1节所示3种风格的学习。具体的<code>train.py</code>如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> tqdm._tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torchvision.utils <span class="hljs-keyword">import</span> save_image<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><br><span class="hljs-keyword">from</span> dataset.my_dataset <span class="hljs-keyword">import</span> Content_Dataset<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> utils.tools <span class="hljs-keyword">import</span> get_gram_matrix, training_process_visualization<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> TransNet, Vgg16<br><br><br><span class="hljs-comment"># 初始化超参数实例</span><br>opt = Config()<br>device = t.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> t.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br><br><span class="hljs-comment"># 加载风格图片</span><br>img_style = opt.trans(Image.<span class="hljs-built_in">open</span>(opt.style_img)).unsqueeze(<span class="hljs-number">0</span>)<br>img_style = img_style.expand(opt.bs, img_style.shape[<span class="hljs-number">1</span>], img_style.shape[<span class="hljs-number">2</span>], img_style.shape[<span class="hljs-number">3</span>])<br>img_style = img_style.to(device)<br><br><span class="hljs-comment"># 创建结果保存文件夹</span><br><span class="hljs-comment"># 创建文件夹</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(opt.result_path):<br>    os.mkdir(opt.result_path)<br><br><span class="hljs-comment"># 初始化内容图片加载器</span><br>content_dataset = Content_Dataset()<br>content_loader = data.DataLoader(content_dataset, opt.bs, num_workers=opt.nw)<br><br><span class="hljs-comment"># 定义模型、优化器、损失函数</span><br>trans_net = TransNet().to(device)<br>loss_net = Vgg16().to(device).<span class="hljs-built_in">eval</span>()<br><br><br>optimizer = t.optim.AdamW(trans_net.parameters(), lr=opt.lr)<br>loss_func = nn.MSELoss().to(device)<br><br><br><span class="hljs-comment"># 利用Vgg16和Gram Matrix度量风格</span><br><span class="hljs-comment"># 此处不用管风格图片的大小因为最后生成的gram matrix大小均为NCxNC</span><br>styles = []<br>features = loss_net(img_style)<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> features:<br>    <span class="hljs-comment"># 这里一定得加上detach()截断风格输入，不然会保留的风格图片的梯度，导致BP失败</span><br>    styles.append(get_gram_matrix(f).detach())<br><br><span class="hljs-comment"># 用于保存训练过程中的损失</span><br>style_loss = []<br>content_loss = []<br>total_loss = []<br><br><span class="hljs-comment"># 更改为tqdm模块内的trange函数以了解训练时间</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(<span class="hljs-number">1</span>, opt.epochs+<span class="hljs-number">1</span>):<br>    trans_net.train()<br>    <span class="hljs-keyword">for</span> i, image <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(content_loader):<br>        image_c = image.to(device)<br>        <span class="hljs-comment"># print(image_c.shape)</span><br>        image_g = trans_net(image_c)<br>       <br>        <span class="hljs-comment"># 计算风格损失</span><br>        loss_s = <span class="hljs-number">0.0</span><br>        outs = loss_net(image_g)<br>        <span class="hljs-keyword">for</span> out, style <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(outs, styles):<br>            loss_s += loss_func(get_gram_matrix(out), style)<br><br>        <span class="hljs-comment"># 计算内容损失</span><br>        contents = loss_net(image_c)<br>        loss_c2 = loss_func(outs[<span class="hljs-number">1</span>], contents[<span class="hljs-number">1</span>])<br><br>        <span class="hljs-comment"># 总损失</span><br>        loss = loss_c2 * opt.wc + loss_s * opt.ws<br>        <span class="hljs-comment"># print(epoch, loss.item(), loss_c2.item(), loss_s.item())</span><br>        style_loss.append(loss_s.item())<br>        content_loss.append(loss_c2.item())<br>        total_loss.append(loss.item())<br><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br>    <span class="hljs-comment"># lr_adjust.step()</span><br><br>    <br>    <span class="hljs-comment"># 中途保存模型</span><br>    <span class="hljs-keyword">if</span> epoch % opt.save_frequency == <span class="hljs-number">0</span>:<br>        all_data = <span class="hljs-built_in">dict</span>(<br>                optimizer=optimizer.state_dict(),<br>                model=trans_net.state_dict(),<br>                info=<span class="hljs-string">u'模型和优化器的所有参数'</span><br>            )<br>        p = opt.style_img.split(<span class="hljs-string">'/'</span>)[-<span class="hljs-number">1</span>]<br>        p = opt.result_path + <span class="hljs-string">"/"</span> + p.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>]<br>        t.save(all_data, <span class="hljs-string">'{}_trans_net_{}.pth'</span>.<span class="hljs-built_in">format</span>(p, epoch))<br>        img_path = <span class="hljs-string">'{}_fuse_{}.jpg'</span>.<span class="hljs-built_in">format</span>(p, epoch)<br>        _, _, h, w = img_style.size()<br>        trans = T.Resize((h, w))<br><br>        save_image([img_style.clone()[<span class="hljs-number">0</span>],trans(image_c[<span class="hljs-number">0</span>]), trans(image_g[<span class="hljs-number">0</span>])], <br>        img_path, padding=<span class="hljs-number">0</span>, normalize=<span class="hljs-literal">True</span>, <span class="hljs-built_in">range</span>=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        <br>data = {<span class="hljs-string">'style_loss'</span>:style_loss, <span class="hljs-string">'content_loss'</span>:content_loss, <span class="hljs-string">'total_loss'</span>:total_loss}<br>training_process_visualization(data)<br></code></pre></td></tr></tbody></table></figure><p>训练过程的损失变化图如下：</p><center class="half"><img src="content_loss.png" alt="content_loss" style="zoom:50%;"><img src="style_loss.png" alt="style_loss" style="zoom: 50%;"><img src="total_loss.png" alt="total_loss" style="zoom:50%;"></center><p><strong>网络测试：</strong>构建<code>test.py</code>文件，加载训练时保存的模型参数，传入需要进行风格迁移的图片，得到风格迁移结果。具体的测试文件如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> name<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.data.dataset <span class="hljs-keyword">import</span> T<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> TransNet<br><span class="hljs-keyword">from</span> torchvision.utils <span class="hljs-keyword">import</span> save_image<br><br>opt = Config()<br>device = t.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> t.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br>trans_net = TransNet().to(device)<br><br>images = glob.glob(<span class="hljs-string">'dataset/content/**'</span>)<br>styles = [<span class="hljs-string">'hosi'</span>, <span class="hljs-string">'la_muse'</span>, <span class="hljs-string">'sketch'</span>, <span class="hljs-string">'trial'</span>]<br><span class="hljs-comment"># 遍历所有content图片</span><br><span class="hljs-keyword">for</span> img_p <span class="hljs-keyword">in</span> images: <br>img = opt.trans(Image.<span class="hljs-built_in">open</span>(img_p)).unsqueeze(<span class="hljs-number">0</span>)<br>img = img.to(device)<br><span class="hljs-comment"># 遍历风格</span><br><span class="hljs-keyword">for</span> style <span class="hljs-keyword">in</span> styles:<br>pred_models = [<span class="hljs-string">'checkpoints/{}_trans_net_{}.pth'</span>.<span class="hljs-built_in">format</span>(style, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>, <span class="hljs-number">151</span>, <span class="hljs-number">30</span>)]<br>outs = []<br>outs.append(img[<span class="hljs-number">0</span>])<br><span class="hljs-comment"># 遍历风格的不同epoch模型</span><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> pred_models:<br>all_data = t.load(m)<br>trans_net.load_state_dict(all_data[<span class="hljs-string">'model'</span>])<br>trans_net.<span class="hljs-built_in">eval</span>() <span class="hljs-comment"># 设置为推理模式</span><br>outs.append(trans_net(img)[<span class="hljs-number">0</span>])<br>name = style + <span class="hljs-string">'_'</span> + img_p[<span class="hljs-number">16</span>:]<br>save_image(outs, name, padding=<span class="hljs-number">0</span>, normalize=<span class="hljs-literal">True</span>, <span class="hljs-built_in">range</span>=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure><h4 id="迁移结果展示">2.5 迁移结果展示</h4><hr><p>最后得到的风格迁移结果如下：</p><p><img src="out1.png"></p><p><img src="out2.png"></p><p><img src="out3.png"></p><p>综合以上三种风格的迁移可视化结果可以看出，（从纵轴上观察）网络在处理人物或者动物图像时，过度的看重了图像的主体特征（内容），忽略了图像风格，这样的情况应该可以通过候选不断调整内容损失和风格损失的权重取得两者之间的平衡去解决，但限于时间和算力，并未做过多的尝试。（从横轴上观察）随着网络训练的加深，迁移后图像的风格也更加自然（虽然我觉得其实<code>epoch=30</code>的时候更像是图像迁移的最终目的<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。</p><h3 id="总结">3. 总结</h3><p>通过这次风格迁移的学习（当然也只是最基础的部分），也让我大致了解风格迁移任务的整体流程，目前完成的效果因为训练时间的限制并不是太好，整体来看有点儿像是风格滤镜那种，不像第一节介绍那种实现图片风格的完全卡通化，后面如果有时间再来好好研究一下。这次任务也让我了解一些新的东西比如：利用<code>Gram Matrix</code>去定量衡量图片风格，自编码网络结构的搭建，利用<code>glob</code>库直接生成目录内文件路径以及不用重复造轮子直接利用Pytorch官方的<code>save_img()</code>保存<code>tensor</code>为图片等等。再接再厉，继续学习<span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>!</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Neural Style</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于CIFAR-10的Pytorch深度学习模板构建</title>
    <link href="/jasonyang.github.io/2021/11/13/%E5%9F%BA%E4%BA%8ECIFAR-10%E7%9A%84Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA/"/>
    <url>/jasonyang.github.io/2021/11/13/%E5%9F%BA%E4%BA%8ECIFAR-10%E7%9A%84Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="基于cifar-10的pytorch深度学习模板构建">基于CIFAR-10的Pytorch深度学习模板构建</h2><p>构建了一个基于CIFAR-10数据集的pytorch版本深度学习baseline，便于以后更快的迁移到其它深度学习任务中去。代码详情请参看<a href="https://github.com/JayHeYang/deep-learning-baseline">GitHub</a>，如有错误，请指正。</p><h2 id="数据集加载">### 数据集加载</h2><ol type="1"><li><p>首先需要从CIFAR-10官网下载打包好的数据集</p><p>CIFAR-10数据集官网：http://www.cs.toronto.edu/~kriz/cifar.html</p><ul><li><p>下载对应Python版本的数据集文件并解压</p></li><li><p>根据官网上的Python加载方式加载数据集</p></li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unpickle</span>(<span class="hljs-params">file</span>):</span><br>    <span class="hljs-keyword">import</span> pickle<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> fo:<br>        <span class="hljs-built_in">dict</span> = pickle.load(fo, encoding=<span class="hljs-string">'bytes'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span><br><br>file = <span class="hljs-string">'/Users/morvan/Downloads/cifar-10-batches-py/data_batch_1'</span><br><span class="hljs-built_in">print</span>(unpickle(file).keys())<br></code></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_keys([<span class="hljs-string">b'batch_label'</span>, <span class="hljs-string">b'labels'</span>, <span class="hljs-string">b'data'</span>, <span class="hljs-string">b'filenames'</span>])<br></code></pre></td></tr></tbody></table></figure><p>经过以上解码加载之后，对返回值<code>dict</code>取<code>dict[b'labels']</code>和<code>dict[b'data']</code>分别获取batch1中的标签和数据，同理可以依次获得batch2-5以及test_batch的标签和数据。</p><blockquote><p><code>dict[b'labels']</code>返回一个长度为10000的列表，每个元素取值范围为0-9，分别对应10个类别的标签。</p></blockquote><blockquote><p><code>dict[b'data']</code>返回一个[10000,3072]的矩阵，存储每张样本图片的RGB像素值。前1024（32x32）是R通道的像素数据，后面依次是B、G通道。</p></blockquote><ol start="2" type="1"><li>完成训练和测试集的样本的解压加载之后，开始第二步：构造数据集加载器类。这个类有三个主要的构造函数分别是：<ol type="1"><li><code>__init__()</code>用于初始化数据集路径和定义一些数据增强Pipline。</li><li><code>__getitem__()</code>用于依据索引获取对应数据增强后的样本（data+label）。</li><li><code>__len__()</code>返回样本集的样本数据量。</li></ol></li></ol><p>具体数据集加载器类构造如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cifar10_Dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data_roots, trans</span>):</span><br>        self.transforms = trans<br>        <span class="hljs-keyword">for</span> k, data_root <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_roots):<br>            data = unpickle(data_root)[<span class="hljs-string">b'data'</span>]<br>            label = unpickle(data_root)[<span class="hljs-string">b'labels'</span>]<br>            <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>                self.all_data = data<br>                self.all_label = label<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># shape-&gt;(50000, 3072) or (10000, 3072)</span><br>                self.all_data = np.vstack((self.all_data, data)) <br>                <span class="hljs-comment"># shape-&gt;(50000, ) or (10000, )</span><br>                self.all_label = self.all_label + label <br>        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-comment"># 调整数据形状为图片格式 (3x32x32), 之后调整通道和图片宽高的排序（CHW-&gt;HWC）</span><br>        sample = np.reshape(self.all_data[idx], (<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)).transpose((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br>        img = Image.fromarray(sample)<br>        img = self.transforms(img) <span class="hljs-comment"># 3x32x32</span><br>        <span class="hljs-keyword">return</span> img, self.all_label[idx]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.all_label)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># storage location datasets</span><br>    file = <span class="hljs-string">'/Users/morvan/Downloads/cifar-10-batches-py/data_batch_1'</span><br>    roots = [file] <br>    trans = T.Compose([<br>        T.RandomCrop(<span class="hljs-number">32</span>),<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>]),<br>    ])<br>    dataset = Cifar10_Dataset(roots, trans)<br>    <span class="hljs-built_in">print</span>(dataset.__getitem__(<span class="hljs-number">10</span>)[<span class="hljs-number">0</span>].shape)<br></code></pre></td></tr></tbody></table></figure><p>至此数据集加载器类构造完成。</p><h3 id="网络模型搭建">网络模型搭建</h3><hr><p>网络模型为ResNet18，这里直接使用Pytorch官方提供的版本（手动更改最后全连接层的节点数为class_num=10）。</p><ol type="1"><li>ResNet18</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResNet18</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, num_classes</span>):</span><br>        <span class="hljs-built_in">super</span>(ResNet18, self).__init__()<br>        resnet18 = M.resnet18(pretrained=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 更改ResNet18最后全连接层的节点数以适应cifar10</span><br>        resnet18.fc = nn.Linear(resnet18.fc.in_features, num_classes)<br>        self.resnet = resnet18<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.resnet(x)<br></code></pre></td></tr></tbody></table></figure><h3 id="工具函数及超参数设置">工具函数及超参数设置</h3><hr><p>构造了两个工具函数<code>calculation_accuracy()</code>和<code>training_process_visualization()</code>分别用于计算准确率和训练过程的可视化。</p><ol type="1"><li>calculation_accuracy()</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculation_accuracy</span>(<span class="hljs-params">pred, label</span>):</span><br>    pred = pred.cpu().detach().numpy() <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>    pred = np.argmax(pred, axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>    right_count = np.<span class="hljs-built_in">sum</span>(pred == label.cpu().numpy()) <br>    acc = right_count / label.size(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> acc<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>training_process_visualization()</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">training_process_visualization</span>(<span class="hljs-params">data</span>):</span><br>    train_acc = data[<span class="hljs-string">'train_acc'</span>]<br>    train_loss = data[<span class="hljs-string">'train_loss'</span>]<br>    test_acc = data[<span class="hljs-string">'test_acc'</span>]<br><br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_loss)), train_loss)<br>    plt.title(<span class="hljs-string">'trian_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'trian loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'step'</span>)<br>    plt.savefig(<span class="hljs-string">'train_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">2</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_acc)), train_acc)<br>    plt.title(<span class="hljs-string">'train_acc'</span>)<br>    plt.ylabel(<span class="hljs-string">'train acc'</span>)<br>    plt.xlabel(<span class="hljs-string">'step'</span>)<br>    plt.savefig(<span class="hljs-string">'train_acc.png'</span>)<br><br>    plt.figure(<span class="hljs-number">3</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(test_acc)), test_acc)<br>    plt.title(<span class="hljs-string">'test_acc'</span>)<br>    plt.ylabel(<span class="hljs-string">'test acc'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'test_acc.png'</span>)<br>    plt.show()<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>config.py</li></ol><p>这个文件一般用来存储模型训练过程中的学习率，数据增强，batchsize，损失函数等超参数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>():</span><br>    train_roots = [<span class="hljs-string">'F:/DeepL/cifar-10-batches-py/data_batch_'</span><br>                        +<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)]<br>    test_roots = [<span class="hljs-string">'F:/DeepL/cifar-10-batches-py/test_batch'</span>]<br>    net = <span class="hljs-string">'Res'</span> <span class="hljs-comment"># 网络结构</span><br>    num_classes = <span class="hljs-number">10</span> <span class="hljs-comment"># 类别数</span><br>    nw = <span class="hljs-number">0</span> <span class="hljs-comment"># 多线程加载数据集（windows多线程加载有问题，所以改成了0）</span><br>    wd = <span class="hljs-number">0.001</span> <span class="hljs-comment"># 权重衰减</span><br>    m = <span class="hljs-number">0.9</span> <span class="hljs-comment"># SGD动量</span><br>    bs = <span class="hljs-number">512</span> <span class="hljs-comment"># batchsize</span><br>    epochs = <span class="hljs-number">20</span> <br>    lr = <span class="hljs-number">0.001</span><br>    <span class="hljs-comment"># 自定义训练和测试数据集所用的数据增强</span><br>    train_trans = T.Compose([<br>        T.RandomCrop(<span class="hljs-number">32</span>),<br>        T.RandomRotation((-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)),<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])])<br>    test_trans = T.Compose([<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])])<br>    <br></code></pre></td></tr></tbody></table></figure><h3 id="训练和测试">训练和测试</h3><hr><h4 id="训练步骤">训练步骤</h4><ol type="1"><li>初始化超参数实例</li><li>定义数据集加载器实例</li><li>定义模型、优化器、损失函数、学习率调整器</li><li>用于保存训练过程中的损失和准确率（可以不用）</li><li>通过两层<code>for</code>循环开始迭代训练<ol type="1"><li>取数据（<code>net.train()</code>）</li><li>优化器梯度置零</li><li>前向传播预测</li><li>计算损失并反向传播</li><li>学习率调整</li><li>每个epoch测试一次（<code>net.eval()</code>）</li></ol></li><li>根据记录的数据可视化训练过程</li></ol><p>完整的<code>train.py</code>如下所示</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">from</span> tqdm._tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> torch.optim.lr_scheduler <span class="hljs-keyword">import</span> StepLR<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><br><span class="hljs-keyword">from</span> dataset.my_dataset <span class="hljs-keyword">import</span> Cifar10_Dataset<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> utils.tools <span class="hljs-keyword">import</span> calculation_accuracy, training_process_visualization<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> ResNet18<br><br><br><span class="hljs-comment"># 初始化超参数实例</span><br>opt = Config()<br><br><span class="hljs-comment"># 初始化训练集、测试集加载器实例</span><br>trainset = Cifar10_Dataset(data_roots=opt.train_roots, trans=opt.train_trans)<br>trainset_loader = data.DataLoader(trainset, opt.bs, num_workers=opt.nw, shuffle=<span class="hljs-literal">True</span>)<br>testset = Cifar10_Dataset(data_roots=opt.test_roots, trans=opt.test_trans)<br>testset_loader = data.DataLoader(testset, opt.bs, num_workers=opt.nw)<br><br><span class="hljs-comment"># 定义模型、优化器、损失函数、学习率调整器</span><br>net = ResNet18(opt.num_classes)<br>optimizer = t.optim.SGD(net.parameters(), lr=opt.lr, momentum=opt.m, weight_decay=opt.wd)<br>loss_func = nn.CrossEntropyLoss()<br>lr_adjust = StepLR(optimizer, step_size=<span class="hljs-number">30</span>, gamma=<span class="hljs-number">0.1</span>)  <br><br><span class="hljs-comment"># 用于保存训练过程中的损失和准确率</span><br>train_loss = []<br>train_acc = []<br>test_acc = []<br><br><span class="hljs-keyword">if</span> t.cuda.is_available():<br>    net.cuda()<br>    loss_func.cuda()<br><br><span class="hljs-comment"># 更改为tqdm模块内的trange函数以了解训练时间</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(<span class="hljs-number">1</span>, opt.epochs+<span class="hljs-number">1</span>):<br>    net.train()<br>    <span class="hljs-keyword">for</span> i, (data, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trainset_loader):<br>        <span class="hljs-keyword">if</span> t.cuda.is_available():<br>            data, label = data.cuda(), label.cuda()<br><br>        optimizer.zero_grad()<br>        pred = net(data)<br><br>        loss = loss_func(pred, label)<br>        acc = calculation_accuracy(pred, label)<br>        loss.backward()<br>        optimizer.step()<br><br>         <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>        train_loss.append(loss.cpu().detach().numpy())<br>        train_acc.append(acc)<br>        <span class="hljs-comment"># print('loss:', loss.cpu().detach().numpy(), "acc", acc)</span><br>    lr_adjust.step()<br><br>    <br>    <span class="hljs-comment"># 每训练完一轮进行一次测试</span><br>    net.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">for</span> j, (data, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(testset_loader):<br>        <span class="hljs-keyword">if</span> t.cuda.is_available():<br>            data, label = data.cuda(), label.cuda()<br>        test_pred = net(data)<br>        <br>        all_pred = test_pred <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> t.vstack((all_pred, test_pred))<br>        all_label = label <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> t.cat((all_label, label))<br>    <br>    acc = calculation_accuracy(all_pred, all_label)<br>    test_acc.append(acc)<br><br><br>data = {<span class="hljs-string">'train_loss'</span>:train_loss, <span class="hljs-string">'train_acc'</span>:train_acc, <span class="hljs-string">'test_acc'</span>:test_acc}<br>training_process_visualization(data)<br></code></pre></td></tr></tbody></table></figure><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>baseline</tag>
      
      <tag>cifar10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git操作指南</title>
    <link href="/jasonyang.github.io/2021/09/25/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <url>/jasonyang.github.io/2021/09/25/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="git-操作指令">Git 操作指令</h2><h3 id="git-是什么">0. Git 是什么</h3><hr><p>Git是一个先进便捷的分布式版本控制系统。它可以实现对纯文本文件（code、txt、csv、md...）的修改提示（具体到某行）、回退到之前的版本、创建不同分支等等操作，这些操作都是可协作的。</p><h3 id="创建本地仓库预备">1. 创建本地仓库（预备）</h3><hr><p>打开GitBash命令行窗口，然后配置一下自己的名字和邮箱（自报家门），方便协作者看到是谁修改提交了版本，配置之后全局有效，你在当前电脑上的每个Git仓库都是使用这个配置。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"jasonyang"</span><br>$ git config --global user.email <span class="hljs-string">"jayheyang@gmail.com"</span><br></code></pre></td></tr></tbody></table></figure><ol type="1"><li><strong>切换到想要建立仓库的文件目录。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /h/code<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li><strong>在当前目录创建新的文件夹<code>learngit</code>,然后切换到<code>learngit</code>目录。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir learngit<br>$ <span class="hljs-built_in">cd</span> learngit <br></code></pre></td></tr></tbody></table></figure><blockquote><p>可使用<code>pwd</code>指令查看当前目录</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>out-&gt; /h/code/learngit<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>使用<code>git init</code>命令使得该目录变成可以被Git管理的仓库（文件夹）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br></code></pre></td></tr></tbody></table></figure><h3 id="将文件添加到仓库">2. 将文件添加到仓库</h3><hr><ol type="1"><li><strong>编写文本文件，可以是<code>.py</code>，<code>.md</code>，<code>.txt</code>等，编写<code>readme.txt</code>，并保存到当前Git目录。</strong></li></ol><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># readme.txt</span><br>Git is <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> control <span class="hljs-keyword">system</span>.<br>balabala...<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li><strong>把文件添加到Git的暂存区。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add readme.txt<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>把所有暂存区的文件提交到Git仓库。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">"wrote a readme file"</span><br></code></pre></td></tr></tbody></table></figure><p><code>-m</code>指令表示对本次提交的文件添加一个说明。</p><h3 id="常用指令">3. 常用指令</h3><hr><h4 id="基础储备">3.1 基础储备</h4><hr><ul><li><strong>basic command</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init <br>$ git add test.py<br>$ git commit -m <span class="hljs-string">"modified XXXX"</span><br></code></pre></td></tr></tbody></table></figure><ol type="1"><li><strong>查看当前仓库状态，了解是否有些文件被删改。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li><strong>查看当前工作区文件与版本库文件有什么不同。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff readme.txt <span class="hljs-comment"># readme.txt与当前版本库里readme.txt的不同</span><br>$ git diff HEAD^ -- readme.txt <span class="hljs-comment"># readme.txt与上一个版本（上一次提交）里的readme.txt的异同。</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>找到不同之后可以根据情况使用<code>git add</code>和<code>git commit</code>添加并提交文件，或者使用<code>git reset</code>回退到修改前的版本。</p></blockquote><ol start="3" type="1"><li><strong>查看提交的版本日志，包括分支（如果有的话）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><br>or<br>$ git <span class="hljs-built_in">log</span> --pretty=oneline<br><br>$ git <span class="hljs-built_in">log</span> --graph <span class="hljs-comment"># 可以看到分支的合并流程图</span><br></code></pre></td></tr></tbody></table></figure><p><code>--pretty=oneline</code>可以让返回的日志信息更加简略。</p><ol start="4" type="1"><li><strong>版本回退（针对已经进行<code>git add</code>甚至<code>git commit</code>操作的情况）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset <span class="hljs-comment"># 移除仓库暂存区的修改，但不改变工作区文件，相当于撤销git add操作。</span><br>$ git reset &lt;commit id&gt; <span class="hljs-comment"># 将仓库分支回退到指定&lt;commit id&gt;版本， 其余同上。</span><br>$ git reset --hard <span class="hljs-comment"># 清除暂存区和工作区的改动。会强制修改工作区文件。</span><br>$ git reset --hard &lt;commit id&gt; <span class="hljs-comment"># 将仓库分支回退到指定&lt;commit id&gt;版本， 其余同上。</span><br><br>$ git reset --hard HEAD^ <span class="hljs-comment"># 回退到当前版本的上一个版本</span><br>$ git reset --hard HEAD~1 <span class="hljs-comment"># 回退到当前版本的上一个版本</span><br><br>$ git reset --hard HEAD^^ <span class="hljs-comment"># 回退到当前版本的上两个版本</span><br>$ git reset --hard HEAD~2 <span class="hljs-comment"># 回退到当前版本的上两个版本。</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>&lt;commit id&gt;</code>可以不用写全，类似<code>1098abd</code>这种前面几位就可以了。</p></blockquote><blockquote><p>没有加<code>--hard</code>的命令手动打开本地工作区文件例如<code>readme.txt</code>不会看到修改的内容撤销了，加了<code>--hard</code>的命令则会看到文件的内容回到了修改之前。</p></blockquote><ol start="5" type="1"><li><strong>撤销修改（针对还未将修改文件提交到暂存区或者仓库的情况）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -- readme.txt<br></code></pre></td></tr></tbody></table></figure><p>撤销工作区里<code>readme.txt</code>文件最近的一次修改，如果文件提交到暂存区，则需要采用第4点的<code>git reset</code>操作进行回退。</p><blockquote><p>注意：如果不小心将工作区文件<code>rm</code>删除了，也可以使用<code>git checkout -- &lt;file name&gt;</code>进行误删恢复，<code>checkout</code>指令就是保证工作区和版本库的文件一致。</p></blockquote><ol start="6" type="1"><li><p><strong>彻底删除文件</strong></p><ol type="1"><li>删除工作区文件</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rm test.py<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>删除版本仓库文件</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rm test.py<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="3" type="1"><li>向Git仓库报告本次删除操作</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">"remove test.py"</span><br></code></pre></td></tr></tbody></table></figure><p></p></li><li><p><strong>为每次提交打标签</strong></p><ol type="1"><li>为最近一次提交打标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.0 <span class="hljs-comment"># 为当前提交commit-&gt;HEAD打上v1.0的标签</span><br>$ git tag -a v1.0 -m <span class="hljs-string">"version 1.0 released"</span> <span class="hljs-comment"># 打标签同时，提供标签说明</span><br></code></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>为指定<code>commit id</code>打标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v0.9 f64c633 <br>$ git tag -a v1.0 -m <span class="hljs-string">"version 1.0 released"</span> f64c633<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="3" type="1"><li>查看标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag <span class="hljs-comment"># 查看已打的标签</span><br>$ git show v1.0 <span class="hljs-comment"># 详细查看v1.0本次提交操作</span><br></code></pre></td></tr></tbody></table></figure><p></p><ol start="4" type="1"><li>删除标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v1.0<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="5" type="1"><li>推送标签到远程、删除远程标签</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin v1.0 <span class="hljs-comment"># 推送v1.0标签到远程`origin`分支</span><br>$ git push origin --tags <span class="hljs-comment"># 一次性推送所有标签</span><br></code></pre></td></tr></tbody></table></figure><p></p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v1.0 <span class="hljs-comment"># 先删除本地标签</span><br>$ git push origin :refs/tags/v1.0 <span class="hljs-comment"># 用'push'删除远程</span><br></code></pre></td></tr></tbody></table></figure><p></p></li></ol><h4 id="分支管理">3. 分支管理</h4><hr><p>分支是Git里面关键的功能，其能够实现平行化版本时间线，也能合并不同分支时间线的版本。推荐创建以下分支：</p><ul><li>master 默认创建的分支，负责更迭正式版本。</li><li>dev协作分支，团队成员之间相互协作，测试版本更迭情况将在此分支的时间线上体现。</li><li>bug bug分支，一般只在本地库，用于修改程序bug。</li><li>feature 记录更迭自己本地更改的版本。</li></ul><p>团队协作的Git版本库分支示意图（图源<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480">廖雪峰官方网站</a>）:</p><p><img src="1.png"></p><ol type="1"><li><strong>创建、查看分支</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev <span class="hljs-comment"># 创建并切换到dev分支</span><br>$ git switch -c dec <span class="hljs-comment"># 创建并切换到dev分支</span><br><br>$ git checkout master <span class="hljs-comment"># 切换到master分支</span><br>$ git switch master <span class="hljs-comment"># 切换到master分支</span><br></code></pre></td></tr></tbody></table></figure><p><code>switch</code>和<code>checkout</code>都可实现分支的创建与切换，老版本的<code>Git</code>使用<code>checkout</code>进行分支管理和文件恢复，现在分别由<code>switch</code>和<code>restore</code>管理。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-comment"># 查看当前版本库所有的分支</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>各个分支之前管理的版本文件相互独立，修改一个分支的版本文件不会影响另一个分支。</p></blockquote><ol start="2" type="1"><li><strong>合并、删除分支</strong></li></ol><p><strong>合并分支</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge dev <span class="hljs-comment"># 将dev分支合并到当前分支</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>单独调用<code>git merge</code>命令时会采用<code>Fast-Forward</code>合并模式，合并完成之后会将分支<code>dev</code>时间上的<code>commit</code>混合到分支<code>master</code>的时间线上去，此时如果实行版本回退则会回退到<code>dev</code>分支所提交的内容，而不是目标<code>master</code>分支上的内容。</p></blockquote><p>上述问题的解决办法就是使用<code>git merge --no-ff</code>指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge --no-ff -m <span class="hljs-string">"merge with no fast-forward"</span> dev<br></code></pre></td></tr></tbody></table></figure><p>该指令可以保留<code>dev</code>分支的提交信息,在分支<code>master</code>上进行版本回退时，可以正确退回<code>master</code>分支上的上一个版本，而不是<code>dev</code>分支上的上一个版本。</p><p><code>no-ff</code>合并操作包含了一次<code>git commit</code>，因此<code>-m</code>参数是为了加上提交说明。</p><blockquote><p>合并分支时，如果当前分支和被合并的分支都在上一个版本基础上进行了修改，合并会失败。同时发生合并冲突的文件例如<code>readme.txt</code>会自动添加内容告诉我们发生冲突的地方，此时需要手动修改冲突的文件。</p></blockquote><p><code>readme.txt</code>冲突发生后，打开文件可看到如下提示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Git is a version control system.<br>balabala...<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">Creating a new branch is quick AND simple.</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></code></pre></td></tr></tbody></table></figure><p>然后需要手动修改<code>readme.txt</code>文件为：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Git is <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> control <span class="hljs-keyword">system</span>.<br>balabala...<br>Creating <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch is quick <span class="hljs-keyword">and</span> simple.<br></code></pre></td></tr></tbody></table></figure><p>之后再执行<code>git add</code>和<code>git commit -m</code>提交到版本仓库，手动解决合并冲突。</p><p><strong>删除分支</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d dev <span class="hljs-comment"># 删除dev分支</span><br></code></pre></td></tr></tbody></table></figure><p>如果分支未合并，使用上面的删除指令会报错，这时需要使用下面的指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -D dev <span class="hljs-comment"># 删除dev分支</span><br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>暂存工作区的任务</strong></li></ol><p>当遇到正在写的任务没写完，又发现了一个紧急任务时，需要当前任务先暂存起来，先处理紧急任务，处理完成之后再回到当前的任务中来。Git提供了解决方案：<code>git stash</code>。</p><ol type="1"><li>存储当前的任务(假设在<code>dev</code>分支)</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash<br></code></pre></td></tr></tbody></table></figure><ol start="2" type="1"><li>去到紧急任务的分支，处理紧急任务</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch master<br>$ git XXX<br>....<br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li>回到之前任务分支，恢复任务</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch dev<br>$ git stash list <span class="hljs-comment"># 查看被暂存的所有任务列表</span><br>$ git stash pop <span class="hljs-comment"># 恢复最近的一个暂存任务</span><br>$ git stash pop stash@{0} <span class="hljs-comment"># 恢复暂存的标号0任务，标号从list的输出信息中得到</span><br></code></pre></td></tr></tbody></table></figure><h3 id="远程仓库操作">4. 远程仓库操作</h3><hr><ol start="0" type="1"><li><strong>预备工作</strong></li></ol><p>第1步：创建私钥和公钥：打开<code>Git Bash</code>命令行窗口，输入下列指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">"jayheyang@gmail.com"</span>?<br></code></pre></td></tr></tbody></table></figure><blockquote><p>地址记得改成自己的email！！！</p></blockquote><p>创建完成之后会在用户目录下（例如<code>/c/Users/Administrator</code>）找到<code>.ssh</code>文件夹，里面会有两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><p>第2步：打开GitHub，登陆。然后依次点击：<code>用户头像</code>-&gt;<code>Settings</code>-&gt;左侧边栏的<code>SSH and GPG keys</code>-&gt;<code>New SSH key</code>。</p><p>第3步：打开<code>id_rsa.pub</code>文件，<code>ctrl A</code>全选，<code>ctrl C</code>复制，切换到GitHub页面，<code>Title栏</code>随便写，相当于给你的这个密钥起名字。然后在<code>Key栏</code>中粘贴刚才复制的文本。</p><p><strong>预备工作完成。</strong></p><ol type="1"><li><p><strong>关联本地仓库与远程仓库</strong></p><ul><li>在GitHub上创建repository</li><li>进入创建的repo，获取SSH链接（形如<code>git@github.com:JayHeYang/learngit.git</code>）,打开<code>Git Bash</code>并切换到Git版本库目录，然后输入以下指令关联。</li></ul><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:JayHeYang/learngit.git<br></code></pre></td></tr></tbody></table></figure><p></p><p><code>origin</code>是默认的远程仓库名，可自行修改。</p></li><li><p><strong>将本地仓库文件<code>push</code>上去</strong></p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin master<br></code></pre></td></tr></tbody></table></figure><p><code>-u</code>的作用是将<code>本地master</code>分支和<code>远程master</code>分支关联起来，后面只需要进行<code>$ git push origin master</code>指令即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master <span class="hljs-comment"># push到远程端的master分支</span><br>$ git push origin dev <span class="hljs-comment"># push到远程端的dev分支</span><br></code></pre></td></tr></tbody></table></figure><ol start="3" type="1"><li><strong>查看所关联的远程库，或者删除与远程库的关联</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v <span class="hljs-comment"># 查看当前本地仓库关联的远程库</span><br>$ git remote rm origin <span class="hljs-comment"># 解除与远程库origin的关联</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>git remote rm</code>指令只是完成了解绑，如果要删除远程库中的文件还得在GitHub上修改。</p></blockquote><ol start="4" type="1"><li><p><strong>从远程仓库克隆文件</strong></p><p>1.切换到需要存储克隆文件的目录：</p><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir clonetest<br>$ <span class="hljs-built_in">cd</span> clonetest<br></code></pre></td></tr></tbody></table></figure><p></p><ol start="2" type="1"><li>获取需要克隆仓库的SSH连接（形如<code>git@github.com:JayHeYang/learngit.git</code>）执行<code>clone</code>指令。</li></ol><p></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:JayHeYang/learngit.git<br></code></pre></td></tr></tbody></table></figure><p></p><p>克隆完成。</p></li></ol><p>如果是其他协作人从远程仓库clone时默认只能看到<code>master</code>分支，如果想要在<code>dev</code>分支上做开发，需要创建远程<code>origin</code>的<code>dev</code>分支到本地，用以下命令行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -d dev origin/dev <br>或者<br>$ git switch -c dev origin/dev<br></code></pre></td></tr></tbody></table></figure><p>5.<strong>抓取分支并<code>push</code>上去</strong></p><p>多人协作的流程是： 第1步：按照任务要求在本地分支上完成修改。第2步：从远程仓库抓取分支，在本地合并，解决冲突。第3步：将本地分支<code>push</code>到远程分支上，更新进度。</p><p>遵循以下命令顺序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch dev <span class="hljs-comment"># 切换到工作分支</span><br>或者<br>$ git checkout -d dev origin/dev <span class="hljs-comment"># 将远程`origin`的`dev`分支创建到本地</span><br><br>$ git branch --set-upstream-to=origin/dev dev <span class="hljs-comment"># 将本地分支与远程分支绑定</span><br><br>$ git pull <span class="hljs-comment"># 抓取远程dev分支（抓取完成之后会自动进行合并）</span><br>$ git pull origin master <span class="hljs-comment"># 也可以直接指定分支抓取</span><br><br>手动解决合并冲突（如果有的话）<br><br>$ git add test.py <span class="hljs-comment"># 添加解决冲突后的文件</span><br><br>$ git commit -m <span class="hljs-string">"fix bug"</span><br><br>$ git push origin dev <span class="hljs-comment"># push到远程分支</span><br></code></pre></td></tr></tbody></table></figure><p><strong>2022年3月3日11:09:23 更新：</strong></p><hr><p><strong>注意</strong>：在<code>github</code>创建<code>repo</code>时如果添加了<code>readme.md</code>或者<code>LINCESE</code>等文件则在<code>push</code>之前得用以下操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git pull origin main --allow-unrelated-histories <span class="hljs-comment"># 使用这个指令，来把远程仓库和本地同步，消除两个文档间的差异，其实也就是把远端文件下载下来</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>为了回避种族歧视，现在创建<code>repo</code>默认将<code>master</code>更改为了<code>main</code>。</p></blockquote><p><code>Git</code>速查表：</p><figure><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/1009686-20160824100127870-1820786836.png" alt="img"><figcaption aria-hidden="true">img</figcaption></figure><h3 id="参考文献">参考文献</h3><hr><p>廖雪峰的Git的教程：https://www.liaoxuefeng.com/wiki/896043488029600</p><p>Git快查表：https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf</p><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simple Online and Realtime Tracking</title>
    <link href="/jasonyang.github.io/2021/09/23/Simple-Online-and-Realtime-Tracking/"/>
    <url>/jasonyang.github.io/2021/09/23/Simple-Online-and-Realtime-Tracking/</url>
    
    <content type="html"><![CDATA[<h2 id="paper-note-simple-online-and-realtime-tracking">Paper Note ——Simple Online and Realtime Tracking</h2><h3 id="文献简介">1.文献简介</h3><hr><ul><li>作者：Alex Bewley、Zongyuan Ge、Lionel Ott</li><li>关键词：Computer Vision, Multiple Object Tracking, Detection, DataAssociation</li><li>年份&amp;期刊（会议）名：IEEE 2016</li></ul><h3 id="结构和内容">2. 结构和内容</h3><hr><ol type="1"><li>介绍目标跟踪的任务流程，目前算法存在的问题和本文算法的优势</li><li>阐述研究背景和现状</li><li>介绍方法论<ul><li>检测模型</li><li>运动评估模型</li><li>数据关联</li><li>消失目标与先出现目标的销毁与创建</li></ul></li><li>实验部分</li></ol><h3 id="创新点实验成果汇总">3.创新点/实验成果汇总</h3><hr><ol type="1"><li>提出了端到端的跟踪模型，运用了tracking bydetection的思想，把主要关注点放在了assignment。</li><li>提出了跟踪领域的baseline。</li><li>运用Kalman filter和Hungarianalgorithm进行匀速模型估计和人物关联。（cost matrix 是IOUdistance）。</li><li>在score较高的情况下达到了一个高的FPS。</li></ol><h3 id="需要改进的地方">4.需要改进的地方</h3><hr><ol type="1"><li>仅用IOU的距离度量不能完全表达目标和预测之间的联系度。</li><li>检测的模型不算特别先进（当时还不错，backbone应该是在性能与运算量之间取了平衡）。</li><li>没有整合其他的人体信息，无法处理行人长时被遮挡的情况。</li></ol><h3 id="重要内容摘录">5.重要内容摘录</h3><hr><ul><li><p>指标的描述方法值得借鉴 <img src="sort1.png"></p></li><li><p>算法速度和性能的二维展示图 <img src="sort2.png"></p></li></ul><p>z</p>]]></content>
    
    
    <categories>
      
      <category>目标跟踪</category>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Hexo框架下Fluid主题自带搜索框一直loading的问题</title>
    <link href="/jasonyang.github.io/2021/08/26/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E4%B8%8BFluid%E4%B8%BB%E9%A2%98%E6%90%9C%E7%B4%A2%E4%B8%80%E7%9B%B4loading%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/jasonyang.github.io/2021/08/26/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E4%B8%8BFluid%E4%B8%BB%E9%A2%98%E6%90%9C%E7%B4%A2%E4%B8%80%E7%9B%B4loading%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="解决hexo框架下fluid主题自带搜索框一直loading的问题">解决Hexo框架下Fluid主题自带搜索框一直loading的问题</h1><p>最开始根据Fluid主题创建个人博客时发现搜索框一直显示loading，不能进行本地搜索。最开始尝试百度和Google解答无果，便搁置了下去。最近有了时间便开始尝试解决，最终使用了一种可行的方案达到了本地搜索效果。</p><h2 id="问题描述">问题描述</h2><p>fluid主题无法搜索的问题如下：当点击博客页面的<strong>搜索</strong>按钮时，搜索页面会一直显示<strong>Loading</strong>，如下图所示：</p><p><img src="1.jpg"></p><h2 id="寻找原因">寻找原因</h2><p>打开自己的博客根文件夹，如我的就是<code>blog</code>，然后打开<code>themes\fluid\_config.yml</code>，找到<code>search</code>模块，如下所示：</p><p><img src="2.jpg"></p><p>从图中可以看到我们搜索索引的文件是<code>local-search.xml</code>，然命令行切换到<code>blog</code>目录启动hexo三连发。</p><figure class="highlight sas"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">cd blog<br>hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo s<br></code></pre></td></tr></tbody></table></figure>打开Chrome浏览器，通过localhost链接打开博客主页，然后点击搜索按钮，使用F12查看报错信息，可以看到如下报错。<p></p><p><img src="3.jpg"></p><p>可以发现是因为找不到这个搜索文件引发的报错，因此就有了解决方案version1。</p><h2 id="解决方案version1">解决方案version1</h2><p>因为搜索框一直loading的原因是找不到生成的<code>.xml</code>文件，然后尝试在自己的<code>blog</code>文件夹中查找<code>local-search.xml</code>文件，发现确实有随着<code>hexo g</code>命令一起生成的<code>local-search.xml</code>文件，但是文件内部并没有博客的内容，因此即使更换为该文件同样无法起到搜索作用（这个本地搜索功能本质上就是检索<code>.xml</code>文件内部的内容，因此没有博客内容的<code>.xml</code>文件起不到任何检索作用）。</p><p>接下来仔细查看<code>blog</code>文件夹，发现在<code>blog\public\</code>文件夹内生成了一个<code>search.xml</code>文件，该文件包含了博客内部的内容应该能起到检索作用。那么，开始修改！同样，打开<code>blog\themes\fluid\_config.yml</code>，找到<code>search</code>模块，更改path如下所示：</p><p><img src="4.jpg"></p><p>再次启动hexo三连大法，然后可以看到<code>主页</code>的搜索已经可以正常检索了，然而当点击到<code>分类</code>d等其他页面时，再点击搜索，同样还是Loading。</p><p><img src="5.jpg"> <img src="1.jpg"></p><p>再次使用F12查看问题</p><p><img src="6.jpg"></p><p>发现全使用<code>search.xml</code>之后在跳转其他页面时Fluid会自动在地址上加入页面标签，比如分类页面就加上了<code>categories</code>(主页时是<code>http://localhost:4000/jasonyang.github.io/search.xml</code>，而分类页变为了<code>http://localhost:4000/jasonyang.github.io/categories/search.xml</code>)</p><p>然后就想到了使用绝对的文件索引地址，由此再每次切换页面时检索文件的地址就不会发生变化。</p><h2 id="解决方案version2">解决方案version2</h2><p>因为这个博客是为了部署到GitHub上面，因此这里将<code>blog\themes\fluid\_config.yml</code>，文件<code>search</code>版块的path更改为<code>博客项目的地址</code>+<code>search.xml</code>。例如：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">path: <span class="hljs-regexp">//</span>jayheyang.github.io<span class="hljs-regexp">/jasonyang.github.io/</span>search.xml<br></code></pre></td></tr></tbody></table></figure><p>最后<code>hexo d</code>部署到GitHub Pages，测试结果如下：</p><p><img src="7.jpg"></p><hr><p>挖个坑，2021年8月13日之后在使用<code>hexo d</code>部署时会遇到<code>Spawn failed</code>错误，网上搜索该错误的解决方法都不对，改天再说如何解决。</p><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hexo和GitHub搭建自己的博客网站</title>
    <link href="/jasonyang.github.io/2021/08/26/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/jasonyang.github.io/2021/08/26/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="基于hexo和github搭建自己的博客网站">基于Hexo和GitHub搭建自己的博客网站</h3><p>单边联动，基本框架搭建请参考Luo Xu的博客：点击<a href="https://ryanluoxu.github.io/2017/11/24/用-Hexo-和-GitHub-Pages-搭建博客/">这里</a>跳转。</p><h3 id="主题使用">主题使用</h3><p>本篇博客采用的是Fluid主题，主题的仓库链接如下：https://github.com/fluid-dev/hexo-theme-fluid</p><p>主题的详细使用指南：https://fluid-dev.github.io/hexo-fluid-docs/guide/</p><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown简易指南</title>
    <link href="/jasonyang.github.io/2021/07/28/Markdown%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/"/>
    <url>/jasonyang.github.io/2021/07/28/Markdown%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="markdown简易指南">Markdown简易指南</h1><h2 id="文档标题">文档标题</h2><p>文档的标题级别通过<code>#</code>数量的多少来衡量，<code>#</code>号数量越多则级别越大，但字号越小。最后一个<code>#</code>号和标题文字之间有一个空格，且文档最多支持六级标题，具体示例如下：</p><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><p><img src="1.jpg"></p><h2 id="创建列表">创建列表</h2><h3 id="创建无序列表">创建无序列表</h3><p>在英文输入法下，通过输入<code>-</code>符号创建无序列表。</p><ul><li>无序列表1</li><li>无序列表2</li></ul><h3 id="创建有序列表">创建有序列表</h3><p>在英文输入法下，通过输入<code>1.</code>数字标记创建有序列表</p><ol type="1"><li>有序列表1</li><li>有序列表2</li></ol><p><img src="2.jpg"></p><h3 id="列表嵌套">列表嵌套</h3><p>再完成一种列表的创建之后回车下一行（可能需要删除掉下一行自动添加的同级列表标记），键入<code>Tap</code>创建嵌套列表，嵌套列表的类型由<code>Tap</code>后输入的<code>-</code>或者<code>1.</code>符号决定。</p><ol type="1"><li>有序列表1<ul><li>无序列表1.1</li><li>无序列表1.2</li></ul></li><li>有序列表2<ol type="1"><li>有序列表2.1</li><li>有序列表2.2</li></ol></li></ol><p><img src="3.jpg"></p><h3 id="创建任务清单列表">创建任务清单列表</h3><p>在英文输入法下通过键入<code>- [ ]</code>创建未完成的任务清单；通过键入<code>- [x]</code>创建已完成的任务清单。任务清单同样可以嵌套，方法同样是利用<code>Tap</code>缩进决定嵌套级别，然后通过规定符号标记确定嵌套列表的类型。</p><ul class="task-list"><li><input type="checkbox" disabled="">这是一个未完成的任务：锻炼<ol type="1"><li>手臂肌肉锻炼</li><li>篮球技巧联系</li></ol></li></ul><div>            <input type="checkbox" disabled="" checked="checked">这是一个已完成的任务：刷B站          </div><div>            <input type="checkbox" disabled="" checked="checked">木鱼水心的视频          </div><div>            <input type="checkbox" disabled="" checked="checked">何同学的视频          </div><p><img src="4.jpg"></p><h2 id="创建分割线">创建分割线</h2><p>可以发现在创建文档标题时，一二级标题下面会自动存在分割线，而其他的标题下面没有分割线，而通过三个以上的<code>*</code>或者<code>-</code>符号可以手动创建分割线。</p><hr><hr><p><img src="5.jpg"></p><h2 id="创建表格">创建表格</h2><p>在英文输入法下，通过<code>|</code>和<code>-</code>的组合可以创建表格。</p><table><thead><tr class="header"><th>表头1</th><th>表头2</th><th>表头3</th></tr></thead><tbody><tr class="odd"><td>内容1</td><td>内容2</td><td>内容3</td></tr><tr class="even"><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><table><thead><tr class="header"><th>序号</th><th>标题</th><th>网址</th></tr></thead><tbody><tr class="odd"><td>01</td><td>百度</td><td><a href="https://www.baidu.com" class="uri">https://www.baidu.com</a></td></tr><tr class="even"><td>02</td><td>谷歌</td><td><a href="https://www.google.com" class="uri">https://www.google.com</a></td></tr></tbody></table><p><img src="6.jpg"></p><h3 id="表格的对齐格式">表格的对齐格式</h3><p>通过在<code>----</code>两天添加英文冒号可以指定表格每列的对齐方式，<code>:----</code>、<code>:----:</code>和<code>----:</code>分别表示左对齐、居中对齐和右对齐。</p><table><thead><tr class="header"><th style="text-align: left;">序号（左对齐）</th><th style="text-align: center;">标题（居中对齐）</th><th style="text-align: right;">网址（右对齐）</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">01</td><td style="text-align: center;">百度</td><td style="text-align: right;"><a href="https://www.baidu.com" class="uri">https://www.baidu.com</a></td></tr><tr class="even"><td style="text-align: left;">02</td><td style="text-align: center;">谷歌</td><td style="text-align: right;"><a href="https://www.google.com" class="uri">https://www.google.com</a></td></tr></tbody></table><p><img src="7.jpg"></p><h2 id="插入图片">插入图片</h2><p>通过<code>![图片描述](图片网址)</code>在文档中插入图片，图片网址可以是本地地址也可以是网络图片地址，图片描述可以省略。</p><figure><img src="markdown_logo.png" alt="Markdown Logo"><figcaption aria-hidden="true">Markdown Logo</figcaption></figure><p><img src="8.jpg"></p><h2 id="插入链接">插入链接</h2><p>通过<code>[链接说明](网址链接)</code>在文档中插入网址连接，一般来说链接说明不能省略。</p><p><a href="https://www.baidu.com/">百度</a></p><p><a href="https://www.google.com/">谷歌</a></p><p><a href="https://www.github.com/">GitHub</a></p><p><img src="9.jpg"></p><h3 id="多次引用同一个网址可以为网址指定索引标签">多次引用同一个网址，可以为网址指定索引标签</h3><p>通过<code>[索引标签]:网址连接</code>创建网址的索引标签，然后在使用<code>[链接说明][索引标签]</code>索引网址。</p><p>这里是我们常用的几个网址连接： <a href="https://www.google.com/">谷歌</a> 、<a href="https://www.baidu.com/">百度</a>和 <a href="https://www.github.com/">GitHub</a></p><p><img src="10.jpg"></p><h3 id="插入目录锚点实现文章内部点击跳转">插入目录锚点（实现文章内部点击跳转）</h3><p>通过<code>[目录名称](#索引标签)</code>生成目录锚点，索引标签必须和要跳转的标题章节名称对应（注：该方法只能跳转到文档标题开头处，正文不能跳转）。如果图方便生成文档目录的话可以直接采用<code>[TOC]</code>命令生成当前文档的目录。</p><p>目标检测入门算法：</p><ul><li><a href="#YOLO算法简介">YOLO</a></li><li><a href="#Faster%20R-CNN算法简介">Faster R-CNN</a></li><li><a href="#SSD算法简介">SSD</a></li></ul><h4 id="yolo算法简介">YOLO算法简介</h4><h4 id="faster-r-cnn算法简介">Faster R-CNN算法简介</h4><h4 id="ssd算法简介">SSD算法简介</h4><p><img src="11.jpg"></p><h4 id="快捷生成目录">快捷生成目录</h4><p>[TOC]</p><h2 id="插入代码块">插入代码块</h2><h3 id="插入行内代码">插入行内代码</h3><p>通过使用成对的左上撇号（`）插入行内代码。</p><p>就如<code>train_func</code>所示，巴拉巴拉......</p><h3 id="插入整段代码块">插入整段代码块</h3><p>通过使用成对的三个左上撇号（`）在文档中插入代码块，同时在第一组左上撇号的后面输入代码块使用的脚本语言例如python。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_func</span>()</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-string">'hello, world!'</span></span>)</span><br></code></pre></td></tr></tbody></table></figure><p><img src="12.jpg"></p><h2 id="插入公式">插入公式</h2><p>分数：<span class="math display">\[ f(x,y) = \frac{x^2}{y^3}\]</span></p><p>省略号：<span class="math display">\[ f(x_1, x_2, \ldots, x_n) = x_1+ x_2 + \cdots + x_n \]</span></p><p><img src="13.jpg"></p><h2 id="标记引用段落">标记引用段落</h2><p>某几句话或者一句话需要特别标注是可以采用“引用”样式，使用方法是在需要引用的文字前面添加<code>&gt;</code>符号。</p><blockquote><p>这句话很重要，引用起来。</p></blockquote><h3 id="可以嵌套引用">可以嵌套引用</h3><blockquote><p>这是第一级引用、</p><blockquote><p>这是第二级引用</p><blockquote><p>这是第三级引用</p></blockquote></blockquote></blockquote><p><img src="14.jpg"></p><h2 id="常用标记">常用标记</h2><p>下面介绍正文的一些处理样式包括粗体、斜体、删除线、文本高亮、下划线、上下标等等。</p><p><strong>粗体</strong>、<em>斜体</em>、==高亮==、<del>删除线</del>、<u>下划线</u>、我是<sup>上标</sup>、我是<sub>下标</sub></p><p><img src="15.jpg"></p><h3 id="转义符号">转义符号</h3><p>因为在Markdown中星号、加减号、括号等都有相应的指示作用，因此如果需要展示使用这些符号本身是需要用到转义字符<code>\</code>。</p><p>\ ' * _ {} [] () + . !</p><p><img src="16.jpg"></p><h3 id="插入emoji表情">插入emoji表情</h3><p>插入emoji表情的方法如下，即在成对的<code>:</code>中间填入表情对应的英文名称即可。</p><p><span class="github-emoji"><span>🥶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f976.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>🥵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f975.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span> <span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>更多表情符号请参考这个<a href="https://www.einsition.com/tools/emojicheatsheet">链接</a></p><p><img src="17.jpg"></p><h2 id="高级操作">高级操作</h2><hr><h3 id="导出pdf时指定分页">1. 导出PDF时指定分页</h3><p>插入如下代码块可在导出PDF时指定位置分页：<code>&lt;div STYLE="page-break-after: always;"&gt;&lt;/div&gt;</code></p><h3 id="插入多张图片并插入图注">2. 插入多张图片，并插入图注</h3><center><img style="width: 45%;" src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231914234.png"><img style="width: 45%;" src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231930826.png"><br><div style="color:orange; border-bottom: 1px solid #d9d9d7;    display: inline-block;    color: #999;    padding: 2px;">图2 【左】无滤波器的输入（黄）与 ap0（蓝）【右】带滤波器的输入（黄）与ap0（蓝）</div></center><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">center</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 45%;"</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">"https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231914234.png"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 45%;"</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">src</span>=<span class="hljs-string">"https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220421231930826.png"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"color:orange; border-bottom: 1px solid #d9d9d7;</span></span><br><span class="hljs-string"><span class="hljs-tag">    display: inline-block;</span></span><br><span class="hljs-string"><span class="hljs-tag">    color: #999;</span></span><br><span class="hljs-string"><span class="hljs-tag">    padding: 2px;"</span>&gt;</span>图2 【左】无滤波器的输入（黄）与 ap0（蓝）    【右】带滤波器的输入（黄）与ap0（蓝）<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">center</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><h3 id="键入空格">3. 键入空格</h3><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-meta">&amp;emsp;</span><br></code></pre></td></tr></tbody></table></figure><p>结尾分号一定要有！</p><h2 id="注意事项">注意事项</h2><p>通常在正文与列表项、表格项、文档标题之间都需要留有空行。</p><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang <strong>CopyrightNotice:</strong> All articles in this blog are licensed under <ahref="https: creativecommons.org="" licenses="" by-nc-sa="" 3.0="" "="">CC BY-NC-SA3.0 unless stating additionally. 转载请注明出处。</ahref="https:></p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/jasonyang.github.io/"/>
    <url>/jasonyang.github.io/</url>
    
    <content type="html"><![CDATA[<p>Hello 大家好，我是JasonYang，目前在电子科技大学读研究生，目前感兴趣的方向是多目标跟踪。</p><p>这个博客主要用于记录和积累学习路上的知识、经验，以求形成系统的体系，也便于以后忘记时及时复习巩固。</p><p>有时也会分享一些读书或观影笔记（如果研究生有时间看课外书的话<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），先就这样吧<span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
    
  </entry>
  
  
  
</search>
