<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>阿里云+frp实现内网穿透</title>
    <link href="/jasonyang.github.io/2022/03/10/%E9%98%BF%E9%87%8C%E4%BA%91+frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    <url>/jasonyang.github.io/2022/03/10/%E9%98%BF%E9%87%8C%E4%BA%91+frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="阿里云-frp实现内网穿透">阿里云+frp实现内网穿透</h2><h3 id="1-云服务器购买">1. 云服务器购买</h3><hr><p>随便买一个就行，主要是需要服务的一个公网ip。（点击<code>立即购买</code>默认创建即可，操作系统可选<code>CentOS</code>）</p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104116564.png" alt="image-20220310104116564" style="zoom:50%;"><h3 id="2-查看实例并开启远程连接">2. 查看实例并开启远程连接</h3><hr><p>点击<code>云服务器ECS-&gt;实例</code>进入实例管理界面，大概长这样：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104745377.png" alt="image-20220310104745377"></p><p>然后点击实例右边的<code>远程连接</code>打开服务器的控制终端。</p><blockquote><p>建议开启免密登陆，监控调试很方便。</p></blockquote><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310104926368.png" alt="image-20220310104926368" style="zoom: 67%;"><p>点击打开后能够看到如下界面：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310105510245.png" alt="image-20220310105510245"></p><h3 id="3-在阿里云服务器下载frp相关文件">3. 在阿里云服务器下载frp相关文件</h3><hr><p><strong>frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</strong></p><blockquote><p>frp下载页面地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>frp官方示例文档：<a href="https://gofrp.org/docs">https://gofrp.org/docs</a></p></blockquote><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310105731938.png" alt="image-20220310105731938" style="zoom:67%;"><p>选择这里的<code>linux_amd64</code>版本，然后鼠标放上面右键选择<code>复制链接地址</code>，之后切换回之前阿里云的终端控制台，使用<code>wget</code>指令下载frp文件。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://github.com/fatedier/frp/releases/download/v0.39.1/frp_0.39.1_linux_amd64.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>解压文件：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar -zxvf  frp_0.39.1_linux_amd64.tar.gz<br></code></pre></td></tr></tbody></table></figure><p>然后<code>cd</code>进入<code>frp_0.39.1_linux_amd64</code>目录，输入<code>ls</code>可以看到以下文件：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310110547047.png" alt="image-20220310110547047"></p><p><strong>文件解释：</strong></p><ul><li><code>frpc</code>——frp在客户端运行的文件，也就是需要穿透的内网环境下的主机需要运行的文件，与阿里云服务器这边无关可以删除。</li><li><code>frpc.ini</code>——frp客户端的配置文件，用于定义一些监听和转发端口啥的。</li><li><code>frps</code>——frp在服务器端运行的文件，这需要在阿里云服务器上运行。</li><li><code>frps.ini</code>——frp服务器端的配置文件。</li><li><code>systemd</code>——用于配置让frp服务一直在后台运行的文件，后面会讲。</li></ul><h3 id="4-开放阿里云服务器端口，并设置frp后台运行。">4. 开放阿里云服务器端口，并设置frp后台运行。</h3><hr><h4 id="4-1-回到阿里云“云服务器ECS-实例”界面，然后点击右侧的安全组，点击默认的安全组进行配置管理。">4.1 回到阿里云“云服务器ECS-&gt;实例”界面，然后点击右侧的<code>安全组</code>，点击默认的安全组进行配置管理。</h4><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310112455190.png" alt="image-20220310112455190"></p><p>手动添加入端口，比如我添加了这几个，一般添加两个端口就行</p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310112545443.png" alt="image-20220310112545443" style="zoom:67%;"><h4 id="4-2-回到云服务器的控制台，查看、修改并运行frps程序。">4.2 回到云服务器的控制台，查看、修改并运行<code>frps</code>程序。</h4><p><code>frps.ini</code>里面的内容如下：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">bind_port</span> = <span class="hljs-number">7000</span> <br></code></pre></td></tr></tbody></table></figure><blockquote><p>注意：7000 是默认绑定的端口，这个端口与你自己开放的入端口的其中一个得对应，不然一会儿客户无法访问。</p></blockquote><p>然后执行下面的语句服务器端程序就运行了。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前台启动</span><br>./frps -c ./frps.ini   <br> <br><span class="hljs-comment"># 后台启动（正常使用后推荐后台启动）</span><br>nohup ./frps -c ./frps.ini &amp;<br></code></pre></td></tr></tbody></table></figure><p>一般情况下后台启动已经能够满足正常要求，只要你的云服务器没有关机，程序就一直在运行，但是如果关机之后就得需要打开云服务器的控制终端重新运行一下<code>frps</code>程序。能不能让<code>frps</code>程序开机自启动，不用每次关机后手动打开呢？<code>systemd</code>文件就是用来干这件事儿的。</p><h4 id="4-3-使用-systemd-管理-frp-服务">4.3 使用 systemd 管理 frp 服务</h4><blockquote><p>下面部分基本<code>ctrl + C V</code>知乎<code>linux 技术栈</code>的文章，原文链接如下：</p><p>《使用 systemd 管理 frp 服务》: <a href="https://zhuanlan.zhihu.com/p/382950791">https://zhuanlan.zhihu.com/p/382950791</a></p></blockquote><ol><li><strong>systemd 服务单元</strong></li></ol><p>systemd 拥有 11 个单元类型，分别是：服务(service)、套接字(socket)、设备(device)、挂载点(mount)、自动挂载点(automount)、 启动目标(target)、交换分区或交换文件(swap)、被监视的路径(path)、任务计划(timer)、 资源控制组(slice)、一组外部创建的进程(scope)。</p><p>其中，服务单元是以 <code>.service</code> 为后缀的单元文件，封装了一个被 <code>systemd</code> 监视与控制的进程。</p><p>服务的单元文件包括三个部分：<code>[Service]</code>、<code>[Unit]</code> 和 <code>[Install]</code>。</p><p>在 GitHub 上下载的 frp 压缩包中已经包含了对应 frpc 和 frps 的服务的 <strong>单元文件</strong>和<strong>单元模板文件</strong>。下面我们将分别讲解基于单元文件和基于单元模板文件进行管理 frps 服务（frpc 服务类似）。</p><ol start="2"><li><strong>基于单元文件管理 frps 服务</strong></li></ol><p>我们先使用 frps 的单元文件（<code>frps.service</code>）进行管理 frps 服务。我们先看一下 <code>frps.service</code> 的文件内容：</p><blockquote><p>进入阿里云服务器控制终端界面<code>cd systemd </code>，然后<code>cat frps.service </code>可以看到如下内容。</p></blockquote><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310141256842.png" alt="image-20220310141256842"></p><p>下面是参数解释：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Frp Server Service <span class="hljs-comment"># 服务描述</span><br><span class="hljs-attr">After</span>=network.target <span class="hljs-comment"># frps 将会在 network.service 启动完毕之后再启动</span><br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple <span class="hljs-comment"># 不论进程是否启动成功，systemctl start 都执行成功</span><br><span class="hljs-attr">User</span>=nobody <span class="hljs-comment"># 设置进程在执行时使用的用户</span><br><span class="hljs-attr">Restart</span>=<span class="hljs-literal">on</span>-failure <span class="hljs-comment"># on-failure 表示仅在服务进程异常退出时重启</span><br><span class="hljs-attr">RestartSec</span>=<span class="hljs-number">5</span>s <span class="hljs-comment"># 设置在重启服务前暂停多长时间</span><br><span class="hljs-attr">ExecStart</span>=/usr/bin/frps -c /etc/frp/frps.ini <span class="hljs-comment"># 在启动该服务时需要执行的命令行</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target <span class="hljs-comment"># 用于 systemctl enable 时创建软连接</span><br></code></pre></td></tr></tbody></table></figure><p>重点只需要关注<code>ExecStart</code>，这里面是该服务的执行命令，其实也就是我们之前手动启动的命令行语句。接下来有两种更改方式：</p><ul><li>更改<code>ExecStart</code>中命令语句的执行路径，因为<code>bin</code>文件内是没有<code>frps</code>程序的</li><li>将<code>frps</code>和<code>frps.ini</code>移入到指定<code>bin</code>和<code>etc/frp</code>目录。</li></ul><p>选择第二种方式部署<code>frp</code>服务，执行步骤：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在etc目录下创建frp文件夹</span><br><span class="hljs-built_in">cd</span> /etc<br>mkdir frp<br><br><span class="hljs-comment"># 返回刚才的systemd目录，复制文件</span><br><span class="hljs-built_in">cd</span> ~<br><span class="hljs-built_in">cd</span> frp_0.39.1_linux_amd64/systemd/<br><br><span class="hljs-comment"># 先拷贝.service文件， 需要在系统的目录下才能自启运行</span><br>sudo cp frps.service /usr/lib/systemd/system/<br><br><span class="hljs-comment"># 回到上一级，拷贝frp和.ini文件</span><br><span class="hljs-built_in">cd</span> ..<br>sudo cp frps /usr/bin/<br>sudo cp frps.ini /etc/frp/<br><br><span class="hljs-comment"># 启动frps服务</span><br>sudo systemctl start frps<br><br><span class="hljs-comment"># 停止frps服务</span><br>sudo systemctl stop frps<br><br><span class="hljs-comment"># 开启 frps 服务开机自启动</span><br>sudo systemctl <span class="hljs-built_in">enable</span> frps<br><br><span class="hljs-comment"># 禁用 frps 服务开机自启动</span><br>sudo systemctl <span class="hljs-built_in">disable</span> frps<br></code></pre></td></tr></tbody></table></figure><p>至此阿里云<code>frps</code>程序的配置部署完整结束，接下来是内网主机的客户端设置。</p><h3 id="5-内网主机的frp客户端配置">5. 内网主机的frp客户端配置</h3><hr><blockquote><p>frp下载页面地址：<a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a></p><p>frp官方示例文档：<a href="https://gofrp.org/docs">https://gofrp.org/docs</a></p></blockquote><p>同样去到frp的下载页面，下载对应版本的frp，我的内网主机是windows，所以下载的windows版本。</p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310143938760.png" alt="image-20220310143938760" style="zoom: 67%;"><p>解压同样可以看到<code>frpc  frpc_full.ini  frpc.ini  frps  frps_full.ini  frps.ini  LICENSE  systemd</code>这些文件，在配置客户端时只需要<code>frpc</code>和<code>frpc.ini</code>两个文件，其余都可以删掉（如果你的内网主机仍是Linux可以保留<code>systemd</code>文件）。</p><p>打开<code>frpc.ini</code>进行如下配置：</p><figure class="highlight ini"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[common]</span><br><span class="hljs-attr">tls_enable</span>=<span class="hljs-literal">true</span>  <span class="hljs-comment"># 这一行是我后面自己加的，原因是之前有段时间frps服务一直连不上，按照网上教程才添加的，最开始可以删除这一行。</span><br><span class="hljs-attr">server_addr</span> = <span class="hljs-number">120.77</span>.<span class="hljs-number">61.888</span> <span class="hljs-comment"># 这是你的阿里云服务器公网ip地址，在"云服务器ECS-&gt;实例"进入实例管理界面可以看到</span><br><span class="hljs-attr">server_port</span> = <span class="hljs-number">7000</span> <span class="hljs-comment"># 这是和frps服务器端绑定的端口，这是阿里云服务器安全组中开放的入端口</span><br><br><span class="hljs-section">[ssh]</span><br><span class="hljs-attr">type</span> = tcp <span class="hljs-comment"># 默认</span><br><span class="hljs-attr">local_ip</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span> <span class="hljs-comment"># 默认内网主机的本地回环地址</span><br><span class="hljs-attr">local_port</span> = <span class="hljs-number">22</span> <span class="hljs-comment"># 内网主机的端口，用于SSH连接</span><br><span class="hljs-attr">remote_port</span> = <span class="hljs-number">6000</span> <span class="hljs-comment"># 这是阿里云服务器安全组中开放的另一个入端口</span><br></code></pre></td></tr></tbody></table></figure><h3 id="6-利用winsw将frpc客户端程序封装成windows服务">6. 利用winsw将frpc客户端程序封装成windows服务</h3><hr><p>完成<code>.ini</code>文件的修改配置之后，同样可以通过执行下面的命令行语句手动运行frpc客户端程序。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 前台启动 （frp_windows文件夹下运行cmd）</span><br>frps -c frps.ini  <br></code></pre></td></tr></tbody></table></figure><p>但是当你的cmd窗口关闭之后吧，程序就自动停止了，如果内网主机是Linux的话同样可以采用之前类似的方法将对应<code>frpc.xxx</code>的文件移入相应路径，windows主机的话则需要winsw来对程序进行封装。</p><blockquote><p>winsw下载地址：<a href="https://github.com/winsw/winsw/releases">https://github.com/winsw/winsw/releases</a></p></blockquote><p>找到对应的x64版本，下载到frp文件夹的相同目录下。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310150256035.png" alt="image-20220310150256035"></p><p>然后新建一个<code>.xml</code>文件，里面填写一些windows服务参数</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> # windows服务id<br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span> # windows服务名<br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>frp client<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span> # 服务描述，可有可没有<br>  <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span> # 服务执行的程序文件<br>  <span class="hljs-tag">&lt;<span class="hljs-name">arguments</span>&gt;</span>-c frpc.ini<span class="hljs-tag">&lt;/<span class="hljs-name">arguments</span>&gt;</span> # 服务程序文件的超参数，其实就相当与吧 frpc -c frpc.ini拆开<br>  <span class="hljs-tag">&lt;<span class="hljs-name">onfailure</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"restart"</span> <span class="hljs-attr">delay</span>=<span class="hljs-string">"10 sec"</span>/&gt;</span> # 重启延时<br>  <span class="hljs-tag">&lt;<span class="hljs-name">log</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">"reset"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">log</span>&gt;</span> # 服务日志记录<br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></tbody></table></figure><p>添加好后命名为<code>winsw.xml</code> 同样放在<code>frp</code>文件夹的目录。</p><p>然后在当前<code>frp</code>路径下打开<code>cmd</code>窗口，输入<code>winsw install</code>就可以创建服务了，配置成功后可以看到如下输出：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310151324896.png" alt="image-20220310151324896"></p><p>之后便可在任务管理器服务一栏中看到<code>frpc</code>服务已启动并显示正在运行，（如果显示<code>已停止</code>右键点击，选择<code>启动</code>即可）</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220310151447585.png" alt="image-20220310151447585"></p><p>然后便可通过在你的外网主机上配置<code>120.77.61.888:6000</code>端口连接访问你的内网主机了，windows用户，用户名和密码就是开机的时候的用户名和密码，提供一份我的配置。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs conf">Host my_pc<br>  HostName 120.77.61.888 # 自己的公网ip<br>  Port 6000 # 自己开放的安全组的入端口，需要与frpc.ini中的remote_port一直。<br>  User Administrator # windows一般是这个用户名<br></code></pre></td></tr></tbody></table></figure><p>终于，完结撒花，特别感谢教研室硕哥的帮助指导。</p><h3 id="参考文章">参考文章</h3><hr><p>【知乎】使用 systemd 管理 frp 服务：<a href="https://zhuanlan.zhihu.com/p/382950791">https://zhuanlan.zhihu.com/p/382950791</a></p><p>【CSDN】阿里云服务器实现frp内网穿透（<a href="https://blog.csdn.net/hesongzefairy/article/details/105543161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164629271016780264082198%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164629271016780264082198&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-4-105543161.pc_search_result_cache&amp;utm_term=%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F&amp;spm=1018.2226.3001.4187">完整教程</a>）</p><p>【CSDN】阿里云服务器实现 frp 内网穿透：<a href="https://blog.csdn.net/cao0507/article/details/82758288?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164629271016780264082198%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=164629271016780264082198&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-82758288.pc_search_result_cache&amp;utm_term=%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F&amp;spm=1018.2226.3001.4187">https://blog.csdn.net/cao0507/article/details/82758288?ops_request_misc=%7B%22request%5Fid%22%3A%22164629271016780264082198%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=164629271016780264082198&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-7-82758288.pc_search_result_cache&amp;utm_term=通过阿里云服务器实现内网穿透&amp;spm=1018.2226.3001.4187</a></p><blockquote><p>文章名称一样，内容稍有不同。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
      <tag>frp</tag>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02. 深度学习网络结构可视化</title>
    <link href="/jasonyang.github.io/2022/02/26/02.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96/"/>
    <url>/jasonyang.github.io/2022/02/26/02.%20%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84%E5%8F%AF%E8%A7%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h2 id="02-深度学习网络结构可视化">02. 深度学习网络结构可视化</h2><h3 id="1-torchsummary">1. torchsummary</h3><p>安装:</p><figure class="highlight cmake"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> torchsummary<br></code></pre></td></tr></tbody></table></figure><p>使用方法：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> models<br><span class="hljs-keyword">from</span> torchsummary <span class="hljs-keyword">import</span> summary<br><br>device = torch.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br>vgg = models.vgg16().to(device)<br><br><span class="hljs-string">'''</span><br><span class="hljs-string"># summary 函数完整形式</span><br><span class="hljs-string">summary(model, input_size, batch_size=-1, device=torch.device('cuda:0'),dtypes=None)</span><br><span class="hljs-string">'''</span><br>summary(vgg, (<span class="hljs-number">3</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br></code></pre></td></tr></tbody></table></figure><p>输出大概长这个样子：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220226155818058.png" alt="image-20220226155818058"></p><p>官方链接及使用指南：<a href="https://github.com/sksq96/pytorch-summary">https://github.com/sksq96/pytorch-summary</a></p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>模型可视化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web地球——网页书签仓库</title>
    <link href="/jasonyang.github.io/2022/02/24/Web%E5%9C%B0%E7%90%83%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E4%B9%A6%E7%AD%BE%E4%BF%9D%E5%AD%98/"/>
    <url>/jasonyang.github.io/2022/02/24/Web%E5%9C%B0%E7%90%83%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E4%B9%A6%E7%AD%BE%E4%BF%9D%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Web地球——网页书签仓库">Web地球——网页书签仓库</h2><p>JasonYang的网页书签收藏仓库</p><h3 id="1-科研学习">1. 科研学习</h3><blockquote><p>论文查找</p></blockquote><p>SEMANTIC SCHOLAR：<a href="https://www.semanticscholar.org/">https://www.semanticscholar.org/</a> 比较全大多数论文都可以找到</p><p>Paper with Code：<a href="https://paperswithcode.com/sota">https://paperswithcode.com/sota</a> 深度学习方向论文的分类+code+paper 适合入门查找论文</p><p>Martin Danelljan 主页：<a href="https://martin-danelljan.github.io/">https://martin-danelljan.github.io/</a> 一个目标跟踪大佬的已发表的论文的主页</p><p>Paper Comparision：<a href="https://github.com/JudasDie/Comparison">https://github.com/JudasDie/Comparison</a> 超哥和张志鹏大佬一起构建的SOT、MOT顶会论文仓库</p><p>Aminer：<a href="https://www.aminer.cn/channel/143">https://www.aminer.cn/channel/143</a>  AI汇总挖掘科研情报，找找顶尖论文，看看顶尖大师</p><blockquote><p>论文下载</p></blockquote><p>SCI-Hub: <a href="https://sci-hub.se/">https://sci-hub.se/</a> 老毛子创建的论文共享下载网站</p><blockquote><p>机器学习</p></blockquote><p>特征工程学习：<a href="https://leoncuhk.gitbooks.io/feature-engineering/content/">https://leoncuhk.gitbooks.io/feature-engineering/content/</a> 一个大佬写的笔记仓库，包括特征预处理、构建、提取、选择等典型步骤</p><blockquote><p>深度学习</p></blockquote><p>在线卷积池化公式计算器：<a href="http://www.sqflash.com/cal.html">http://www.sqflash.com/cal.html</a></p><p>Pytorch Image Model: <a href="https://rwightman.github.io/pytorch-image-models/results/">https://rwightman.github.io/pytorch-image-models/results/</a> 各种backbone模型</p><p>ImgAug: <a href="https://github.com/aleju/imgaug">https://github.com/aleju/imgaug</a> 图像数据增强方法</p><p>边写边搜：<a href="https://app.fir.ai/">https://app.fir.ai/</a>  在线做笔记查阅</p><p>readpaper：<a href="https://readpaper.com/">https://readpaper.com/</a> 同济子豪兄等人创建的论文阅读记录平台</p><p>MistGPU：<a href="https://mistgpu.com/login/">https://mistgpu.com/login/</a> GPU服务器租用</p><p>Featurize: <a href="https://featurize.cn/">https://featurize.cn/</a> 同上 GPU服务器租用</p><blockquote><p>公式编辑</p></blockquote><p>Latex 公式在线编辑器：<a href="https://www.latexlive.com/#%23">https://www.latexlive.com/#%23</a> 可以识别公式图片并转换为latex格式（可以用mathpix app替代）</p><p>在线公式编辑：<a href="https://math.edrawsoft.cn/">https://math.edrawsoft.cn/</a> 图形化公式符号插入，可以导出为<code>latex、mml</code>或者图片格式</p><blockquote><p>LeetCode学习</p></blockquote><p>LeetCode按照怎样的顺序来刷题比较好？<a href="https://www.zhihu.com/question/36738189/answer/908664455">https://www.zhihu.com/question/36738189/answer/908664455</a> 知乎问题</p><p>企业常考的LeetCode题目：<a href="https://codetop.cc/home">https://codetop.cc/home</a> 按照企业考试频率整理的LeetCode题目</p><p>ACM金牌选手整理的LeetCode刷题顺序：<a href="https://zhuanlan.zhihu.com/p/388470520">https://zhuanlan.zhihu.com/p/388470520</a></p><blockquote><p>在线课程</p></blockquote><p>国立台湾大学在线课程：<a href="http://ocw.aca.ntu.edu.tw/ntu-ocw/ocw/coupage/6">http://ocw.aca.ntu.edu.tw/ntu-ocw/ocw/coupage/6</a> 数学、艺术、还有文学课程</p><h3 id="2-工具类">2. 工具类</h3><blockquote><p>常用</p></blockquote><p>在线工具合集：<a href="https://www.67tool.com">https://www.67tool.com</a> 设计配色、视频格式转换、OCR识别、单位转换等等</p><p>Wallhaven：<a href="https://wallhaven.cc/">https://wallhaven.cc/</a> 高清电脑壁纸库</p><p>在线格式转换：<a href="https://www.alltoall.net/">https://www.alltoall.net/</a> 任意图像、视频、文档格式转换</p><p>I Love PDF：<a href="https://www.ilovepdf.com/zh-cn/merge_pdf">https://www.ilovepdf.com/zh-cn/merge_pdf</a>  超级好用的pdf文件在线合并以及压缩的网站</p><p>TempMail: <a href="https://temp-mail.org/en/">https://temp-mail.org/en/</a> 临时邮箱用于注册一些不重要的网站</p><p>图贴士：<a href="https://www.tutieshi.com/compose/">https://www.tutieshi.com/compose/</a> 图片生成GIF</p><p>MarkDown emoji：<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p><blockquote><p>图片处理</p></blockquote><p>皮卡智能抠图：<a href="https://www.picup.shop/apidoc-image-matting.html">https://www.picup.shop/apidoc-image-matting.html</a> 一个智能抠图网站，可以添加背景</p><p>BgRemover: <a href="https://www.aigei.com/bgremover/">https://www.aigei.com/bgremover/</a>  背景消除</p><blockquote><p>在线图表</p></blockquote><p>Apache ECharts：<a href="https://echarts.apache.org/zh/index.html">https://echarts.apache.org/zh/index.html</a> 一个基于 JavaScript 的开源可视化图表库</p><p>花火图表：<a href="https://hanabi.data-viz.cn/templates?lang=zh-CN">https://hanabi.data-viz.cn/templates?lang=zh-CN</a> 在线动态图表制作</p><p>Processon：<a href="https://www.processon.com/">https://www.processon.com/</a> 在线流程图、思维导图制作</p><blockquote><p>颜色及编码工具</p></blockquote><p>RGB与16进制颜色编码对照表：<a href="https://www.sioe.cn/yingyong/yanse-rgb-16/">https://www.sioe.cn/yingyong/yanse-rgb-16/</a> 可以任意指定RGB值</p><p>RGB颜色对照表：<a href="https://tool.oschina.net/commons?type=3">https://tool.oschina.net/commons?type=3</a>  只有对照表</p><p>高质量论文配色参考：<a href="https://slandarer.blog.csdn.net/article/details/114157177?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link">https://slandarer.blog.csdn.net/article/details/114157177?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-1.no_search_link</a></p><blockquote><p>PPT素材 + icon图标</p></blockquote><p>Esayicon: <a href="https://www.easyicon.cc/">https://www.easyicon.cc/</a>  简单易用</p><p>Iconfont阿里巴巴矢量图标库：<a href="https://www.iconfont.cn/">https://www.iconfont.cn/</a> 图标丰富全面</p><p>Fotor 懒设计：<a href="https://www.fotor.com.cn/stickers">https://www.fotor.com.cn/stickers</a> 各式各样的PPT贴纸</p><p>稿定设计：<a href="https://www.gaoding.com/introduction">https://www.gaoding.com/introduction</a> 平面、LOGO、PPT模板贴纸</p><p>BG-pattrens: <a href="http://bg-patterns.com/">http://bg-patterns.com/</a> PPT背景纹理素材</p><p>Pexels: <a href="https://www.pexels.com/zh-cn/">https://www.pexels.com/zh-cn/</a> 高清图片素材</p><p>毛笔字体生成：<a href="http://www.akuziti.com/mb/">http://www.akuziti.com/mb/</a> 可以生成多种毛笔字体保存为图像</p><p>字体转换：<a href="http://www.diyiziti.com/xingkai">http://www.diyiziti.com/xingkai</a> 功能同上</p><blockquote><p>PPT模板+简历模板</p></blockquote><p>KeyNote模板：<a href="http://www.ikeynote.cn/forum.php?mod=forumdisplay&amp;fid=42">http://www.ikeynote.cn/forum.php?mod=forumdisplay&amp;fid=42</a></p><p>创可贴：<a href="https://www.chuangkit.com/templatecenter">https://www.chuangkit.com/templatecenter</a> 登陆获取模板</p><p>第一PPT：<a href="https://www.1ppt.com/">https://www.1ppt.com/</a> 免费、免登陆，就是样式有点儿丑</p><p>Slides Go: <a href="https://slidesgo.com/">https://slidesgo.com/</a> 国外的PPT模板网站，免费用户每月限制下载10次</p><blockquote><p>软件下载</p></blockquote><p>MacWK：<a href="https://macwk.com/">https://macwk.com/</a> 超全：Mac版本软件下载</p><p>Mac毒：<a href="https://www.macdo.cn/">https://www.macdo.cn/</a> Mac版本软件下载</p><p>MacBL：<a href="https://www.macbl.com/">https://www.macbl.com/</a> 马可波罗 Mac版本软件下载</p><p>I tell You：<a href="https://msdn.itellyou.cn/">https://msdn.itellyou.cn/</a> 正版本windows和office软件下载 （不过学校提供正版软件！）</p><blockquote><p>语言表达&amp;文章纠错&amp;词频统计词云生成</p></blockquote><p>万词王-反向词典：<a href="https://wantwords.thunlp.org">https://wantwords.thunlp.org</a>  查找近义词或者查找与句子表述意思相近的词语</p><p>秘塔写作猫：<a href="https://xiezuocat.com/#/">https://xiezuocat.com/#/</a> 修改文章措辞表达，对“得、的、地”分不清真的很有用！</p><p>微词云：<a href="https://www.weiciyun.com/">https://www.weiciyun.com/</a> 统计词频并可视化成词云，总结时可用</p><p>Highlight Code：<a href="https://highlightcode.com/">https://highlightcode.com/</a> 代码高亮 用于插入word文档</p><blockquote><p>计算机类书籍下载</p></blockquote><p>码农书籍网：<a href="https://www.manongbook.com/python/1944.html">https://www.manongbook.com/python/1944.html</a> 计算机编程类电子书，python java，linux基本都有</p><p>GitHub上的中文编程书目索引：<a href="https://github.com/justjavac/free-programming-books-zh_CN#%E7%9B%AE%E5%BD%95">https://github.com/justjavac/free-programming-books-zh_CN#目录</a> 也比较全</p><p>GitHub上的经典编程书目索引：<a href="https://github.com/jobbole/awesome-programming-books">https://github.com/jobbole/awesome-programming-books</a> 经典书籍</p><h3 id="3-人文类">3. 人文类</h3><blockquote><p>优秀图书推荐</p></blockquote><p>豆瓣旧版图书TOP250：<a href="https://www.douban.com/doulist/43621091/">https://www.douban.com/doulist/43621091/</a> 排除最近一些畅销书的冲击，回味经典</p><blockquote><p>电子书下载</p></blockquote><p>Kindle电子书下载：<a href="https://zh.hk1lib.org">https://zh.hk1lib.org</a> 9000w+电子图书</p><p>熊猫搜书：<a href="https://xmsoushu.com/#/">https://xmsoushu.com/#/</a> 电子书下载</p><blockquote><p>历史</p></blockquote><p>全历史：<a href="https://www.allhistory.com/">https://www.allhistory.com/</a> 各个国家各个朝代历史文化学习</p><blockquote><p>杂</p></blockquote><p>Auto draw: <a href="https://www.autodraw.com/">https://www.autodraw.com/</a> 在线绘制简笔画，同时会有AI对目前的简笔画提供绘画建议</p><p>后续：<a href="https://houxu.app">https://houxu.app</a> 热点事件、新闻后续报道</p><p>电影海报下载：<a href="http://www.impawards.com">http://www.impawards.com</a> 各种电影海报下载</p><p>人人电影网：<a href="https://www.rrdynb.com/movie/">https://www.rrdynb.com/movie/</a> 经典、热门电影百度网盘保存</p><h3 id="4-其他">4. 其他</h3><blockquote><p>英语相关</p></blockquote><p>Anki共享单词卡片：<a href="https://ankiweb.net/shared/decks/english">https://ankiweb.net/shared/decks/english</a></p><p>BrainyQuote: <a href="https://www.brainyquote.com/">https://www.brainyquote.com/</a>?<strong>cf_chl_captcha_tk</strong>=pmd_FJEiJ.fORbZaza6gJ9H3lg6j6a4e1diHebA5NdIDVSQ-1630979858-0-gqNtZGzNA3ujcnBszQiR 英文名言名句</p><blockquote><p>琐碎</p></blockquote><p>书签地球：<a href="https://www.bookmarkearth.com/">https://www.bookmarkearth.com/</a> 分享个人书签的一个网站大概率找到宝藏网址</p><p>coffee BGM：<a href="https://bgmc-station.com/users/sign_in">https://bgmc-station.com/users/sign_in</a> cofee的常用BGM可以在放松或者学习的时候播放</p><p>在线打字游戏：<a href="https://play.typeracer.com">https://play.typeracer.com</a> 随机打出一段英语语句，挺有趣的，可以没事打着玩。</p><p>mathor大佬：<a href="https://wmathor.com/index.php/about.html">https://wmathor.com/index.php/about.html</a> 他的Transformer讲解很不错</p><p>国家自然基金查询：<a href="http://www.letpub.com.cn/index.php?page=grant">http://www.letpub.com.cn/index.php?page=grant</a> 可以查询心仪导师或者大牛在1997-2021年国家批准的自然基金项目</p><p>核爆范围：<a href="https://nuclearsecrecy.com/nukemap/">https://nuclearsecrecy.com/nukemap/</a> 查看当前原子弹或者氢弹爆炸的范围伤害</p><p>生成对称炫酷的图片：<a href="http://weavesilk.com/">http://weavesilk.com/</a> 随便移动鼠标就是生成炫酷图片</p><p>矩阵计算器：<a href="http://www.yunsuan.info/cgi-bin/eigen_decomp.py">http://www.yunsuan.info/cgi-bin/eigen_decomp.py</a> 矩阵理论学习利器，在线求特征值、SVD、QR分解之类的</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>个人收藏</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01. Pytorch 筛选部分网络层权重参数加载</title>
    <link href="/jasonyang.github.io/2022/02/20/Pytorch%20%E7%AD%9B%E9%80%89%E9%83%A8%E5%88%86%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9D%83%E9%87%8D%E5%8F%82%E6%95%B0%E5%8A%A0%E8%BD%BD/"/>
    <url>/jasonyang.github.io/2022/02/20/Pytorch%20%E7%AD%9B%E9%80%89%E9%83%A8%E5%88%86%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9D%83%E9%87%8D%E5%8F%82%E6%95%B0%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="01-Pytorch-筛选部分网络层权重参数加载">01. Pytorch 筛选部分网络层权重参数加载</h2><h3 id="1-从权重文件中筛选并加载">1. 从权重文件中筛选并加载</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">pretrained_weight = torch.load(<span class="hljs-string">'weight.pth'</span>) <span class="hljs-comment"># 加载预训练的全部权重参数</span><br>new_net = My_Net() <span class="hljs-comment"># 定义自己的部分网络</span><br>new_net_dict = new_net.state_dict() <span class="hljs-comment"># 获取自己网络的权重参数</span><br>pretrained_dict = {k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> pretrained_weight.items() <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> net_dict} <span class="hljs-comment"># 筛选</span><br>new_net_dict.update(pretrained_dict) <span class="hljs-comment"># 更新自己网络的权重参数</span><br>new_net.load_state_dict(new_net_dict) <span class="hljs-comment"># 重新加载进自己的网络中</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>上面代码<code>筛选</code>步骤需要两个网络的网络层命名一样才能筛选成功，如果不一样参考下面网络层名映射的方法。</p></blockquote><h3 id="2-从Pytorch官方模型中筛选部分层并加载">2. 从Pytorch官方模型中筛选部分层并加载</h3><h4 id="1-加载预训练模型">1. 加载预训练模型</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision <span class="hljs-keyword">as</span> tv<br><br>pretrained_net = tv.models.alexnet(pretrained=<span class="hljs-literal">True</span>)<br>pretrained_weight = pretrained_net.state_dict()<br><br><span class="hljs-built_in">print</span>(pretrained_net)<br><span class="hljs-built_in">print</span>(pretrained_weight.keys())<br><br></code></pre></td></tr></tbody></table></figure><p>部分输出截取如下：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220163646781.png" alt="image-20220220163646781"></p><p>选取红框部分的网络参数加载</p><h4 id="2-自定义网络">2. 自定义网络</h4><p>根据已有模型的输入输出设计网络</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">My_net</span>(<span class="hljs-params">torch.nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(My_net, self).__init__()<br>        self.layer = torch.nn.Sequential(<br>            torch.nn.Linear(in_features=<span class="hljs-number">4096</span>, out_features=<span class="hljs-number">4096</span>, bias=<span class="hljs-literal">True</span>),<br>            torch.nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            torch.nn.Linear(in_features=<span class="hljs-number">4096</span>, out_features=<span class="hljs-number">1000</span>, bias=<span class="hljs-literal">True</span>)   <br>        )<br>     <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.layer(x)<br></code></pre></td></tr></tbody></table></figure><h4 id="3-实例化网络并确定映射关系">3. 实例化网络并确定映射关系</h4><p>因为权重参数是通过字典存储的，当你重新定义一样的网络（即时输入输出相同）但是每层的名称会不一样。导致无法加载。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">net = My_net()<br>net_dict = net.state_dict()<br>net_dict.keys()<br>need_weights = [<span class="hljs-string">'classifier.4.weight'</span>, <span class="hljs-string">'classifier.4.bias'</span>, <span class="hljs-string">'classifier.6.weight'</span>, <span class="hljs-string">'classifier.6.bias'</span>]<br>layer_name_map = { a: b <span class="hljs-keyword">for</span> a,b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(need_weights, net_dict.keys())} <span class="hljs-comment"># 网络层名称映射</span><br><span class="hljs-built_in">print</span>(layer_name_map)<br><span class="hljs-string">"""</span><br><span class="hljs-string">outs:</span><br><span class="hljs-string">{'classifier.4.weight': 'layer.0.weight',</span><br><span class="hljs-string"> 'classifier.4.bias': 'layer.0.bias',</span><br><span class="hljs-string"> 'classifier.6.weight': 'layer.2.weight',</span><br><span class="hljs-string"> 'classifier.6.bias': 'layer.2.bias'}</span><br><span class="hljs-string">"""</span><br></code></pre></td></tr></tbody></table></figure><h4 id="4-筛选并加载参数">4. 筛选并加载参数</h4><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">pretrained_dict = {}<br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> pretrained_weight.items():<br>    <span class="hljs-keyword">if</span> k <span class="hljs-keyword">in</span> need_weights:<br>        <span class="hljs-comment"># 通过映射获取自己网络的网络名</span><br>        pretrained_dict[layer_name_map[k]] = v<br><br>net.load_state_dict(pretrained_dict)<br></code></pre></td></tr></tbody></table></figure><p>END</p><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
      <category>Pytorch 使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>权重加载</tag>
      
      <tag>Pytorch</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows更改默认Python版本</title>
    <link href="/jasonyang.github.io/2022/02/20/windows%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/"/>
    <url>/jasonyang.github.io/2022/02/20/windows%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4Python%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h2 id="Windows更改默认Python版本">Windows更改默认Python版本</h2><p>之前想为特定版本的Python安装依赖包时遇到无法切换Python默认版本的问题，于是记录一下解决过程。</p><blockquote><p>适用于windows 直接安装的python版本之间切换或者直接安装的python版本与anaconda中 base环境 python版本的切换。如果直接在anaconda中切换版本直接使用<code>source activate &lt;env name&gt; </code>或者<code>conda activate &lt;env name&gt;</code>。</p></blockquote><h4 id="1-查看当前默认Python版本">1.查看当前默认Python版本</h4><p>在windows命令行窗口输入<code>python -V</code>查看当前Python版本。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220144944093.png" alt="image-20220220144944093"></p><h4 id="2-打开环境变量编辑界面">2.打开环境变量编辑界面</h4><p>windows中指令的调用顺序或者优先级是按照环境变量排列的先后顺序确定的，因此要改变默认python版本只需要调整<code>python.exe</code>路径在环境变量中的先后。依次点击<code>开始菜单&gt;设置&gt;系统&gt;关于&gt;高级系统设置&gt;环境变量</code>，打开后可以看到以下页面。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220150355935.png" alt="image-20220220150355935"></p><p>有两组变量<code>用户变量</code>和<code>系统变量</code>，<code>系统变量</code>的优先级比用户变量优先级更高，因此即使你是<code>用户变量path</code>中的第一个也比<code>系统变量path</code>中的最后一个优先级低。</p><h4 id="3-确定python各版本路径">3.确定python各版本路径</h4><p>先确定切换的python版本的路径，在命令行窗口输入<code>where python</code>查看已安装的python的路径。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220151037991.png" alt="image-20220220151037991"></p><p>主要就两个：一个在C盘，一个在G盘（C盘的是3.7, G盘的是python3.9）。</p><h4 id="4-更改环境变量顺序">4.更改环境变量顺序</h4><p>然后分别点击<code>用户变量</code>和<code>系统变量</code>中的<code>Path</code>组，然后点击<code>编辑</code>，查看对应python的顺序，确保想设置为默认python版本的路径在前面，我这里python3.7在anaconda python3.9上面所以默认是python 3.7。</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152025184.png" alt="image-20220220152025184"></p><p>如果我更改环境变量顺序为下图所示：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152226491.png" alt="image-20220220152226491"></p><p>此时重新打开命令行窗口，并输入<code>python -V</code>则会返回python 3.9</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220220152410083.png" alt="image-20220220152410083"></p><p>至此python默认版本更改完毕。</p><blockquote><p>注意：有些时候你的不同版本python变量路径分别在<code>用户变量</code>和<code>系统变量</code>的path中，这时可以把其中一个路径删除，在同一个组（<code>用户变量</code>组或<code>系统变量</code>组）内添加，并确定优先顺序。</p></blockquote><div class="note note-success">            <p><strong>Post Author:</strong> jasonyang</p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TMUX 简易使用方法</title>
    <link href="/jasonyang.github.io/2022/02/18/TMUX%20%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/jasonyang.github.io/2022/02/18/TMUX%20%E7%AE%80%E6%98%93%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="TMUX-简易使用方法">TMUX 简易使用方法</h2><blockquote><p><strong>主要参考：</strong></p><p>阮一峰 Tmux 使用教程：<a href="https://www.ruanyifeng.com/blog/2019/10/tmux.html">https://www.ruanyifeng.com/blog/2019/10/tmux.html</a></p><p>Tmux使用手册：<a href="http://louiszhai.github.io/2017/09/30/tmux/#%E6%9F%A5%E7%9C%8B%E6%89%80%E6%9C%89%E7%9A%84%E4%BC%9A%E8%AF%9D">http://louiszhai.github.io/2017/09/30/tmux/#查看所有的会话</a></p></blockquote><p>**基本概念：**输入tmux命令就相当于开启了一个服务器，此时默认将新建一个会话，然后会话中默认新建一个窗口，窗口中默认新建一个面板。tmux会话、窗口、面板之间的联系如下：</p><ul><li><p>一个tmux <code>session</code>（会话）可以包含多个<code>window</code>（窗口），窗口默认充满会话界面，因此这些窗口中可以运行相关性不大的任务。</p></li><li><p>一个<code>window</code>又可以包含多个<code>pane</code>（面板），窗口下的面板，都处于同一界面下，这些面板适合运行相关性高的任务，以便同时观察到它们的运行情况。</p></li></ul><h3 id="0-tmux-安装">0. tmux 安装</h3><hr><h4 id="ROOT-用户安装：">ROOT 用户安装：</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu 或 Debian</span><br>$ sudo apt-get install tmux<br><br><span class="hljs-comment"># CentOS 或 Fedora</span><br>$ sudo yum install tmux<br><br><span class="hljs-comment"># Mac</span><br>$ brew install tmux<br></code></pre></td></tr></tbody></table></figure><h4 id="非ROOT-用户安装：">非ROOT 用户安装：</h4><p>非root用户安装tmux参考以下链接：</p><p><a href="https://zhuanlan.zhihu.com/p/155662601">知乎：非root用户安装tmux</a></p><blockquote><p>如果使用<code>wget</code>产生类似<code>无法解析github.com</code>的错误信息可以利用链接进入GitHub仓库下载后传入安装位置。</p></blockquote><h3 id="1-基本用法">1. 基本用法</h3><hr><p>最简单也是最常用的tmux使用流程是：新建会话、在新建的会话中运行程序、分离会话、下次使用接入会话</p><h4 id="创建会话">创建会话</h4><ol><li>使用tmux快速创建会话</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>指定创建会话的名称</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s test-1<br></code></pre></td></tr></tbody></table></figure><p>上面表示创建一个名为<code>test</code>的会话。会话创建完后会在当前窗口的下方出现一个小绿条，类似这种：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/image-20220218101122309.png" alt="image-20220218101122309"></p><p>小绿条左边显示会话名称<code>test-1</code>、窗格(pane)序号<code>0</code>以及窗口名称<code>bash</code>（窗格和窗口的简单操作后面会提到）。小绿条右边则显示会话的创建时间及其他一些信息。</p><h4 id="运行程序">运行程序</h4><p>在刚才创建好的会话中键入自己想运行的程序指令，然后该指令便会一直在后台运行并不会随着SSH连接的断开而停止运行。例如在刚才的会话中运行<code>train.py</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ python train.py<br></code></pre></td></tr></tbody></table></figure><p>就像正常的SSH连接一样程序开始运行。</p><h4 id="会话分离">会话分离</h4><p>经过上面的操作程序已经正常运行起来了，接下来我们可以用<code>detach</code>将这个会话与SSH窗口分离开，让它自己在后台运行。</p><p>具体操作如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux detach<br></code></pre></td></tr></tbody></table></figure><p>然后小绿条消失，会话窗口恢复到SSH连接窗口。</p><blockquote><p>可能在运行程序之后，你的程序会一直打印输出导致你无法输入上述指令这时可以利用先按一次<code>Ctrl+b</code>松开后再按<code>d</code>快捷键分离会话。</p></blockquote><h4 id="会话接入">会话接入</h4><p>一个小时之后我们想看看自己的程序跑得怎么样了，这时使用<code>attach</code>便能接入会话查看训练过程。具体指令如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 接入之前 test 会话</span><br>$ tmux attach -t <span class="hljs-built_in">test</span><br></code></pre></td></tr></tbody></table></figure><h4 id="退出会话">退出会话</h4><p>会话分离操作只是将任务放置后台托管并没有断开连接，如果想在程序运行完之后断开连接退出会话则需要使用快捷键<code>Ctrl+d</code>或者键入<code>exit</code>。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">exit</span><br></code></pre></td></tr></tbody></table></figure><h3 id="2-其他操作">2. 其他操作</h3><h4 id="会话操作">会话操作</h4><ul><li>创建会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new -s &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>查看会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ctrl+b + s 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux ls<br><span class="hljs-comment"># or</span><br>$ tmux list-session<br></code></pre></td></tr></tbody></table></figure><ul><li>分离会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ctrl+b + d 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux detach<br></code></pre></td></tr></tbody></table></figure><ul><li>接入会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux attach -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>杀死（退出）会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ctrl+d</span><br><span class="hljs-comment"># or</span><br>$ tmux kill-session -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>切换会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux switch -t &lt;session-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>重命名会话</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux rename-session -t &lt;old-name&gt; &lt;new-name&gt;<br></code></pre></td></tr></tbody></table></figure><h4 id="窗格操作">窗格操作</h4><ul><li>划分窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 划分为上下两个窗格</span><br><span class="hljs-comment"># ctrl+b + " 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux split-window<br><br><br><span class="hljs-comment"># 划分为左右两个窗格</span><br><span class="hljs-comment"># ctrl+b + % 分开按</span><br><span class="hljs-comment"># or</span><br>$ tmux split-window -h<br></code></pre></td></tr></tbody></table></figure><ul><li>移动光标</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 光标切换到上方窗格</span><br>$ tmux select-pane -U<br><br><span class="hljs-comment"># 光标切换到下方窗格</span><br>$ tmux select-pane -D<br><br><span class="hljs-comment"># 光标切换到左边窗格</span><br>$ tmux select-pane -L<br><br><span class="hljs-comment"># 光标切换到右边窗格</span><br>$ tmux select-pane -R<br></code></pre></td></tr></tbody></table></figure><blockquote><p>除了使用上面的显示指令外也可以通过<code>ctrl+b</code>和<code>键盘上下左右方向键来移动光标</code>。</p></blockquote><ul><li>交换窗格位置</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前窗格上移</span><br>$ tmux swap-pane -U<br><br><span class="hljs-comment"># 当前窗格下移</span><br>$ tmux swap-pane -D<br></code></pre></td></tr></tbody></table></figure><p>貌似无法支持窗格左右移动？</p><ul><li>查看窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux list-pane<br></code></pre></td></tr></tbody></table></figure><ul><li>移除窗格</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除当前光标所在窗格</span><br><span class="hljs-comment"># ctrl+b + x 分开按</span><br><br><span class="hljs-comment"># 移除指定序号0的窗格</span><br>$ tmux kill-pane -t 0<br></code></pre></td></tr></tbody></table></figure><h4 id="窗口操作">窗口操作</h4><ul><li>创建窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux new-window<br><br><span class="hljs-comment"># 新建一个指定名称的窗口</span><br>$ tmux new-window -n &lt;window-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>重命名窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给当前窗口重名命</span><br>$ tmux rename-window &lt;new-name&gt;<br><br>$ tmux rename-window -t  &lt;old-name&gt; &lt;new-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>查看窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tmux list-window<br></code></pre></td></tr></tbody></table></figure><ul><li>切换窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到指定编号的窗口</span><br>$ tmux select-window -t &lt;window-number&gt;<br><br><span class="hljs-comment"># 切换到指定名称的窗口</span><br>$ tmux select-window -t &lt;window-name&gt;<br></code></pre></td></tr></tbody></table></figure><ul><li>关闭窗口</li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 移除指定的窗口</span><br>$ tmux kill-window -t &lt;name&gt;<br></code></pre></td></tr></tbody></table></figure><p>END</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tmux</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>风格迁移</title>
    <link href="/jasonyang.github.io/2021/11/30/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/"/>
    <url>/jasonyang.github.io/2021/11/30/%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="风格迁移">风格迁移</h2><hr><h3 id="1-什么是风格迁移">1. 什么是风格迁移</h3><h4 id="1-1-风格迁移任务介绍">1.1 风格迁移任务介绍</h4><hr><p>简而言之，风格迁移即是将一种图像的画风（颜色、纹理等）融合到另一幅图像中，使得融合后的图像能够以风格图像的色彩风格呈现原始图像的内容（任务、景物等前景）。具体示例可见下方图示。</p><center class="half">    <img src="style.png" style="zoom:50%;"><img src="content.png" style="zoom:50%;"></center><img src="fuse.png" style="zoom:50%;"><p>向风格迁移网络中输入风格图像<code>style</code>和内容图像<code>content</code>，网络便会输出融合<code>style</code>和<code>content</code>的新图像<code>style transfer</code>。</p><h4 id="1-2-风格迁移网络">1.2 风格迁移网络</h4><hr><p>基于深度学习的风格迁移任务的难点在于如何度量图片的风格，如若找到一种可以度量图像风格的数学模型，便可以基于反向传播训练风格迁移网络，以达到良好的风格迁移效果。</p><ol><li>Gram Matrix</li></ol><p>2015年Gatys利用Gram Matrix实现了图像风格的定量计算方法，现在大多数图像风格迁移的风格度量均采用Gram Matrix或者Gram Matrix的改进版本。因为本文所用风格度量方法也是基于Gram Matrix的，于是先简单介绍一下什么是Gram Matrix。</p><img src="gram.png" alt="gram" style="zoom: 25%;"><p>当输入一幅图像（<code>2xWxH</code>）进入卷积神经网络时，图像经过卷积层会得到<code>CxWxH</code>的图像特征，在特征的每个通道特征<code>1xWxH</code>上保留了图像的高语义特征（包括内容和风格），但是不同通道之间的学习到的特征内容是不同。比如输入是一幅人脸图像，经过卷积网络之后可能通道1学习到了人脸鼻子特征，而通道2学习到了眼睛特征，它们的特征主体是不一样的，但同时他们来源于同一幅图像，他们的风格应该是一样的，由此Gatys通过计算不同通道特征向量<code>W*H</code>的的协方差矩阵（<code>CxC</code>）定量刻画图像的风格。具体做法是将卷积网络中特征图每个通道的特征reshape成一个向量（<code>1xWxH-&gt;1xWH</code>）然后计算不同通道特征的（偏心）协方差矩阵，这个就矩阵就是Gram Matrix。操作示意图如上所示（图源<a href="https://blog.csdn.net/Hi_maxin/article/details/84979580?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BBgram&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-84979580.first_rank_v2_pc_rank_v29&amp;spm=1018.2226.3001.4187">CSDN</a>）：</p><ol start="2"><li>风格转换网络结构</li></ol><p>使用的风格转换网络来源于Cui的《Multi-style Transfer: Generalizing Fast Style Transfer to Several Genres》，网络结构图如下所示。</p><img src="transnet.png" style="zoom: 50%;"><p>从图中可以看到风格转换网络由两个网络拼接而成，<code>Image Transform Net</code>用于向陌生的图像融合学习到的风格特征；<code>Loss Network</code>仅用在网络训练阶段，借用<code>Loss Network</code>以得到图像的内容损失和风格损失，以此更新模型参数。具体而言，输入陌生图片$x$（一般情况下也是内容图像），经过<code>Image Transform Net</code>得到融合新风格的图像$\hat{y}$，然后将风格迁移后图像$\hat{y}$、风格图像$y_{s}$和内容图像（也即原始图像）$y_{c}$分别送入<code>Loss Network</code>，<code>Loss Network</code>是VGG-16的特征提取网络。分别保存三幅图像在前、后卷积层的输出响应（特征图），针对风格迁移后图像$\hat{y}$和风格图像$y_{s}$分别计算其Gram Matrix，然后利用<code>MSELoss()</code>度量风格差异；针对风格迁移后图像$\hat{y}$和内容图像$y_{c}$直接使用<code>MSELoss()</code>度量图像之间特征主体的差异。</p><h3 id="2-基于Pytorch的快速风格迁移实例">2. 基于Pytorch的快速风格迁移实例</h3><hr><blockquote><p>环境：windows 10 + RTX3060 + CUDA 11.4</p></blockquote><blockquote><p>requirements：</p></blockquote><figure class="highlight tcl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tcl">matplotlib==<span class="hljs-number">3.4</span><span class="hljs-number">.3</span><br>numpy==<span class="hljs-number">1.21</span><span class="hljs-number">.4</span><br>Pillow==<span class="hljs-number">8.4</span><span class="hljs-number">.0</span><br>torch==<span class="hljs-number">1.10</span><span class="hljs-number">.0</span><br>torchvision==<span class="hljs-number">0.11</span><span class="hljs-number">.1</span><br>tqdm==<span class="hljs-number">4.62</span><span class="hljs-number">.3</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>代码主要参考:<a href="https://blog.csdn.net/weixin_48866452/article/details/109309245">https://blog.csdn.net/weixin_48866452/article/details/109309245</a></p></blockquote><hr><h4 id="2-1-数据集构建">2.1 数据集构建</h4><hr><p>对于风格迁移任务来说训练样本不需要太多，最少两张图片便可完成风格转换的训练。本次选取了3张风格图片与6张内容图片构建风格迁移的数据集。风格和内容图片示例如下：</p><p><img src="datas.png" alt=""></p><p><img src="datac.png" alt=""></p><blockquote><p>样本图片来自于这个<a href="https://github.com/irasin/Pytorch_Style_Swap/tree/master">GitHub仓库</a>。</p></blockquote><p>具体的内容数据集加载方式如下方代码所示：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Content_Dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>(Content_Dataset, self).__init__()<br>        r_path = <span class="hljs-string">'dataset/content/'</span> <span class="hljs-comment"># 存放内容图片的路径</span><br>        c_img_name = os.listdir(r_path)<br>        self.c_img_path = [r_path+i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> c_img_name]<br>        self.transforms = T.Compose([<br>            T.Resize((<span class="hljs-number">512</span>, <span class="hljs-number">512</span>)),<br>            T.ToTensor(),<br>        ])<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index</span>):</span><br>        c_img = Image.<span class="hljs-built_in">open</span>(self.c_img_path[index])<br>        <br>        <span class="hljs-keyword">return</span> self.transforms(c_img)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.c_img_path)<br><br></code></pre></td></tr></tbody></table></figure><h4 id="2-2-风格迁移网络">2.2 风格迁移网络</h4><hr><p>迁移网络采用自编码结构，先用卷积将图像尺度缩小并学习高语义特征，再利用上采样将图像尺度放大，保证图像风格变换前后大小不变。迁移网络的Pytorch实现如下：</p><ol><li>TransNet</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResBlock</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, channels</span>):</span><br>        <span class="hljs-built_in">super</span>(ResBlock, self).__init__()<br>        self.layer = nn.Sequential(<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(channels), <span class="hljs-comment"># 在图像像素上，对每个通道的HW做归一化。</span><br>            nn.ReLU(),<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(channels)<br>        )<br>        self.relu = nn.ReLU()<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.relu(self.layer(x)+x)<br>    <br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransNet</span>(<span class="hljs-params">nn.Module</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>(TransNet, self).__init__()<br>        self.layer = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">64</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">128</span>),<br>            nn.ReLU(),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            ResBlock(<span class="hljs-number">128</span>),<br>            nn.Upsample(scale_factor=<span class="hljs-number">2</span>, mode=<span class="hljs-string">'nearest'</span>),<br>            nn.Conv2d(<span class="hljs-number">128</span>,<span class="hljs-number">64</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.Upsample(scale_factor=<span class="hljs-number">2</span>, mode=<span class="hljs-string">'nearest'</span>),<br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, bias=<span class="hljs-literal">False</span>),<br>            nn.InstanceNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>),<br>            nn.Sigmoid()<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.layer(x)<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>LossNet</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vgg16</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-built_in">super</span>(Vgg16, self).__init__()<br>        <span class="hljs-comment"># 直接加载预训练的VGG16网络提取图像特征</span><br>        loss_net = M.vgg16(pretrained=<span class="hljs-literal">True</span>)<br>        loss_net = loss_net.features<br>        self.feature1 = loss_net[:<span class="hljs-number">4</span>]<br>        self.feature2 = loss_net[<span class="hljs-number">4</span>:<span class="hljs-number">9</span>]<br>        self.feature3 = loss_net[<span class="hljs-number">9</span>:<span class="hljs-number">16</span>]<br>        self.feature4 = loss_net[<span class="hljs-number">16</span>:<span class="hljs-number">23</span>]<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        feature1 = self.feature1(x)<br>        feature2 = self.feature2(feature1)<br>        feature3 = self.feature3(feature2)<br>        feature4 = self.feature4(feature3)<br><br>        <span class="hljs-keyword">return</span> feature1, feature2, feature3, feature4<br>    <br></code></pre></td></tr></tbody></table></figure><h4 id="2-3-必要的工具函数">2.3 必要的工具函数</h4><hr><p>因为风格迁移没有定量评估迁移好坏的指标（一般都是通过人眼自行观察风格迁移结果去确定迁移性能），所以这里的工具函数目前包括Gram矩阵的计算函数和训练过程可视化函数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义gram矩阵</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_gram_matrix</span>(<span class="hljs-params">feature_map</span>):</span><br>    n, c, h, w = feature_map.shape<br>    feature_map = feature_map.reshape(n*c, h*w)<br>    gram_matrix = t.mm(feature_map, feature_map.t())<br>    <span class="hljs-keyword">return</span> gram_matrix.div(n*c*h*w)<br></code></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练过程损失可视化</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">training_process_visualization</span>(<span class="hljs-params">data</span>):</span><br>    style_loss = data[<span class="hljs-string">'style_loss'</span>]<br>    content_loss = data[<span class="hljs-string">'content_loss'</span>]<br>    total_loss = data[<span class="hljs-string">'total_loss'</span>]<br><br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(content_loss)), content_loss)<br>    plt.title(<span class="hljs-string">'content_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'content_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'content_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">2</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(style_loss)), style_loss)<br>    plt.title(<span class="hljs-string">'style_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'style_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'style_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">3</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(total_loss)), total_loss)<br>    plt.title(<span class="hljs-string">'total_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'total_loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'total_loss.png'</span>)<br>    plt.show()<br></code></pre></td></tr></tbody></table></figure><hr><p>通常在工具函数中还包括了存储网络超参数的<code>config.py</code>文件，本次风格迁移使用的超参数文件如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>():</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/hosi.jpg'</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/la_muse.jpg'</span><br>    <span class="hljs-comment"># style_img = 'dataset/style/trial.jpg'</span><br>    style_img = <span class="hljs-string">'dataset/style/sketch.png'</span><br>    nw = <span class="hljs-number">0</span> <span class="hljs-comment"># 多线程加载数据集（windows多线程加载有问题，所以改成了0）</span><br>    bs = <span class="hljs-number">3</span> <span class="hljs-comment"># batchsize</span><br>    epochs = <span class="hljs-number">150</span> <br>    lr = <span class="hljs-number">0.001</span><br>    wc = <span class="hljs-number">1</span> <span class="hljs-comment"># 内容损失的权重</span><br>    ws = <span class="hljs-number">100000</span> <span class="hljs-comment"># 风格损失的权重</span><br>    result_path = <span class="hljs-string">'checkpoints'</span> <span class="hljs-comment"># 训练结果保存文件夹</span><br>    save_frequency = <span class="hljs-number">30</span> <span class="hljs-comment"># 每30个epoch保存一次</span><br>    trans = T.ToTensor()<br></code></pre></td></tr></tbody></table></figure><h4 id="2-4-网络训练及测试">2.4 网络训练及测试</h4><hr><p>**网络训练：**通过更改<code>config.py</code>文件中的<code>style_img</code>路径更改训练的风格图片，然后完成2.1节所示3种风格的学习。具体的<code>train.py</code>如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">from</span> tqdm._tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torchvision.utils <span class="hljs-keyword">import</span> save_image<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><br><span class="hljs-keyword">from</span> dataset.my_dataset <span class="hljs-keyword">import</span> Content_Dataset<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> utils.tools <span class="hljs-keyword">import</span> get_gram_matrix, training_process_visualization<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> TransNet, Vgg16<br><br><br><span class="hljs-comment"># 初始化超参数实例</span><br>opt = Config()<br>device = t.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> t.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br><br><span class="hljs-comment"># 加载风格图片</span><br>img_style = opt.trans(Image.<span class="hljs-built_in">open</span>(opt.style_img)).unsqueeze(<span class="hljs-number">0</span>)<br>img_style = img_style.expand(opt.bs, img_style.shape[<span class="hljs-number">1</span>], img_style.shape[<span class="hljs-number">2</span>], img_style.shape[<span class="hljs-number">3</span>])<br>img_style = img_style.to(device)<br><br><span class="hljs-comment"># 创建结果保存文件夹</span><br><span class="hljs-comment"># 创建文件夹</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(opt.result_path):<br>    os.mkdir(opt.result_path)<br><br><span class="hljs-comment"># 初始化内容图片加载器</span><br>content_dataset = Content_Dataset()<br>content_loader = data.DataLoader(content_dataset, opt.bs, num_workers=opt.nw)<br><br><span class="hljs-comment"># 定义模型、优化器、损失函数</span><br>trans_net = TransNet().to(device)<br>loss_net = Vgg16().to(device).<span class="hljs-built_in">eval</span>()<br><br><br>optimizer = t.optim.AdamW(trans_net.parameters(), lr=opt.lr)<br>loss_func = nn.MSELoss().to(device)<br><br><br><span class="hljs-comment"># 利用Vgg16和Gram Matrix度量风格</span><br><span class="hljs-comment"># 此处不用管风格图片的大小因为最后生成的gram matrix大小均为NCxNC</span><br>styles = []<br>features = loss_net(img_style)<br><span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> features:<br>    <span class="hljs-comment"># 这里一定得加上detach()截断风格输入，不然会保留的风格图片的梯度，导致BP失败</span><br>    styles.append(get_gram_matrix(f).detach())<br><br><span class="hljs-comment"># 用于保存训练过程中的损失</span><br>style_loss = []<br>content_loss = []<br>total_loss = []<br><br><span class="hljs-comment"># 更改为tqdm模块内的trange函数以了解训练时间</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(<span class="hljs-number">1</span>, opt.epochs+<span class="hljs-number">1</span>):<br>    trans_net.train()<br>    <span class="hljs-keyword">for</span> i, image <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(content_loader):<br>        image_c = image.to(device)<br>        <span class="hljs-comment"># print(image_c.shape)</span><br>        image_g = trans_net(image_c)<br>       <br>        <span class="hljs-comment"># 计算风格损失</span><br>        loss_s = <span class="hljs-number">0.0</span><br>        outs = loss_net(image_g)<br>        <span class="hljs-keyword">for</span> out, style <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(outs, styles):<br>            loss_s += loss_func(get_gram_matrix(out), style)<br><br>        <span class="hljs-comment"># 计算内容损失</span><br>        contents = loss_net(image_c)<br>        loss_c2 = loss_func(outs[<span class="hljs-number">1</span>], contents[<span class="hljs-number">1</span>])<br><br>        <span class="hljs-comment"># 总损失</span><br>        loss = loss_c2 * opt.wc + loss_s * opt.ws<br>        <span class="hljs-comment"># print(epoch, loss.item(), loss_c2.item(), loss_s.item())</span><br>        style_loss.append(loss_s.item())<br>        content_loss.append(loss_c2.item())<br>        total_loss.append(loss.item())<br><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br>    <span class="hljs-comment"># lr_adjust.step()</span><br><br>    <br>    <span class="hljs-comment"># 中途保存模型</span><br>    <span class="hljs-keyword">if</span> epoch % opt.save_frequency == <span class="hljs-number">0</span>:<br>        all_data = <span class="hljs-built_in">dict</span>(<br>                optimizer=optimizer.state_dict(),<br>                model=trans_net.state_dict(),<br>                info=<span class="hljs-string">u'模型和优化器的所有参数'</span><br>            )<br>        p = opt.style_img.split(<span class="hljs-string">'/'</span>)[-<span class="hljs-number">1</span>]<br>        p = opt.result_path + <span class="hljs-string">"/"</span> + p.split(<span class="hljs-string">'.'</span>)[<span class="hljs-number">0</span>]<br>        t.save(all_data, <span class="hljs-string">'{}_trans_net_{}.pth'</span>.<span class="hljs-built_in">format</span>(p, epoch))<br>        img_path = <span class="hljs-string">'{}_fuse_{}.jpg'</span>.<span class="hljs-built_in">format</span>(p, epoch)<br>        _, _, h, w = img_style.size()<br>        trans = T.Resize((h, w))<br><br>        save_image([img_style.clone()[<span class="hljs-number">0</span>],trans(image_c[<span class="hljs-number">0</span>]), trans(image_g[<span class="hljs-number">0</span>])], <br>        img_path, padding=<span class="hljs-number">0</span>, normalize=<span class="hljs-literal">True</span>, <span class="hljs-built_in">range</span>=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>        <br>data = {<span class="hljs-string">'style_loss'</span>:style_loss, <span class="hljs-string">'content_loss'</span>:content_loss, <span class="hljs-string">'total_loss'</span>:total_loss}<br>training_process_visualization(data)<br></code></pre></td></tr></tbody></table></figure><p>训练过程的损失变化图如下：</p><center class="half"><img src="content_loss.png" alt="content_loss" style="zoom:50%;"><img src="style_loss.png" alt="style_loss" style="zoom: 50%;"><img src="total_loss.png" alt="total_loss" style="zoom:50%;"> </center><p>**网络测试：**构建<code>test.py</code>文件，加载训练时保存的模型参数，传入需要进行风格迁移的图片，得到风格迁移结果。具体的测试文件如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> name<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">import</span> glob<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.data.dataset <span class="hljs-keyword">import</span> T<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> TransNet<br><span class="hljs-keyword">from</span> torchvision.utils <span class="hljs-keyword">import</span> save_image<br><br>opt = Config()<br>device = t.device(<span class="hljs-string">'cuda'</span> <span class="hljs-keyword">if</span> t.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">'cpu'</span>)<br>trans_net = TransNet().to(device)<br><br>images = glob.glob(<span class="hljs-string">'dataset/content/**'</span>)<br>styles = [<span class="hljs-string">'hosi'</span>, <span class="hljs-string">'la_muse'</span>, <span class="hljs-string">'sketch'</span>, <span class="hljs-string">'trial'</span>]<br><span class="hljs-comment"># 遍历所有content图片</span><br><span class="hljs-keyword">for</span> img_p <span class="hljs-keyword">in</span> images: <br>img = opt.trans(Image.<span class="hljs-built_in">open</span>(img_p)).unsqueeze(<span class="hljs-number">0</span>)<br>img = img.to(device)<br><span class="hljs-comment"># 遍历风格</span><br><span class="hljs-keyword">for</span> style <span class="hljs-keyword">in</span> styles:<br>pred_models = [<span class="hljs-string">'checkpoints/{}_trans_net_{}.pth'</span>.<span class="hljs-built_in">format</span>(style, i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">30</span>, <span class="hljs-number">151</span>, <span class="hljs-number">30</span>)]<br>outs = []<br>outs.append(img[<span class="hljs-number">0</span>])<br><span class="hljs-comment"># 遍历风格的不同epoch模型</span><br><span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> pred_models:<br>all_data = t.load(m)<br>trans_net.load_state_dict(all_data[<span class="hljs-string">'model'</span>])<br>trans_net.<span class="hljs-built_in">eval</span>() <span class="hljs-comment"># 设置为推理模式</span><br>outs.append(trans_net(img)[<span class="hljs-number">0</span>])<br>name = style + <span class="hljs-string">'_'</span> + img_p[<span class="hljs-number">16</span>:]<br>save_image(outs, name, padding=<span class="hljs-number">0</span>, normalize=<span class="hljs-literal">True</span>, <span class="hljs-built_in">range</span>=(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure><h4 id="2-5-迁移结果展示">2.5 迁移结果展示</h4><hr><p>最后得到的风格迁移结果如下：</p><p><img src="out1.png" alt=""></p><p><img src="out2.png" alt=""></p><p><img src="out3.png" alt=""></p><p>综合以上三种风格的迁移可视化结果可以看出，（从纵轴上观察）网络在处理人物或者动物图像时，过度的看重了图像的主体特征（内容），忽略了图像风格，这样的情况应该可以通过候选不断调整内容损失和风格损失的权重取得两者之间的平衡去解决，但限于时间和算力，并未做过多的尝试。（从横轴上观察）随着网络训练的加深，迁移后图像的风格也更加自然（虽然我觉得其实<code>epoch=30</code>的时候更像是图像迁移的最终目的<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>）。</p><h3 id="3-总结">3. 总结</h3><p>通过这次风格迁移的学习（当然也只是最基础的部分），也让我大致了解风格迁移任务的整体流程，目前完成的效果因为训练时间的限制并不是太好，整体来看有点儿像是风格滤镜那种，不像第一节介绍那种实现图片风格的完全卡通化，后面如果有时间再来好好研究一下。这次任务也让我了解一些新的东西比如：利用<code>Gram Matrix</code>去定量衡量图片风格，自编码网络结构的搭建，利用<code>glob</code>库直接生成目录内文件路径以及不用重复造轮子直接利用Pytorch官方的<code>save_img()</code>保存<code>tensor</code>为图片等等。再接再厉，继续学习<span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><span class="github-emoji"><span>🐛</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f41b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>!</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Neural Style</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于CIFAR-10的Pytorch深度学习模板构建</title>
    <link href="/jasonyang.github.io/2021/11/13/%E5%9F%BA%E4%BA%8ECIFAR-10%E7%9A%84Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA/"/>
    <url>/jasonyang.github.io/2021/11/13/%E5%9F%BA%E4%BA%8ECIFAR-10%E7%9A%84Pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A8%A1%E6%9D%BF%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="基于CIFAR-10的Pytorch深度学习模板构建">基于CIFAR-10的Pytorch深度学习模板构建</h2><p>构建了一个基于CIFAR-10数据集的pytorch版本深度学习baseline，便于以后更快的迁移到其它深度学习任务中去。代码详情请参看<a href="https://github.com/JayHeYang/deep-learning-baseline">GitHub</a>，如有错误，请指正。</p><h3 id="数据集加载">数据集加载</h3><hr><ol><li><p>首先需要从CIFAR-10官网下载打包好的数据集</p><p>CIFAR-10数据集官网：<a href="http://www.cs.toronto.edu/~kriz/cifar.html">http://www.cs.toronto.edu/~kriz/cifar.html</a></p><ul><li><p>下载对应Python版本的数据集文件并解压</p></li><li><p>根据官网上的Python加载方式加载数据集</p></li></ul></li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unpickle</span>(<span class="hljs-params">file</span>):</span><br>    <span class="hljs-keyword">import</span> pickle<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file, <span class="hljs-string">'rb'</span>) <span class="hljs-keyword">as</span> fo:<br>        <span class="hljs-built_in">dict</span> = pickle.load(fo, encoding=<span class="hljs-string">'bytes'</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span><br><br>file = <span class="hljs-string">'/Users/morvan/Downloads/cifar-10-batches-py/data_batch_1'</span><br><span class="hljs-built_in">print</span>(unpickle(file).keys())<br></code></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dict_keys([<span class="hljs-string">b'batch_label'</span>, <span class="hljs-string">b'labels'</span>, <span class="hljs-string">b'data'</span>, <span class="hljs-string">b'filenames'</span>])<br></code></pre></td></tr></tbody></table></figure><p>经过以上解码加载之后，对返回值<code>dict</code>取<code>dict[b'labels']</code>和<code>dict[b'data']</code>分别获取batch1中的标签和数据，同理可以依次获得batch2-5以及test_batch的标签和数据。</p><blockquote><p><code>dict[b'labels']</code>返回一个长度为10000的列表，每个元素取值范围为0-9，分别对应10个类别的标签。</p></blockquote><blockquote><p><code>dict[b'data']</code>返回一个[10000, 3072]的矩阵，存储每张样本图片的RGB像素值。前1024（32x32）是R通道的像素数据，后面依次是B、G通道。</p></blockquote><ol start="2"><li>完成训练和测试集的样本的解压加载之后，开始第二步：构造数据集加载器类。这个类有三个主要的构造函数分别是：<ol><li><code>__init__()</code>用于初始化数据集路径和定义一些数据增强Pipline。</li><li><code>__getitem__()</code>用于依据所以获取对应数据增强后的样本（data+label）。</li><li><code>__len__()</code>返回样本集的样本数据量。</li></ol></li></ol><p>具体数据集加载器类构造如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cifar10_Dataset</span>(<span class="hljs-params">data.Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, data_roots, trans</span>):</span><br>        self.transforms = trans<br>        <span class="hljs-keyword">for</span> k, data_root <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(data_roots):<br>            data = unpickle(data_root)[<span class="hljs-string">b'data'</span>]<br>            label = unpickle(data_root)[<span class="hljs-string">b'labels'</span>]<br>            <span class="hljs-keyword">if</span> k == <span class="hljs-number">0</span>:<br>                self.all_data = data<br>                self.all_label = label<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># shape-&gt;(50000, 3072) or (10000, 3072)</span><br>                self.all_data = np.vstack((self.all_data, data)) <br>                <span class="hljs-comment"># shape-&gt;(50000, ) or (10000, )</span><br>                self.all_label = self.all_label + label <br>        <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-comment"># 调整数据形状为图片格式 (3x32x32), 之后调整通道和图片宽高的排序（CHW-&gt;HWC）</span><br>        sample = np.reshape(self.all_data[idx], (<span class="hljs-number">3</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)).transpose((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br>        img = Image.fromarray(sample)<br>        img = self.transforms(img) <span class="hljs-comment"># 3x32x32</span><br>        <span class="hljs-keyword">return</span> img, self.all_label[idx]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.all_label)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-comment"># storage location datasets</span><br>    file = <span class="hljs-string">'/Users/morvan/Downloads/cifar-10-batches-py/data_batch_1'</span><br>    roots = [file] <br>    trans = T.Compose([<br>        T.RandomCrop(<span class="hljs-number">32</span>),<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>]),<br>    ])<br>    dataset = Cifar10_Dataset(roots, trans)<br>    <span class="hljs-built_in">print</span>(dataset.__getitem__(<span class="hljs-number">10</span>)[<span class="hljs-number">0</span>].shape)<br></code></pre></td></tr></tbody></table></figure><p>至此数据集加载器类构造完成。</p><h3 id="网络模型搭建">网络模型搭建</h3><hr><p>网络模型为ResNet18，这里直接使用Pytorch官方提供的版本（手动更改最后全连接层的节点数为class_num=10）。</p><ol><li>ResNet18</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResNet18</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, num_classes</span>):</span><br>        <span class="hljs-built_in">super</span>(ResNet18, self).__init__()<br>        resnet18 = M.resnet18(pretrained=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 更改ResNet18最后全连接层的节点数以适应cifar10</span><br>        resnet18.fc = nn.Linear(resnet18.fc.in_features, num_classes)<br>        self.resnet = resnet18<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        <span class="hljs-keyword">return</span> self.resnet(x)<br></code></pre></td></tr></tbody></table></figure><h3 id="工具函数及超参数设置">工具函数及超参数设置</h3><hr><p>构造了两个工具函数<code>calculation_accuracy()</code>和<code>training_process_visualization()</code>分别用于计算准确率和训练过程的可视化。</p><ol><li>calculation_accuracy()</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculation_accuracy</span>(<span class="hljs-params">pred, label</span>):</span><br>    pred = pred.cpu().detach().numpy() <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>    pred = np.argmax(pred, axis=<span class="hljs-number">1</span>)<br>    <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>    right_count = np.<span class="hljs-built_in">sum</span>(pred == label.cpu().numpy()) <br>    acc = right_count / label.size(<span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> acc<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>training_process_visualization()</li></ol><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">training_process_visualization</span>(<span class="hljs-params">data</span>):</span><br>    train_acc = data[<span class="hljs-string">'train_acc'</span>]<br>    train_loss = data[<span class="hljs-string">'train_loss'</span>]<br>    test_acc = data[<span class="hljs-string">'test_acc'</span>]<br><br>    plt.figure(<span class="hljs-number">1</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_loss)), train_loss)<br>    plt.title(<span class="hljs-string">'trian_loss'</span>)<br>    plt.ylabel(<span class="hljs-string">'trian loss'</span>)<br>    plt.xlabel(<span class="hljs-string">'step'</span>)<br>    plt.savefig(<span class="hljs-string">'train_loss.png'</span>)<br><br>    plt.figure(<span class="hljs-number">2</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(train_acc)), train_acc)<br>    plt.title(<span class="hljs-string">'train_acc'</span>)<br>    plt.ylabel(<span class="hljs-string">'train acc'</span>)<br>    plt.xlabel(<span class="hljs-string">'step'</span>)<br>    plt.savefig(<span class="hljs-string">'train_acc.png'</span>)<br><br>    plt.figure(<span class="hljs-number">3</span>)<br>    plt.plot(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(test_acc)), test_acc)<br>    plt.title(<span class="hljs-string">'test_acc'</span>)<br>    plt.ylabel(<span class="hljs-string">'test acc'</span>)<br>    plt.xlabel(<span class="hljs-string">'epoch'</span>)<br>    plt.savefig(<span class="hljs-string">'test_acc.png'</span>)<br>    plt.show()<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><a href="http://config.py">config.py</a></li></ol><p>这个文件一般用来存储模型训练过程中的学习率，数据增强，batch size，损失函数等超参数。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms <span class="hljs-keyword">as</span> T<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>():</span><br>    train_roots = [<span class="hljs-string">'F:/DeepL/cifar-10-batches-py/data_batch_'</span><br>                        +<span class="hljs-built_in">str</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)]<br>    test_roots = [<span class="hljs-string">'F:/DeepL/cifar-10-batches-py/test_batch'</span>]<br>    net = <span class="hljs-string">'Res'</span> <span class="hljs-comment"># 网络结构</span><br>    num_classes = <span class="hljs-number">10</span> <span class="hljs-comment"># 类别数</span><br>    nw = <span class="hljs-number">0</span> <span class="hljs-comment"># 多线程加载数据集（windows多线程加载有问题，所以改成了0）</span><br>    wd = <span class="hljs-number">0.001</span> <span class="hljs-comment"># 权重衰减</span><br>    m = <span class="hljs-number">0.9</span> <span class="hljs-comment"># SGD动量</span><br>    bs = <span class="hljs-number">512</span> <span class="hljs-comment"># batchsize</span><br>    epochs = <span class="hljs-number">20</span> <br>    lr = <span class="hljs-number">0.001</span><br>    <span class="hljs-comment"># 自定义训练和测试数据集所用的数据增强</span><br>    train_trans = T.Compose([<br>        T.RandomCrop(<span class="hljs-number">32</span>),<br>        T.RandomRotation((-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)),<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])])<br>    test_trans = T.Compose([<br>        T.ToTensor(),<br>        T.Normalize(mean=[<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>],<br>                    std=[<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])])<br>    <br></code></pre></td></tr></tbody></table></figure><h3 id="训练和测试">训练和测试</h3><hr><h4 id="训练步骤">训练步骤</h4><ol><li>初始化超参数实例</li><li>定义数据集加载器实例</li><li>定义模型、优化器、损失函数、学习率调整器</li><li>用于保存训练过程中的损失和准确率（可以不用）</li><li>通过两层<code>for</code>循环开始迭代训练<ol><li>取数据（<code>net.train()</code>）</li><li>优化器梯度置零</li><li>前向传播预测</li><li>计算损失并反向传播</li><li>学习率调整</li><li>每个epoch测试一次（<code>net.eval()</code>）</li></ol></li><li>根据记录的数据可视化训练过程</li></ol><p>完整的<code>train.py</code>如下所示</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> t<br><span class="hljs-keyword">from</span> tqdm._tqdm <span class="hljs-keyword">import</span> trange<br><span class="hljs-keyword">from</span> torch.optim.lr_scheduler <span class="hljs-keyword">import</span> StepLR<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><br><span class="hljs-keyword">from</span> dataset.my_dataset <span class="hljs-keyword">import</span> Cifar10_Dataset<br><span class="hljs-keyword">from</span> utils.config <span class="hljs-keyword">import</span> Config<br><span class="hljs-keyword">from</span> utils.tools <span class="hljs-keyword">import</span> calculation_accuracy, training_process_visualization<br><span class="hljs-keyword">from</span> model.my_net <span class="hljs-keyword">import</span> ResNet18<br><br><br><span class="hljs-comment"># 初始化超参数实例</span><br>opt = Config()<br><br><span class="hljs-comment"># 初始化训练集、测试集加载器实例</span><br>trainset = Cifar10_Dataset(data_roots=opt.train_roots, trans=opt.train_trans)<br>trainset_loader = data.DataLoader(trainset, opt.bs, num_workers=opt.nw, shuffle=<span class="hljs-literal">True</span>)<br>testset = Cifar10_Dataset(data_roots=opt.test_roots, trans=opt.test_trans)<br>testset_loader = data.DataLoader(testset, opt.bs, num_workers=opt.nw)<br><br><span class="hljs-comment"># 定义模型、优化器、损失函数、学习率调整器</span><br>net = ResNet18(opt.num_classes)<br>optimizer = t.optim.SGD(net.parameters(), lr=opt.lr, momentum=opt.m, weight_decay=opt.wd)<br>loss_func = nn.CrossEntropyLoss()<br>lr_adjust = StepLR(optimizer, step_size=<span class="hljs-number">30</span>, gamma=<span class="hljs-number">0.1</span>)  <br><br><span class="hljs-comment"># 用于保存训练过程中的损失和准确率</span><br>train_loss = []<br>train_acc = []<br>test_acc = []<br><br><span class="hljs-keyword">if</span> t.cuda.is_available():<br>    net.cuda()<br>    loss_func.cuda()<br><br><span class="hljs-comment"># 更改为tqdm模块内的trange函数以了解训练时间</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> trange(<span class="hljs-number">1</span>, opt.epochs+<span class="hljs-number">1</span>):<br>    net.train()<br>    <span class="hljs-keyword">for</span> i, (data, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(trainset_loader):<br>        <span class="hljs-keyword">if</span> t.cuda.is_available():<br>            data, label = data.cuda(), label.cuda()<br><br>        optimizer.zero_grad()<br>        pred = net(data)<br><br>        loss = loss_func(pred, label)<br>        acc = calculation_accuracy(pred, label)<br>        loss.backward()<br>        optimizer.step()<br><br>         <span class="hljs-comment"># 如果没有用GPU加速，则把.cpu()删除</span><br>        train_loss.append(loss.cpu().detach().numpy())<br>        train_acc.append(acc)<br>        <span class="hljs-comment"># print('loss:', loss.cpu().detach().numpy(), "acc", acc)</span><br>    lr_adjust.step()<br><br>    <br>    <span class="hljs-comment"># 每训练完一轮进行一次测试</span><br>    net.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">for</span> j, (data, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(testset_loader):<br>        <span class="hljs-keyword">if</span> t.cuda.is_available():<br>            data, label = data.cuda(), label.cuda()<br>        test_pred = net(data)<br>        <br>        all_pred = test_pred <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> t.vstack((all_pred, test_pred))<br>        all_label = label <span class="hljs-keyword">if</span> j == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> t.cat((all_label, label))<br>    <br>    acc = calculation_accuracy(all_pred, all_label)<br>    test_acc.append(acc)<br><br><br>data = {<span class="hljs-string">'train_loss'</span>:train_loss, <span class="hljs-string">'train_acc'</span>:train_acc, <span class="hljs-string">'test_acc'</span>:test_acc}<br>training_process_visualization(data)<br></code></pre></td></tr></tbody></table></figure><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang<br><strong>Copyright Notice:</strong>  All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> unless stating additionally. 转载请注明出处。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>baseline</tag>
      
      <tag>Cifar10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git操作指南</title>
    <link href="/jasonyang.github.io/2021/09/25/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <url>/jasonyang.github.io/2021/09/25/Git%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="Git-操作指令">Git 操作指令</h2><h3 id="0-Git-是什么">0. Git 是什么</h3><hr><p>Git 是一个先进便捷的分布式版本控制系统。它可以实现对纯文本文件（code、txt、csv、md…）的修改提示（具体到某行）、回退到之前的版本、创建不同分支等等操作，这些操作都是可协作的。</p><h3 id="1-创建本地仓库（预备）">1. 创建本地仓库（预备）</h3><hr><p>打开Git Bash命令行窗口，然后配置一下自己的名字和邮箱（自报家门），方便协作者看到是谁修改提交了版本，配置之后全局有效，你在当前电脑上的每个Git仓库都是使用这个配置。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git config --global user.name <span class="hljs-string">"jasonyang"</span><br>$ git config --global user.email <span class="hljs-string">"jayheyang@gmail.com"</span><br></code></pre></td></tr></tbody></table></figure><ol><li><strong>切换到想要建立仓库的文件目录。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /h/code<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>在当前目录创建新的文件夹<code>learngit</code>, 然后切换到<code>learngit</code>目录。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir learngit<br>$ <span class="hljs-built_in">cd</span> learngit <br></code></pre></td></tr></tbody></table></figure><blockquote><p>可使用<code>pwd</code>指令查看当前目录</p></blockquote><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>out-&gt; /h/code/learngit<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>使用<code>git init</code>命令使得该目录变成可以被Git管理的仓库（文件夹）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br></code></pre></td></tr></tbody></table></figure><h3 id="2-将文件添加到仓库">2. 将文件添加到仓库</h3><hr><ol><li><strong>编写文本文件，可以是<code>.py</code>，<code>.md</code>， <code>.txt</code>等， 编写<code>readme.txt</code>，并保存到当前Git目录。</strong></li></ol><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># readme.txt</span><br>Git is <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> control <span class="hljs-keyword">system</span>.<br>balabala...<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>把文件添加到Git的暂存区。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add readme.txt<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>把所有暂存区的文件提交到Git仓库。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">"wrote a readme file"</span><br></code></pre></td></tr></tbody></table></figure><p><code>-m</code>指令表示对本次提交的文件添加一个说明。</p><h3 id="3-常用指令">3. 常用指令</h3><hr><h4 id="3-1-基础储备">3.1 基础储备</h4><hr><ul><li><strong>basic command</strong></li></ul><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init <br>$ git add test.py<br>$ git commit -m <span class="hljs-string">"modified XXXX"</span><br></code></pre></td></tr></tbody></table></figure><ol><li><strong>查看当前仓库状态，了解是否有些文件被删改。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li><strong>查看当前工作区文件与版本库文件有什么不同。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff readme.txt <span class="hljs-comment"># readme.txt与当前版本库里readme.txt的不同</span><br>$ git diff HEAD^ -- readme.txt <span class="hljs-comment"># readme.txt与上一个版本（上一次提交）里的readme.txt的异同。</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>找到不同之后可以根据情况使用<code>git add</code>和<code>git commit</code>添加并提交文件，或者使用<code>git reset</code>回退到修改前的版本。</p></blockquote><ol start="3"><li><strong>查看提交的版本日志，包括分支（如果有的话）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span><br>or<br>$ git <span class="hljs-built_in">log</span> --pretty=oneline<br><br>$ git <span class="hljs-built_in">log</span> --graph <span class="hljs-comment"># 可以看到分支的合并流程图</span><br></code></pre></td></tr></tbody></table></figure><p><code>--pretty=oneline</code>可以让返回的日志信息更加简略。</p><ol start="4"><li><strong>版本回退（针对已经进行<code>git add</code> 甚至<code>git commit</code>操作的情况）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset <span class="hljs-comment"># 移除仓库暂存区的修改，但不改变工作区文件，相当于撤销git add操作。</span><br>$ git reset &lt;commit id&gt; <span class="hljs-comment"># 将仓库分支回退到指定&lt;commit id&gt;版本， 其余同上。</span><br>$ git reset --hard <span class="hljs-comment"># 清除暂存区和工作区的改动。会强制修改工作区文件。</span><br>$ git reset --hard &lt;commit id&gt; <span class="hljs-comment"># 将仓库分支回退到指定&lt;commit id&gt;版本， 其余同上。</span><br><br>$ git reset --hard HEAD^ <span class="hljs-comment"># 回退到当前版本的上一个版本</span><br>$ git reset --hard HEAD~1 <span class="hljs-comment"># 回退到当前版本的上一个版本</span><br><br>$ git reset --hard HEAD^^ <span class="hljs-comment"># 回退到当前版本的上两个版本</span><br>$ git reset --hard HEAD~2 <span class="hljs-comment"># 回退到当前版本的上两个版本。</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>&lt;commit id&gt;</code>可以不用写全，类似<code>1098abd</code>这种前面几位就可以了。</p></blockquote><blockquote><p>没有加<code>--hard</code>的命令手动打开本地工作区文件例如<code>readme.txt</code>不会看到修改的内容撤销了，加了<code>--hard</code>的命令则会看到文件的内容回到了修改之前。</p></blockquote><ol start="5"><li><strong>撤销修改（针对还未将修改文件提交到暂存区或者仓库的情况）。</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -- readme.txt<br></code></pre></td></tr></tbody></table></figure><p>撤销工作区里<code>readme.txt</code>文件最近的一次修改，如果文件提交到暂存区，则需要采用第4点的<code>git reset</code>操作进行回退。</p><blockquote><p>注意：如果不小心将工作区文件<code>rm</code>删除了，也可以使用<code>git checkout -- &lt;file name&gt;</code>进行误删恢复， <code>checkout</code>指令就是保证工作区和版本库的文件一致。</p></blockquote><ol start="6"><li><p><strong>彻底删除文件</strong></p><ol><li>删除工作区文件</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ rm test.py<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>删除版本仓库文件</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rm test.py<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>向Git仓库报告本次删除操作</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">"remove test.py"</span><br></code></pre></td></tr></tbody></table></figure></li><li><p><strong>为每次提交打标签</strong></p><ol><li>为最近一次提交打标签</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.0 <span class="hljs-comment"># 为当前提交commit-&gt;HEAD打上v1.0的标签</span><br>$ git tag -a v1.0 -m <span class="hljs-string">"version 1.0 released"</span> <span class="hljs-comment"># 打标签同时，提供标签说明</span><br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>为指定<code>commit id</code>打标签</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v0.9 f64c633 <br>$ git tag -a v1.0 -m <span class="hljs-string">"version 1.0 released"</span> f64c633<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>查看标签</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag <span class="hljs-comment"># 查看已打的标签</span><br>$ git show v1.0 <span class="hljs-comment"># 详细查看v1.0本次提交操作</span><br></code></pre></td></tr></tbody></table></figure><ol start="4"><li>删除标签</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v1.0<br></code></pre></td></tr></tbody></table></figure><ol start="5"><li>推送标签到远程、删除远程标签</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin v1.0 <span class="hljs-comment"># 推送v1.0标签到远程`origin`分支</span><br>$ git push origin --tags <span class="hljs-comment"># 一次性推送所有标签</span><br></code></pre></td></tr></tbody></table></figure> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v1.0 <span class="hljs-comment"># 先删除本地标签</span><br>$ git push origin :refs/tags/v1.0 <span class="hljs-comment"># 用'push'删除远程</span><br></code></pre></td></tr></tbody></table></figure></li></ol><h4 id="3-分支管理">3. 分支管理</h4><hr><p>分支是Git里面关键的功能，其能够实现平行化版本时间线，也能合并不同分支时间线的版本。<br>推荐创建以下分支：</p><ul><li>master 默认创建的分支，负责更迭正式版本。</li><li>dev 协作分支，团队成员之间相互协作，测试版本更迭情况将在此分支的时间线上体现。</li><li>bug bug分支，一般只在本地库，用于修改程序bug。</li><li>feature 记录更迭自己本地更改的版本。</li></ul><p>团队协作的Git版本库分支示意图（图源<a href="https://www.liaoxuefeng.com/wiki/896043488029600/900005860592480">廖雪峰官方网站</a>）:</p><p><img src="1.png" alt=""></p><ol><li><strong>创建、查看分支</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev <span class="hljs-comment"># 创建并切换到dev分支</span><br>$ git switch -c dec <span class="hljs-comment"># 创建并切换到dev分支</span><br><br>$ git checkout master <span class="hljs-comment"># 切换到master分支</span><br>$ git switch master <span class="hljs-comment"># 切换到master分支</span><br></code></pre></td></tr></tbody></table></figure><p><code>switch</code>和<code>checkout</code>都可实现分支的创建与切换，老版本的<code>Git</code>使用<code>checkout</code>进行分支管理和文件恢复，现在分别由<code>switch</code>和<code>restore</code>管理。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch <span class="hljs-comment"># 查看当前版本库所有的分支</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>各个分支之前管理的版本文件相互独立，修改一个分支的版本文件不会影响另一个分支。</p></blockquote><ol start="2"><li><strong>合并、删除分支</strong></li></ol><p><strong>合并分支</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge dev <span class="hljs-comment"># 将dev分支合并到当前分支</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>单独调用<code>git merge</code>命令时会采用<code>Fast-Forward</code>合并模式，合并完成之后会将分支<code>dev</code>时间上的<code>commit</code>混合到分支<code>master</code>的时间线上去，此时如果实行版本回退则会回退到<code>dev</code>分支所提交的内容，而不是目标<code>master</code>分支上的内容。</p></blockquote><p>上述问题的解决办法就是使用<code>git merge --no-ff</code>指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge --no-ff -m <span class="hljs-string">"merge with no fast-forward"</span> dev<br></code></pre></td></tr></tbody></table></figure><p>该指令可以保留<code>dev</code>分支的提交信息,在分支<code>master</code>上进行版本回退时，可以正确退回<code>master</code>分支上的上一个版本，而不是<code>dev</code>分支上的上一个版本。</p><p><code>no-ff</code>合并操作包含了一次<code>git commit</code>，因此<code>-m</code>参数是为了加上提交说明。</p><blockquote><p>合并分支时，如果当前分支和被合并的分支都在上一个版本基础上进行了修改，合并会失败。同时发生合并冲突的文件例如<code>readme.txt</code>会自动添加内容告诉我们发生冲突的地方，此时需要手动修改冲突的文件。</p></blockquote><p><code>readme.txt</code>冲突发生后，打开文件可看到如下提示：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Git is a version control system.<br>balabala...<br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">Creating a new branch is quick &amp; simple.</span><br><span class="hljs-string">=======</span><br><span class="hljs-string">Creating a new branch is quick AND simple.</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev</span><br></code></pre></td></tr></tbody></table></figure><p>然后需要手动修改<code>readme.txt</code>文件为：</p><figure class="highlight livecodeserver"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Git is <span class="hljs-keyword">a</span> <span class="hljs-built_in">version</span> control <span class="hljs-keyword">system</span>.<br>balabala...<br>Creating <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch is quick <span class="hljs-keyword">and</span> simple.<br></code></pre></td></tr></tbody></table></figure><p>之后再执行<code>git add</code>和<code>git commit -m</code>提交到版本仓库，手动解决合并冲突。</p><p><strong>删除分支</strong></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d dev <span class="hljs-comment"># 删除dev分支</span><br></code></pre></td></tr></tbody></table></figure><p>如果分支未合并，使用上面的删除指令会报错，这时需要使用下面的指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -D dev <span class="hljs-comment"># 删除dev分支</span><br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>暂存工作区的任务</strong></li></ol><p>当遇到正在写的任务没写完，又发现了一个紧急任务时，需要当前任务先暂存起来，先处理紧急任务，处理完成之后再回到当前的任务中来。Git提供了解决方案：<code>git stash</code>。</p><ol><li>存储当前的任务(假设在<code>dev</code>分支)</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>去到紧急任务的分支，处理紧急任务</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch master<br>$ git XXX<br>....<br></code></pre></td></tr></tbody></table></figure><ol start="3"><li>回到之前任务分支，恢复任务</li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch dev<br>$ git stash list <span class="hljs-comment"># 查看被暂存的所有任务列表</span><br>$ git stash pop <span class="hljs-comment"># 恢复最近的一个暂存任务</span><br>$ git stash pop stash@{0} <span class="hljs-comment"># 恢复暂存的标号0任务，标号从list的输出信息中得到</span><br></code></pre></td></tr></tbody></table></figure><h3 id="4-远程仓库操作">4. 远程仓库操作</h3><hr><ol start="0"><li><strong>预备工作</strong></li></ol><p>第1步：创建私钥和公钥：打开<code>Git Bash</code>命令行窗口，输入下列指令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ssh-keygen -t rsa -C <span class="hljs-string">"jayheyang@gmail.com"</span>?<br></code></pre></td></tr></tbody></table></figure><blockquote><p>地址记得改成自己的email！！！</p></blockquote><p>创建完成之后会在用户目录下（例如<code>/c/Users/Administrator</code>）找到<code>.ssh</code>文件夹，里面会有两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>。</p><p>第2步：打开GitHub，登陆。然后依次点击：<code>用户头像</code>-&gt;<code>Settings</code>-&gt;左侧边栏的<code>SSH and GPG keys</code>-&gt;<code>New SSH key</code>。</p><p>第3步：打开<code>id_rsa.pub</code>文件，<code>ctrl A</code>全选，<code>ctrl C</code>复制， 切换到GitHub页面，<code>Title栏</code>随便写，相当于给你的这个密钥起名字。然后在<code>Key栏</code>中粘贴刚才复制的文本。</p><p><strong>预备工作完成。</strong></p><ol><li><p><strong>关联本地仓库与远程仓库</strong></p><ul><li>在GitHub上创建repository</li><li>进入创建的repo，获取SSH链接（形如<code>git@github.com:JayHeYang/learngit.git</code>）,打开<code>Git Bash</code>并切换到Git版本库目录，然后输入以下指令关联。</li></ul> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote add origin git@github.com:JayHeYang/learngit.git<br></code></pre></td></tr></tbody></table></figure><p><code>origin</code>是默认的远程仓库名，可自行修改。</p></li><li><p><strong>将本地仓库文件<code>push</code>上去</strong></p></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin master<br></code></pre></td></tr></tbody></table></figure><p><code>-u</code>的作用是将<code>本地master</code>分支和<code>远程master</code>分支关联起来，后面只需要进行<code>$ git push origin master</code>指令即可。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin master <span class="hljs-comment"># push到远程端的master分支</span><br>$ git push origin dev <span class="hljs-comment"># push到远程端的dev分支</span><br></code></pre></td></tr></tbody></table></figure><ol start="3"><li><strong>查看所关联的远程库，或者删除与远程库的关联</strong></li></ol><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote -v <span class="hljs-comment"># 查看当前本地仓库关联的远程库</span><br>$ git remote rm origin <span class="hljs-comment"># 解除与远程库origin的关联</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p><code>git remote rm</code>指令只是完成了解绑，如果要删除远程库中的文件还得在GitHub上修改。</p></blockquote><ol start="4"><li><p><strong>从远程仓库克隆文件</strong></p><p>1.切换到需要存储克隆文件的目录：</p>  <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ mkdir clonetest<br>$ <span class="hljs-built_in">cd</span> clonetest<br></code></pre></td></tr></tbody></table></figure><ol start="2"><li>获取需要克隆仓库的SSH连接（形如<code>git@github.com:JayHeYang/learngit.git</code>）执行<code>clone</code>指令。</li></ol> <figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:JayHeYang/learngit.git<br></code></pre></td></tr></tbody></table></figure><p>克隆完成。</p></li></ol><p>如果是其他协作人从远程仓库clone时默认只能看到<code>master</code>分支，如果想要在<code>dev</code>分支上做开发，需要创建远程<code>origin</code>的<code>dev</code>分支到本地，用以下命令行：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -d dev origin/dev <br>或者<br>$ git switch -c dev origin/dev<br></code></pre></td></tr></tbody></table></figure><p>5.<strong>抓取分支并<code>push</code>上去</strong></p><p>多人协作的流程是：<br>第1步：按照任务要求在本地分支上完成修改。<br>第2步：从远程仓库抓取分支，在本地合并，解决冲突。<br>第3步：将本地分支<code>push</code>到远程分支上，更新进度。</p><p>遵循以下命令顺序：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git switch dev <span class="hljs-comment"># 切换到工作分支</span><br>或者<br>$ git checkout -d dev origin/dev <span class="hljs-comment"># 将远程`origin`的`dev`分支创建到本地</span><br><br>$ git branch --set-upstream-to=origin/dev dev <span class="hljs-comment"># 将本地分支与远程分支绑定</span><br><br>$ git pull <span class="hljs-comment"># 抓取远程dev分支（抓取完成之后会自动进行合并）</span><br>$ git pull origin master <span class="hljs-comment"># 也可以直接指定分支抓取</span><br><br>手动解决合并冲突（如果有的话）<br><br>$ git add test.py <span class="hljs-comment"># 添加解决冲突后的文件</span><br><br>$ git commit -m <span class="hljs-string">"fix bug"</span><br><br>$ git push origin dev <span class="hljs-comment"># push到远程分支</span><br></code></pre></td></tr></tbody></table></figure><p><strong>2022年3月3日11:09:23 更新：</strong></p><hr><p><strong>注意</strong>：在<code>github</code>创建<code>repo</code>时如果添加了<code>readme.md</code>或者<code>LINCESE</code>等文件则在<code>push</code>之前得用以下操作：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git pull origin main --allow-unrelated-histories <span class="hljs-comment"># 使用这个指令，来把远程仓库和本地同步，消除两个文档间的差异，其实也就是把远端文件下载下来</span><br></code></pre></td></tr></tbody></table></figure><blockquote><p>为了回避种族歧视，现在创建<code>repo</code>默认将<code>master</code>更改为了<code>main</code>。</p></blockquote><p><code>Git</code>速查表：</p><p><img src="https://imgbed2333.oss-cn-beijing.aliyuncs.com/img/1009686-20160824100127870-1820786836.png" alt="img"></p><h3 id="参考文献">参考文献</h3><hr><p>廖雪峰的Git的教程：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p><p>Git快查表：<a href="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf">https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf</a></p><div class="note note-success">            <p><strong>Post author:</strong> jasonyang<br><strong>Copyright Notice:</strong>  All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> unless stating additionally. 转载请注明出处。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Simple Online and Realtime Tracking</title>
    <link href="/jasonyang.github.io/2021/09/23/Simple-Online-and-Realtime-Tracking/"/>
    <url>/jasonyang.github.io/2021/09/23/Simple-Online-and-Realtime-Tracking/</url>
    
    <content type="html"><![CDATA[<h2 id="Paper-Note-——-Simple-Online-and-Realtime-Tracking">Paper Note —— Simple Online and Realtime Tracking</h2><h3 id="1-文献简介">1.文献简介</h3><hr><ul><li>作者：Alex Bewley、Zongyuan Ge、Lionel Ott</li><li>关键词：Computer Vision, Multiple Object Tracking, Detection, Data Association</li><li>年份&amp;期刊（会议）名：IEEE 2016</li></ul><h3 id="2-结构和内容">2. 结构和内容</h3><hr><ol><li>介绍目标跟踪的任务流程，目前算法存在的问题和本文算法的优势</li><li>阐述研究背景和现状</li><li>介绍方法论<ul><li>检测模型</li><li>运动评估模型</li><li>数据关联</li><li>消失目标与先出现目标的销毁与创建</li></ul></li><li>实验部分</li></ol><h3 id="3-创新点-实验成果汇总">3.创新点/实验成果汇总</h3><hr><ol><li>提出了端到端的跟踪模型，运用了tracking by detection的思想，把主要关注点放在了assignment。</li><li>提出了跟踪领域的baseline。</li><li>运用Kalman filter和Hungarian algorithm进行匀速模型估计和人物关联。（cost matrix 是IOU distance）。</li><li>在score较高的情况下达到了一个高的FPS。</li></ol><h3 id="4-需要改进的地方">4.需要改进的地方</h3><hr><ol><li>仅用IOU的距离度量不能完全表达目标和预测之间的联系度。</li><li>检测的模型不算特别先进（当时还不错，backbone应该是在性能与运算量之间取了平衡）。</li><li>没有整合其他的人体信息，无法处理行人长时被遮挡的情况。</li></ol><h3 id="5-重要内容摘录">5.重要内容摘录</h3><hr><ul><li><p>指标的描述方法值得借鉴<br><img src="sort1.png" alt=""></p></li><li><p>算法速度和性能的二维展示图<br><img src="sort2.png" alt=""></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>目标跟踪</category>
      
      <category>论文总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MOT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Hexo框架下Fluid主题自带搜索框一直loading的问题</title>
    <link href="/jasonyang.github.io/2021/08/26/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E4%B8%8BFluid%E4%B8%BB%E9%A2%98%E6%90%9C%E7%B4%A2%E4%B8%80%E7%9B%B4loading%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/jasonyang.github.io/2021/08/26/%E8%A7%A3%E5%86%B3Hexo%E6%A1%86%E6%9E%B6%E4%B8%8BFluid%E4%B8%BB%E9%A2%98%E6%90%9C%E7%B4%A2%E4%B8%80%E7%9B%B4loading%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1>解决Hexo框架下Fluid主题自带搜索框一直loading的问题</h1><p>最开始根据Fluid主题创建个人博客时发现搜索框一直显示loading，不能进行本地搜索。最开始尝试百度和Google解答无果，便搁置了下去。最近有了时间便开始尝试解决，最终使用了一种可行的方案达到了本地搜索效果。</p><h2 id="问题描述">问题描述</h2><p>fluid主题无法搜索的问题如下：当点击博客页面的<strong>搜索</strong>按钮时，搜索页面会一直显示<strong>Loading</strong>，如下图所示：</p><p><img src="1.jpg" alt=""></p><h2 id="寻找原因">寻找原因</h2><p>打开自己的博客根文件夹，如我的就是<code>blog</code>，然后打开<code>themes\fluid\_config.yml</code>，找到<code>search</code>模块，如下所示：</p><p><img src="2.jpg" alt=""></p><p>从图中可以看到我们搜索索引的文件是<code>local-search.xml</code>，然命令行切换到<code>blog</code>目录启动hexo三连发。</p><figure class="highlight sas"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">cd blog<br>hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo s<br></code></pre></td></tr></tbody></table></figure><p>打开Chrome浏览器，通过localhost链接打开博客主页，然后点击搜索按钮，使用F12查看报错信息，可以看到如下报错。</p><p><img src="3.jpg" alt=""></p><p>可以发现是因为找不到这个搜索文件引发的报错，因此就有了解决方案version1。</p><h2 id="解决方案version1">解决方案version1</h2><p>因为搜索框一直loading的原因是找不到生成的<code>.xml</code>文件，然后尝试在自己的<code>blog</code>文件夹中查找<code>local-search.xml</code>文件，发现确实有随着<code>hexo g</code>命令一起生成的<code>local-search.xml</code>文件，但是文件内部并没有博客的内容，因此即使更换为该文件同样无法起到搜索作用（这个本地搜索功能本质上就是检索<code>.xml</code>文件内部的内容，因此没有博客内容的<code>.xml</code>文件起不到任何检索作用）。</p><p>接下来仔细查看<code>blog</code>文件夹，发现在<code>blog\public\</code>文件夹内生成了一个<code>search.xml</code>文件，该文件包含了博客内部的内容应该能起到检索作用。那么，开始修改！同样，打开<code>blog\themes\fluid\_config.yml</code>，找到<code>search</code>模块，更改path如下所示：</p><p><img src="4.jpg" alt=""></p><p>再次启动hexo三连大法，然后可以看到<code>主页</code>的搜索已经可以正常检索了，然而当点击到<code>分类</code>d等其他页面时，再点击搜索，同样还是Loading。</p><p><img src="5.jpg" alt=""><br><img src="1.jpg" alt=""></p><p>再次使用F12查看问题</p><p><img src="6.jpg" alt=""></p><p>发现全使用<code>search.xml</code>之后在跳转其他页面时Fluid会自动在地址上加入页面标签，比如分类页面就加上了<code>categories</code>(主页时是<code>http://localhost:4000/jasonyang.github.io/search.xml</code>，而分类页变为了<code>http://localhost:4000/jasonyang.github.io/categories/search.xml</code>)</p><p>然后就想到了使用绝对的文件索引地址，由此再每次切换页面时检索文件的地址就不会发生变化。</p><h2 id="解决方案version2">解决方案version2</h2><p>因为这个博客是为了部署到GitHub上面，因此这里将<code>blog\themes\fluid\_config.yml</code>，文件<code>search</code>版块的path更改为<code>博客项目的地址</code>+<code>search.xml</code>。例如：</p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">path: <span class="hljs-regexp">//</span>jayheyang.github.io<span class="hljs-regexp">/jasonyang.github.io/</span>search.xml<br></code></pre></td></tr></tbody></table></figure><p>最后<code>hexo d</code>部署到GitHub Pages，测试结果如下：</p><p><img src="7.jpg" alt=""></p><hr><p>挖个坑，2021年8月13日之后在使用<code>hexo d</code>部署时会遇到<code>Spawn failed</code>错误，网上搜索该错误的解决方法都不对，改天再说如何解决。</p><div class="note note-success">            <p><strong>Post author:</strong> jasonyang<br><strong>Copyright Notice:</strong>  All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> unless stating additionally. 转载请注明出处。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Hexo和GitHub搭建自己的博客网站</title>
    <link href="/jasonyang.github.io/2021/08/26/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/jasonyang.github.io/2021/08/26/%E5%9F%BA%E4%BA%8EHexo%E5%92%8CGitHub%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h3 id="基于Hexo和GitHub搭建自己的博客网站">基于Hexo和GitHub搭建自己的博客网站</h3><p>单边联动，基本框架搭建请参考Luo Xu的博客：点击<a href="https://ryanluoxu.github.io/2017/11/24/%E7%94%A8-Hexo-%E5%92%8C-GitHub-Pages-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">这里</a>跳转。</p><h3 id="主题使用">主题使用</h3><p>本篇博客采用的是Fluid主题，主题的仓库链接如下：<a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>主题的详细使用指南：<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/">https://fluid-dev.github.io/hexo-fluid-docs/guide/</a></p><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang<br><strong>Copyright Notice:</strong>  All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> unless stating additionally. 转载请注明出处。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown简易指南</title>
    <link href="/jasonyang.github.io/2021/07/28/Markdown%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/"/>
    <url>/jasonyang.github.io/2021/07/28/Markdown%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1>Markdown简易指南</h1><h2 id="文档标题">文档标题</h2><p>文档的标题级别通过<code>#</code>数量的多少来衡量，<code>#</code>号数量越多则级别越大，但字号越小。最后一个<code>#</code>号和标题文字之间有一个空格，且文档最多支持六级标题，具体示例如下：</p><h3 id="三级标题">三级标题</h3><h4 id="四级标题">四级标题</h4><h5 id="五级标题">五级标题</h5><p><img src="1.jpg" alt=""></p><h2 id="创建列表">创建列表</h2><h3 id="创建无序列表">创建无序列表</h3><p>在英文输入法下，通过输入<code>- </code>符号创建无序列表。</p><ul><li>无序列表1</li><li>无序列表2</li></ul><h3 id="创建有序列表">创建有序列表</h3><p>在英文输入法下，通过输入<code>1. </code>数字标记创建有序列表</p><ol><li>有序列表1</li><li>有序列表2</li></ol><p><img src="2.jpg" alt=""></p><h3 id="列表嵌套">列表嵌套</h3><p>再完成一种列表的创建之后回车下一行（可能需要删除掉下一行自动添加的同级列表标记），键入<code>Tap</code>创建嵌套列表，嵌套列表的类型由<code>Tap</code>后输入的<code>- </code>或者<code>1. </code>符号决定。</p><ol><li>有序列表1<ul><li>无序列表1.1</li><li>无序列表1.2</li></ul></li><li>有序列表2<ol><li>有序列表2.1</li><li>有序列表2.2</li></ol></li></ol><p><img src="3.jpg" alt=""></p><h3 id="创建任务清单列表">创建任务清单列表</h3><p>在英文输入法下通过键入<code>- [ ] </code>创建未完成的任务清单；通过键入<code>- [x] </code>创建已完成的任务清单。任务清单同样可以嵌套，方法同样是利用<code>Tap</code>缩进决定嵌套级别，然后通过规定符号标记确定嵌套列表的类型。</p><ul><li>[ ] 这是一个未完成的任务：锻炼<ol><li>手臂肌肉锻炼</li><li>篮球技巧联系</li></ol></li></ul><div>            <input type="checkbox" disabled="" checked="checked">这是一个已完成的任务：刷B站          </div><div>            <input type="checkbox" disabled="" checked="checked">木鱼水心的视频          </div><div>            <input type="checkbox" disabled="" checked="checked">何同学的视频          </div><p><img src="4.jpg" alt=""></p><h2 id="创建分割线">创建分割线</h2><p>可以发现在创建文档标题时，一二级标题下面会自动存在分割线，而其他的标题下面没有分割线，而通过三个以上的<code>*</code>或者<code>-</code>符号可以手动创建分割线。</p><hr><hr><p><img src="5.jpg" alt=""></p><h2 id="创建表格">创建表格</h2><p>在英文输入法下，通过<code>|</code>和<code>-</code>的组合可以创建表格。</p><table><thead><tr><th>表头1</th><th>表头2</th><th>表头3</th></tr></thead><tbody><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr><tr><td>内容1</td><td>内容2</td><td>内容3</td></tr></tbody></table><table><thead><tr><th>序号</th><th>标题</th><th>网址</th></tr></thead><tbody><tr><td>01</td><td>百度</td><td><a href="https://www.baidu.com">https://www.baidu.com</a></td></tr><tr><td>02</td><td>谷歌</td><td><a href="https://www.google.com">https://www.google.com</a></td></tr></tbody></table><p><img src="6.jpg" alt=""></p><h3 id="表格的对齐格式">表格的对齐格式</h3><p>通过在<code>----</code>两天添加英文冒号可以指定表格每列的对齐方式，<code>:----</code>、<code>:----:</code>和<code>----:</code>分别表示左对齐、居中对齐和右对齐。</p><table><thead><tr><th style="text-align:left">序号（左对齐）</th><th style="text-align:center">标题（居中对齐）</th><th style="text-align:right">网址（右对齐）</th></tr></thead><tbody><tr><td style="text-align:left">01</td><td style="text-align:center">百度</td><td style="text-align:right"><a href="https://www.baidu.com">https://www.baidu.com</a></td></tr><tr><td style="text-align:left">02</td><td style="text-align:center">谷歌</td><td style="text-align:right"><a href="https://www.google.com">https://www.google.com</a></td></tr></tbody></table><p><img src="7.jpg" alt=""></p><h2 id="插入图片">插入图片</h2><p>通过<code>![图片描述](图片网址)</code>在文档中插入图片，图片网址可以是本地地址也可以是网络图片地址，图片描述可以省略。</p><p><img src="markdown_logo.png" alt="Markdown Logo"></p><p><img src="8.jpg" alt=""></p><h2 id="插入链接">插入链接</h2><p>通过<code>[链接说明](网址链接)</code>在文档中插入网址连接，一般来说链接说明不能省略。</p><p><a href="https://www.baidu.com/">百度</a></p><p><a href="https://www.google.com/">谷歌</a></p><p><a href="https://www.github.com/">GitHub</a></p><p><img src="9.jpg" alt=""></p><h3 id="多次引用同一个网址，可以为网址指定索引标签">多次引用同一个网址，可以为网址指定索引标签</h3><p>通过<code>[索引标签]:网址连接</code>创建网址的索引标签，然后在使用<code>[链接说明][索引标签]</code>索引网址。</p><p>这里是我们常用的几个网址连接： <a href="https://www.google.com/">谷歌</a> 、<a href="https://www.baidu.com/">百度</a>和 <a href="https://www.github.com/">GitHub</a></p><p><img src="10.jpg" alt=""></p><h3 id="插入目录锚点（实现文章内部点击跳转）">插入目录锚点（实现文章内部点击跳转）</h3><p>通过<code>[目录名称](#索引标签)</code>生成目录锚点，索引标签必须和要跳转的标题章节名称对应（注：该方法只能跳转到文档标题开头处，正文不能跳转）。如果图方便生成文档目录的话可以直接采用<code>[TOC]</code>命令生成当前文档的目录。</p><p>目标检测入门算法：</p><ul><li><a href="#YOLO%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">YOLO</a></li><li>[Faster R-CNN](#Faster R-CNN算法简介)</li><li><a href="#SSD%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B">SSD</a></li></ul><h4 id="YOLO算法简介">YOLO算法简介</h4><h4 id="Faster-R-CNN算法简介">Faster R-CNN算法简介</h4><h4 id="SSD算法简介">SSD算法简介</h4><p><img src="11.jpg" alt=""></p><h4 id="快捷生成目录">快捷生成目录</h4><p>[TOC]</p><h2 id="插入代码块">插入代码块</h2><h3 id="插入行内代码">插入行内代码</h3><p>通过使用成对的左上撇号（`）插入行内代码。</p><p>就如<code>train_func</code>所示，巴拉巴拉…</p><h3 id="插入整段代码块">插入整段代码块</h3><p>通过使用成对的三个左上撇号（`）在文档中插入代码块，同时在第一组左上撇号的后面输入代码块使用的脚本语言例如python。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">print_func</span>()</span><br><span class="hljs-function"><span class="hljs-title">print</span>(<span class="hljs-params"><span class="hljs-string">'hello, world!'</span></span>)</span><br></code></pre></td></tr></tbody></table></figure><p><img src="12.jpg" alt=""></p><h2 id="插入公式">插入公式</h2><p>分数：$$ f(x,y) = \frac{x^2}{y^3} $$</p><p>省略号：$$ f(x_1, x_2, \ldots, x_n) = x_1 + x_2 + \cdots + x_n $$</p><p><img src="13.jpg" alt=""></p><h2 id="标记引用段落">标记引用段落</h2><p>某几句话或者一句话需要特别标注是可以采用“引用”样式，使用方法是在需要引用的文字前面添加<code>&gt; </code>符号。</p><blockquote><p>这句话很重要，引用起来。</p></blockquote><h3 id="可以嵌套引用">可以嵌套引用</h3><blockquote><p>这是第一级引用、</p><blockquote><p>这是第二级引用</p><blockquote><p>这是第三级引用</p></blockquote></blockquote></blockquote><p><img src="14.jpg" alt=""></p><h2 id="常用标记">常用标记</h2><p>下面介绍正文的一些处理样式包括粗体、斜体、删除线、文本高亮、下划线、上下标等等。</p><p><strong>粗体</strong>、<em>斜体</em>、==高亮==、<s>删除线</s>、<u>下划线</u>、我是^上标^、我是~下标~</p><p><img src="15.jpg" alt=""></p><h3 id="转义符号">转义符号</h3><p>因为在Markdown中星号、加减号、括号等都有相应的指示作用，因此如果需要展示使用这些符号本身是需要用到转义字符<code>\</code>。</p><p>\<br>’<br>*<br>_<br>{}<br>[]<br>()<br>+<br>.<br>!</p><p><img src="16.jpg" alt=""></p><h3 id="插入emoji表情">插入emoji表情</h3><p>插入emoji表情的方法如下，即在成对的<code>:</code>中间填入表情对应的英文名称即可。</p><p><span class="github-emoji"><span>🥶</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f976.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><span class="github-emoji"><span>🥵</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f975.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><span class="github-emoji"><span>😄</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><span class="github-emoji"><span>😆</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br><span class="github-emoji"><span>👏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><p>更多表情符号请参考这个<a href="https://www.einsition.com/tools/emojicheatsheet">链接</a></p><p><img src="17.jpg" alt=""></p><h2 id="注意事项">注意事项</h2><p>通常在正文与列表项、表格项、文档标题之间都需要留有空行。</p><hr><div class="note note-success">            <p><strong>Post author:</strong> jasonyang<br><strong>Copyright Notice:</strong>  All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">CC BY-NC-SA 3.0</a> unless stating additionally. 转载请注明出处。</p>          </div>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode题目积累</title>
    <link href="/jasonyang.github.io/2021/07/22/LeetCode%E9%A2%98%E7%9B%AE%E7%A7%AF%E7%B4%AF/"/>
    <url>/jasonyang.github.io/2021/07/22/LeetCode%E9%A2%98%E7%9B%AE%E7%A7%AF%E7%B4%AF/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/jasonyang.github.io/"/>
    <url>/jasonyang.github.io/</url>
    
    <content type="html"><![CDATA[<p>Hello 大家好，我是Jason Yang，目前在电子科技大学读研究生，研究方向是模式识别。</p><p>这个博客主要用于记录和积累学习路上的知识、经验，以求形成系统的体系，也便于以后忘记时及时复习巩固。</p><p>有时也会分享一些读书或观影笔记（如果研究生有时间看课外书的话<span class="github-emoji"><span>😂</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>），先就这样吧<span class="github-emoji"><span>😉</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f609.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
    
  </entry>
  
  
  
</search>
